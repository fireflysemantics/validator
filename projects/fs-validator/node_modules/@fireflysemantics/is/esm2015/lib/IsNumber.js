import { IsError } from './IsError';
import { Types } from './types';
import { ValidationConstraintEnum } from './ValidationConstraintEnum';
/**
 * Default options for IsNumber
 */
export const IS_NUMBER_OPTIONS_DEFAULTS = {
    allowNaN: false,
    allowInfinity: true
};
/**
 * Check if a given value is a number.
 *
 * Default `IsNumberOptions` allow
 * `-Infinity, Infinity` but disallow `NaN`.
 *
 * @param target The value being checked.
 * @param options The optional configuration {@link IsNumberOptions}.
 * @return True if the value is a number, false otherwise.
 */
export function isNumber(target, options = IS_NUMBER_OPTIONS_DEFAULTS) {
    if (target === Infinity || target === -Infinity) {
        return !!options.allowInfinity;
    }
    if (Number.isNaN(target)) {
        return !!options.allowNaN;
    }
    return Number.isFinite(target);
}
/**
 * Utility method for throwing an error if the {@link isNumber} test fails.
 *
 * @param target The target value being checked
 * @param field The name of the field containing the number
 * @param code Optional nervous system code
 * @param options Optional {@link IsNumberOptions} instance.
 * @throws IsError if the target is not a number
 * @returns false if an {@link IsError} is not thrown
 */
export function isNumberError(target, field, code, options) {
    const o = options ? options : IS_NUMBER_OPTIONS_DEFAULTS;
    if (!isNumber(target)) {
        const message = `The field ${field} is not a number.  
             The options used to perform the check were ${JSON.stringify(o)}.`;
        throw new IsError(message, target, field, ValidationConstraintEnum.IS_NUMBER, Types.NUMBER, code);
    }
    return false;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSXNOdW1iZXIuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AZmlyZWZseXNlbWFudGljcy9pcy8iLCJzb3VyY2VzIjpbImxpYi9Jc051bWJlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sV0FBVyxDQUFBO0FBQ25DLE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSxTQUFTLENBQUE7QUFDL0IsT0FBTyxFQUFFLHdCQUF3QixFQUFFLE1BQU0sNEJBQTRCLENBQUE7QUFXckU7O0dBRUc7QUFDSCxNQUFNLENBQUMsTUFBTSwwQkFBMEIsR0FBbUI7SUFDckQsUUFBUSxFQUFFLEtBQUs7SUFDZixhQUFhLEVBQUUsSUFBSTtDQUN2QixDQUFBO0FBRUQ7Ozs7Ozs7OztHQVNHO0FBQ0gsTUFBTSxVQUFVLFFBQVEsQ0FBQyxNQUFXLEVBQ2hDLFVBQTJCLDBCQUEwQjtJQUNyRCxJQUFJLE1BQU0sS0FBSyxRQUFRLElBQUksTUFBTSxLQUFLLENBQUMsUUFBUSxFQUFFO1FBQy9DLE9BQU8sQ0FBQyxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUM7S0FDaEM7SUFFRCxJQUFJLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLEVBQUU7UUFDeEIsT0FBTyxDQUFDLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQztLQUMzQjtJQUNELE9BQU8sTUFBTSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUNqQyxDQUFDO0FBRUg7Ozs7Ozs7OztHQVNHO0FBQ0gsTUFBTSxVQUFVLGFBQWEsQ0FBQyxNQUFjLEVBQUUsS0FBYSxFQUFFLElBQWEsRUFBRSxPQUF3QjtJQUNoRyxNQUFNLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsMEJBQTBCLENBQUE7SUFFeEQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsRUFBRTtRQUNyQixNQUFNLE9BQU8sR0FDUCxhQUFhLEtBQUs7MERBQzRCLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQTtRQUN4RSxNQUFNLElBQUksT0FBTyxDQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLHdCQUF3QixDQUFDLFNBQVMsRUFBRSxLQUFLLENBQUMsTUFBTSxFQUFHLElBQUksQ0FBQyxDQUFBO0tBQ25HO0lBQ0QsT0FBTyxLQUFLLENBQUE7QUFDaEIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IElzRXJyb3IgfSBmcm9tICcuL0lzRXJyb3InXG5pbXBvcnQgeyBUeXBlcyB9IGZyb20gJy4vdHlwZXMnXG5pbXBvcnQgeyBWYWxpZGF0aW9uQ29uc3RyYWludEVudW0gfSBmcm9tICcuL1ZhbGlkYXRpb25Db25zdHJhaW50RW51bSdcblxuLy9UT0RPIC0gVGhpcyBzaG91bGQgcHJvYmFibHkgYmUgbW92ZWQgdG8gQGZpcmVmbHlzZW1hbnRpY3MvdmFsaWRhdG9ydHNcbi8qKlxuICogSXNOdW1iZXJPcHRpb25zLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIElzTnVtYmVyT3B0aW9ucyB7XG4gICAgYWxsb3dOYU4/OiBib29sZWFuO1xuICAgIGFsbG93SW5maW5pdHk/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIERlZmF1bHQgb3B0aW9ucyBmb3IgSXNOdW1iZXJcbiAqL1xuZXhwb3J0IGNvbnN0IElTX05VTUJFUl9PUFRJT05TX0RFRkFVTFRTOklzTnVtYmVyT3B0aW9ucyA9IHtcbiAgICAgYWxsb3dOYU46IGZhbHNlLCBcbiAgICAgYWxsb3dJbmZpbml0eTogdHJ1ZSBcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIGdpdmVuIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogXG4gKiBEZWZhdWx0IGBJc051bWJlck9wdGlvbnNgIGFsbG93IFxuICogYC1JbmZpbml0eSwgSW5maW5pdHlgIGJ1dCBkaXNhbGxvdyBgTmFOYC5cbiAqIFxuICogQHBhcmFtIHRhcmdldCBUaGUgdmFsdWUgYmVpbmcgY2hlY2tlZC5cbiAqIEBwYXJhbSBvcHRpb25zIFRoZSBvcHRpb25hbCBjb25maWd1cmF0aW9uIHtAbGluayBJc051bWJlck9wdGlvbnN9LlxuICogQHJldHVybiBUcnVlIGlmIHRoZSB2YWx1ZSBpcyBhIG51bWJlciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNOdW1iZXIodGFyZ2V0OiBhbnksXG4gICAgb3B0aW9uczogSXNOdW1iZXJPcHRpb25zID0gSVNfTlVNQkVSX09QVElPTlNfREVGQVVMVFMpOiBib29sZWFuIHtcbiAgICBpZiAodGFyZ2V0ID09PSBJbmZpbml0eSB8fCB0YXJnZXQgPT09IC1JbmZpbml0eSkge1xuICAgICAgcmV0dXJuICEhb3B0aW9ucy5hbGxvd0luZmluaXR5O1xuICAgIH1cbiAgXG4gICAgaWYgKE51bWJlci5pc05hTih0YXJnZXQpKSB7XG4gICAgICByZXR1cm4gISFvcHRpb25zLmFsbG93TmFOO1xuICAgIH1cbiAgICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKHRhcmdldCk7XG4gIH1cblxuLyoqXG4gKiBVdGlsaXR5IG1ldGhvZCBmb3IgdGhyb3dpbmcgYW4gZXJyb3IgaWYgdGhlIHtAbGluayBpc051bWJlcn0gdGVzdCBmYWlscy5cbiAqIFxuICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IHZhbHVlIGJlaW5nIGNoZWNrZWRcbiAqIEBwYXJhbSBmaWVsZCBUaGUgbmFtZSBvZiB0aGUgZmllbGQgY29udGFpbmluZyB0aGUgbnVtYmVyXG4gKiBAcGFyYW0gY29kZSBPcHRpb25hbCBuZXJ2b3VzIHN5c3RlbSBjb2RlXG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25hbCB7QGxpbmsgSXNOdW1iZXJPcHRpb25zfSBpbnN0YW5jZS5cbiAqIEB0aHJvd3MgSXNFcnJvciBpZiB0aGUgdGFyZ2V0IGlzIG5vdCBhIG51bWJlclxuICogQHJldHVybnMgZmFsc2UgaWYgYW4ge0BsaW5rIElzRXJyb3J9IGlzIG5vdCB0aHJvd25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTnVtYmVyRXJyb3IodGFyZ2V0OiBudW1iZXIsIGZpZWxkOiBzdHJpbmcsIGNvZGU/OiBzdHJpbmcsIG9wdGlvbnM/OklzTnVtYmVyT3B0aW9ucyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IG8gPSBvcHRpb25zID8gb3B0aW9ucyA6IElTX05VTUJFUl9PUFRJT05TX0RFRkFVTFRTXG4gIFxuICAgIGlmICghaXNOdW1iZXIodGFyZ2V0KSkge1xuICAgICAgY29uc3QgbWVzc2FnZTogc3RyaW5nID0gXG4gICAgICAgICAgICBgVGhlIGZpZWxkICR7ZmllbGR9IGlzIG5vdCBhIG51bWJlci4gIFxuICAgICAgICAgICAgIFRoZSBvcHRpb25zIHVzZWQgdG8gcGVyZm9ybSB0aGUgY2hlY2sgd2VyZSAke0pTT04uc3RyaW5naWZ5KG8pfS5gXG4gICAgICB0aHJvdyBuZXcgSXNFcnJvcihtZXNzYWdlLCB0YXJnZXQsIGZpZWxkLCBWYWxpZGF0aW9uQ29uc3RyYWludEVudW0uSVNfTlVNQkVSLCBUeXBlcy5OVU1CRVIsICBjb2RlKVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2Vcbn0iXX0=