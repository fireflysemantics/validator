import { assertString } from '../util/assertString';
/* eslint-disable max-len */
// from http://goo.gl/0ejHHW
const iso8601 = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
/* eslint-enable max-len */
const isValidDate = (str) => {
    // str must have passed the ISO8601 check
    // this check is meant to catch invalid dates
    // like 2009-02-31
    // first check for ordinal dates
    const ordinalMatch = str.match(/^(\d{4})-?(\d{3})([ T]{1}\.*|$)/);
    if (ordinalMatch) {
        const oYear = Number(ordinalMatch[1]);
        const oDay = Number(ordinalMatch[2]);
        // if is leap year
        if ((oYear % 4 === 0 && oYear % 100 !== 0) || oYear % 400 === 0)
            return oDay <= 366;
        return oDay <= 365;
    }
    const match = str.match(/(\d{4})-?(\d{0,2})-?(\d*)/).map(Number);
    const year = match[1];
    const month = match[2];
    const day = match[3];
    const monthString = month ? `0${month}`.slice(-2) : month;
    const dayString = day ? `0${day}`.slice(-2) : day;
    // create a date object and compare
    const d = new Date(`${year}-${monthString || '01'}-${dayString || '01'}`);
    if (month && day) {
        return d.getUTCFullYear() === year
            && (d.getUTCMonth() + 1) === month
            && d.getUTCDate() === day;
    }
    return true;
};
const ɵ0 = isValidDate;
/**
 * Checks whether the `target` string is a valid ISO8601 date
 *
 * @param target The target string
 * @param options The options
 * @return true if the `target` is a valid ISO8601 date, false otherwise
 */
export function isISO8601(str, options) {
    assertString(str);
    const check = iso8601.test(str);
    if (!options)
        return check;
    if (check && options.strict)
        return isValidDate(str);
    return check;
}
export { ɵ0 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaXNJU084NjAxLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGZpcmVmbHlzZW1hbnRpY3MvdmFsaWRhdG9ydHMvIiwic291cmNlcyI6WyJsaWIvdmFsaWRhdG9ycy9pc0lTTzg2MDEudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBRXBELDRCQUE0QjtBQUM1Qiw0QkFBNEI7QUFDNUIsTUFBTSxPQUFPLEdBQUcsNFJBQTRSLENBQUM7QUFDN1MsMkJBQTJCO0FBQzNCLE1BQU0sV0FBVyxHQUFHLENBQUMsR0FBRyxFQUFFLEVBQUU7SUFDMUIseUNBQXlDO0lBQ3pDLDZDQUE2QztJQUM3QyxrQkFBa0I7SUFDbEIsZ0NBQWdDO0lBQ2hDLE1BQU0sWUFBWSxHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsaUNBQWlDLENBQUMsQ0FBQztJQUNsRSxJQUFJLFlBQVksRUFBRTtRQUNoQixNQUFNLEtBQUssR0FBRyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDdEMsTUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3JDLGtCQUFrQjtRQUNsQixJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksS0FBSyxHQUFHLEdBQUcsS0FBSyxDQUFDLENBQUMsSUFBSSxLQUFLLEdBQUcsR0FBRyxLQUFLLENBQUM7WUFBRSxPQUFPLElBQUksSUFBSSxHQUFHLENBQUM7UUFDcEYsT0FBTyxJQUFJLElBQUksR0FBRyxDQUFDO0tBQ3BCO0lBQ0QsTUFBTSxLQUFLLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FBQywyQkFBMkIsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNqRSxNQUFNLElBQUksR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDdEIsTUFBTSxLQUFLLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3ZCLE1BQU0sR0FBRyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNyQixNQUFNLFdBQVcsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztJQUMxRCxNQUFNLFNBQVMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksR0FBRyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQztJQUVsRCxtQ0FBbUM7SUFDbkMsTUFBTSxDQUFDLEdBQUcsSUFBSSxJQUFJLENBQUMsR0FBRyxJQUFJLElBQUksV0FBVyxJQUFJLElBQUksSUFBSSxTQUFTLElBQUksSUFBSSxFQUFFLENBQUMsQ0FBQztJQUMxRSxJQUFJLEtBQUssSUFBSSxHQUFHLEVBQUU7UUFDaEIsT0FBTyxDQUFDLENBQUMsY0FBYyxFQUFFLEtBQUssSUFBSTtlQUM3QixDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsR0FBRyxDQUFDLENBQUMsS0FBSyxLQUFLO2VBQy9CLENBQUMsQ0FBQyxVQUFVLEVBQUUsS0FBSyxHQUFHLENBQUM7S0FDN0I7SUFDRCxPQUFPLElBQUksQ0FBQztBQUNkLENBQUMsQ0FBQTs7QUFHRDs7Ozs7O0dBTUc7QUFDSCxNQUFNLFVBQVUsU0FBUyxDQUFDLEdBQUcsRUFBRSxPQUFRO0lBQ3JDLFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNsQixNQUFNLEtBQUssR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ2hDLElBQUksQ0FBQyxPQUFPO1FBQUUsT0FBTyxLQUFLLENBQUM7SUFDM0IsSUFBSSxLQUFLLElBQUksT0FBTyxDQUFDLE1BQU07UUFBRSxPQUFPLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNyRCxPQUFPLEtBQUssQ0FBQztBQUNmLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhc3NlcnRTdHJpbmcgfSBmcm9tICcuLi91dGlsL2Fzc2VydFN0cmluZyc7XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbi8vIGZyb20gaHR0cDovL2dvby5nbC8wZWpISFdcbmNvbnN0IGlzbzg2MDEgPSAvXihbXFwrLV0/XFxkezR9KD8hXFxkezJ9XFxiKSkoKC0/KSgoMFsxLTldfDFbMC0yXSkoXFwzKFsxMl1cXGR8MFsxLTldfDNbMDFdKSk/fFcoWzAtNF1cXGR8NVswLTNdKSgtP1sxLTddKT98KDAwWzEtOV18MFsxLTldXFxkfFsxMl1cXGR7Mn18MyhbMC01XVxcZHw2WzEtNl0pKSkoW1RcXHNdKCgoWzAxXVxcZHwyWzAtM10pKCg6PylbMC01XVxcZCk/fDI0Oj8wMCkoW1xcLixdXFxkKyg/ITopKT8pPyhcXDE3WzAtNV1cXGQoW1xcLixdXFxkKyk/KT8oW3paXXwoW1xcKy1dKShbMDFdXFxkfDJbMC0zXSk6PyhbMC01XVxcZCk/KT8pPyk/JC87XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cbmNvbnN0IGlzVmFsaWREYXRlID0gKHN0cikgPT4ge1xuICAvLyBzdHIgbXVzdCBoYXZlIHBhc3NlZCB0aGUgSVNPODYwMSBjaGVja1xuICAvLyB0aGlzIGNoZWNrIGlzIG1lYW50IHRvIGNhdGNoIGludmFsaWQgZGF0ZXNcbiAgLy8gbGlrZSAyMDA5LTAyLTMxXG4gIC8vIGZpcnN0IGNoZWNrIGZvciBvcmRpbmFsIGRhdGVzXG4gIGNvbnN0IG9yZGluYWxNYXRjaCA9IHN0ci5tYXRjaCgvXihcXGR7NH0pLT8oXFxkezN9KShbIFRdezF9XFwuKnwkKS8pO1xuICBpZiAob3JkaW5hbE1hdGNoKSB7XG4gICAgY29uc3Qgb1llYXIgPSBOdW1iZXIob3JkaW5hbE1hdGNoWzFdKTtcbiAgICBjb25zdCBvRGF5ID0gTnVtYmVyKG9yZGluYWxNYXRjaFsyXSk7XG4gICAgLy8gaWYgaXMgbGVhcCB5ZWFyXG4gICAgaWYgKChvWWVhciAlIDQgPT09IDAgJiYgb1llYXIgJSAxMDAgIT09IDApIHx8IG9ZZWFyICUgNDAwID09PSAwKSByZXR1cm4gb0RheSA8PSAzNjY7XG4gICAgcmV0dXJuIG9EYXkgPD0gMzY1O1xuICB9XG4gIGNvbnN0IG1hdGNoID0gc3RyLm1hdGNoKC8oXFxkezR9KS0/KFxcZHswLDJ9KS0/KFxcZCopLykubWFwKE51bWJlcik7XG4gIGNvbnN0IHllYXIgPSBtYXRjaFsxXTtcbiAgY29uc3QgbW9udGggPSBtYXRjaFsyXTtcbiAgY29uc3QgZGF5ID0gbWF0Y2hbM107XG4gIGNvbnN0IG1vbnRoU3RyaW5nID0gbW9udGggPyBgMCR7bW9udGh9YC5zbGljZSgtMikgOiBtb250aDtcbiAgY29uc3QgZGF5U3RyaW5nID0gZGF5ID8gYDAke2RheX1gLnNsaWNlKC0yKSA6IGRheTtcblxuICAvLyBjcmVhdGUgYSBkYXRlIG9iamVjdCBhbmQgY29tcGFyZVxuICBjb25zdCBkID0gbmV3IERhdGUoYCR7eWVhcn0tJHttb250aFN0cmluZyB8fCAnMDEnfS0ke2RheVN0cmluZyB8fCAnMDEnfWApO1xuICBpZiAobW9udGggJiYgZGF5KSB7XG4gICAgcmV0dXJuIGQuZ2V0VVRDRnVsbFllYXIoKSA9PT0geWVhclxuICAgICAgJiYgKGQuZ2V0VVRDTW9udGgoKSArIDEpID09PSBtb250aFxuICAgICAgJiYgZC5nZXRVVENEYXRlKCkgPT09IGRheTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBgdGFyZ2V0YCBzdHJpbmcgaXMgYSB2YWxpZCBJU084NjAxIGRhdGVcbiAqIFxuICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IHN0cmluZ1xuICogQHBhcmFtIG9wdGlvbnMgVGhlIG9wdGlvbnNcbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUgYHRhcmdldGAgaXMgYSB2YWxpZCBJU084NjAxIGRhdGUsIGZhbHNlIG90aGVyd2lzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNJU084NjAxKHN0ciwgb3B0aW9ucz8pIHtcbiAgYXNzZXJ0U3RyaW5nKHN0cik7XG4gIGNvbnN0IGNoZWNrID0gaXNvODYwMS50ZXN0KHN0cik7XG4gIGlmICghb3B0aW9ucykgcmV0dXJuIGNoZWNrO1xuICBpZiAoY2hlY2sgJiYgb3B0aW9ucy5zdHJpY3QpIHJldHVybiBpc1ZhbGlkRGF0ZShzdHIpO1xuICByZXR1cm4gY2hlY2s7XG59XG4iXX0=