const alpha = {
    'en-US': /^[A-Z]+$/i,
    'bg-BG': /^[А-Я]+$/i,
    'cs-CZ': /^[A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]+$/i,
    'da-DK': /^[A-ZÆØÅ]+$/i,
    'de-DE': /^[A-ZÄÖÜß]+$/i,
    'el-GR': /^[Α-ώ]+$/i,
    'es-ES': /^[A-ZÁÉÍÑÓÚÜ]+$/i,
    'fr-FR': /^[A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]+$/i,
    'it-IT': /^[A-ZÀÉÈÌÎÓÒÙ]+$/i,
    'nb-NO': /^[A-ZÆØÅ]+$/i,
    'nl-NL': /^[A-ZÁÉËÏÓÖÜÚ]+$/i,
    'nn-NO': /^[A-ZÆØÅ]+$/i,
    'hu-HU': /^[A-ZÁÉÍÓÖŐÚÜŰ]+$/i,
    'pl-PL': /^[A-ZĄĆĘŚŁŃÓŻŹ]+$/i,
    'pt-PT': /^[A-ZÃÁÀÂÄÇÉÊËÍÏÕÓÔÖÚÜ]+$/i,
    'ru-RU': /^[А-ЯЁ]+$/i,
    'sl-SI': /^[A-ZČĆĐŠŽ]+$/i,
    'sk-SK': /^[A-ZÁČĎÉÍŇÓŠŤÚÝŽĹŔĽÄÔ]+$/i,
    'sr-RS@latin': /^[A-ZČĆŽŠĐ]+$/i,
    'sr-RS': /^[А-ЯЂЈЉЊЋЏ]+$/i,
    'sv-SE': /^[A-ZÅÄÖ]+$/i,
    'tr-TR': /^[A-ZÇĞİıÖŞÜ]+$/i,
    'uk-UA': /^[А-ЩЬЮЯЄIЇҐі]+$/i,
    'ku-IQ': /^[ئابپتجچحخدرڕزژسشعغفڤقکگلڵمنوۆھەیێيطؤثآإأكضصةظذ]+$/i,
    ar: /^[ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]+$/,
    he: /^[א-ת]+$/,
    'fa-IR': /^['آابپتثجچهخدذرزژسشصضطظعغفقکگلمنوهی']+$/i,
};
const alphanumeric = {
    'en-US': /^[0-9A-Z]+$/i,
    'bg-BG': /^[0-9А-Я]+$/i,
    'cs-CZ': /^[0-9A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]+$/i,
    'da-DK': /^[0-9A-ZÆØÅ]+$/i,
    'de-DE': /^[0-9A-ZÄÖÜß]+$/i,
    'el-GR': /^[0-9Α-ω]+$/i,
    'es-ES': /^[0-9A-ZÁÉÍÑÓÚÜ]+$/i,
    'fr-FR': /^[0-9A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]+$/i,
    'it-IT': /^[0-9A-ZÀÉÈÌÎÓÒÙ]+$/i,
    'hu-HU': /^[0-9A-ZÁÉÍÓÖŐÚÜŰ]+$/i,
    'nb-NO': /^[0-9A-ZÆØÅ]+$/i,
    'nl-NL': /^[0-9A-ZÁÉËÏÓÖÜÚ]+$/i,
    'nn-NO': /^[0-9A-ZÆØÅ]+$/i,
    'pl-PL': /^[0-9A-ZĄĆĘŚŁŃÓŻŹ]+$/i,
    'pt-PT': /^[0-9A-ZÃÁÀÂÄÇÉÊËÍÏÕÓÔÖÚÜ]+$/i,
    'ru-RU': /^[0-9А-ЯЁ]+$/i,
    'sl-SI': /^[0-9A-ZČĆĐŠŽ]+$/i,
    'sk-SK': /^[0-9A-ZÁČĎÉÍŇÓŠŤÚÝŽĹŔĽÄÔ]+$/i,
    'sr-RS@latin': /^[0-9A-ZČĆŽŠĐ]+$/i,
    'sr-RS': /^[0-9А-ЯЂЈЉЊЋЏ]+$/i,
    'sv-SE': /^[0-9A-ZÅÄÖ]+$/i,
    'tr-TR': /^[0-9A-ZÇĞİıÖŞÜ]+$/i,
    'uk-UA': /^[0-9А-ЩЬЮЯЄIЇҐі]+$/i,
    'ku-IQ': /^[٠١٢٣٤٥٦٧٨٩0-9ئابپتجچحخدرڕزژسشعغفڤقکگلڵمنوۆھەیێيطؤثآإأكضصةظذ]+$/i,
    ar: /^[٠١٢٣٤٥٦٧٨٩0-9ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]+$/,
    he: /^[0-9א-ת]+$/,
    'fa-IR': /^['0-9آابپتثجچهخدذرزژسشصضطظعغفقکگلمنوهی۱۲۳۴۵۶۷۸۹۰']+$/i,
};
const decimal = {
    'en-US': '.',
    ar: '٫',
};
const englishLocales = ['AU', 'GB', 'HK', 'IN', 'NZ', 'ZA', 'ZM'];
for (let locale, i = 0; i < englishLocales.length; i++) {
    locale = `en-${englishLocales[i]}`;
    alpha[locale] = alpha['en-US'];
    alphanumeric[locale] = alphanumeric['en-US'];
    decimal[locale] = decimal['en-US'];
}
// Source: http://www.localeplanet.com/java/
const arabicLocales = [
    'AE', 'BH', 'DZ', 'EG', 'IQ', 'JO', 'KW', 'LB', 'LY',
    'MA', 'QM', 'QA', 'SA', 'SD', 'SY', 'TN', 'YE',
];
for (let locale, i = 0; i < arabicLocales.length; i++) {
    locale = `ar-${arabicLocales[i]}`;
    alpha[locale] = alpha.ar;
    alphanumeric[locale] = alphanumeric.ar;
    decimal[locale] = decimal.ar;
}
// Source: https://en.wikipedia.org/wiki/Decimal_mark
const dotDecimal = ['ar-EG', 'ar-LB', 'ar-LY'];
const commaDecimal = [
    'bg-BG', 'cs-CZ', 'da-DK', 'de-DE', 'el-GR', 'en-ZM', 'es-ES', 'fr-FR', 'it-IT', 'ku-IQ', 'hu-HU', 'nb-NO',
    'nn-NO', 'nl-NL', 'pl-PL', 'pt-PT', 'ru-RU', 'sl-SI', 'sr-RS@latin',
    'sr-RS', 'sv-SE', 'tr-TR', 'uk-UA',
];
for (let i = 0; i < dotDecimal.length; i++) {
    decimal[dotDecimal[i]] = decimal['en-US'];
}
for (let i = 0; i < commaDecimal.length; i++) {
    decimal[commaDecimal[i]] = ',';
}
alpha['pt-BR'] = alpha['pt-PT'];
alphanumeric['pt-BR'] = alphanumeric['pt-PT'];
decimal['pt-BR'] = decimal['pt-PT'];
// see #862
alpha['pl-Pl'] = alpha['pl-PL'];
alphanumeric['pl-Pl'] = alphanumeric['pl-PL'];
decimal['pl-Pl'] = decimal['pl-PL'];

/**
 * Tests whether `input` is of type string
 * @param input The value that should be a string
 * @throws TypeError if the value is not a string
 */
function assertString(input) {
    const isString = (typeof input === 'string' || input instanceof String);
    if (!isString) {
        let invalidType;
        if (input === null) {
            invalidType = 'null';
        }
        else {
            invalidType = typeof input;
            if (invalidType === 'object' && input.constructor && input.constructor.hasOwnProperty('name')) {
                invalidType = input.constructor.name;
            }
            else {
                invalidType = `a ${invalidType}`;
            }
        }
        throw new TypeError(`Expected string but received ${invalidType}.`);
    }
}

/**
 * Convert the `input` argument into a string
 * @param input The input that should be converted to a string
 * @return The string value for the `input` argument
 */
function toString(input) {
    if (typeof input === 'object' && input !== null) {
        if (typeof input.toString === 'function') {
            input = input.toString();
        }
        else {
            input = '[object Object]';
        }
    }
    else if (input === null || typeof input === 'undefined' || (isNaN(input) && !input.length)) {
        input = '';
    }
    return String(input);
}

/**
 * Test whether the target string contains the arg.
 *
 * @param target The string that should contains the element
 * @param arg The contained string
 * @return true if the `target` string contains the `arg` string, false otherwise
 */
function contains(target, arg) {
    assertString(target);
    return target.indexOf(toString(arg)) >= 0;
}

/**
 * Compares the `target` and `arg` strings for strict (`===`) equality
 *
 * @param target The target string to compare to
 * @param arg The argument to perform the comparison with
 * @return true if the `target` is strictly equal to the `arg`, false otherwise
 */
function equals(target, arg) {
    assertString(target);
    return target === arg;
}

/**
 * Replaces <, >, &, ', " and / with HTML entities.
 * @param str The string to perform the `escape` operation on.
 */
function escape(str) {
    assertString(str);
    return (str.replace(/&/g, '&amp;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#x27;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/\//g, '&#x2F;')
        .replace(/\\/g, '&#x5C;')
        .replace(/`/g, '&#96;'));
}

function toDate(date) {
    assertString(date);
    const millis = Date.parse(date);
    return !isNaN(millis) ? new Date(date) : null;
}

/**
 * Checks whether the `target` date comes after the `arg` date
 *
 * @param target The target date
 * @param arg The argument to perform the comparison with
 * @return true if the `target` date comes after the `arg` date, false otherwise
 */
function isAfter(target, arg = String(new Date())) {
    assertString(target);
    const comparison = toDate(arg);
    const original = toDate(target);
    return !!(original && comparison && original > comparison);
}

/**
 * Checks whether `arg` is in alpha and if so validates whether
 * the `target` string conforms to the `arg` locale.
 *
 * @param target The target string to compare to
 * @param arg The argument that might equal the target
 * @return true if the `target` date comes after the `arg` date, false otherwise
 */
function isAlpha(target, arg = 'en-US') {
    assertString(target);
    if (arg in alpha) {
        return alpha[arg].test(target);
    }
    throw new Error(`Invalid locale '${arg}'`);
}
/**
 * The alpha locales
 */
const isAlphaLocales = Object.keys(alpha);

/**
 * Checks whether `arg` is in alphanumeric and if so validates whether
 * the `target` string conforms to the `arg` locale.
 *
 * @param target The target string
 * @param arg The locale (Defaults to 'en-US')
 * @return true if the `target` string conforms to the `arg` locale, false otherwise
 */
function isAlphaNumeric(target, arg = 'en-US') {
    assertString(target);
    if (arg in alphanumeric) {
        return alphanumeric[arg].test(target);
    }
    throw new Error(`Invalid locale '${arg}'`);
}
/**
 * The alpha numeric locales
 */
const isAlphaNumericLocales = Object.keys(alphanumeric);

/* eslint-disable no-control-regex */
const ascii = /^[\x00-\x7F]+$/;
/* eslint-enable no-control-regex */
/**
 * Checks whether the `target` conforms to the ascii standard
 *
 * @param target The target string
 * @return true if the `target` conforms to the ascii standard, false otherwise
 */
function isAscii(target) {
    assertString(target);
    return ascii.test(target);
}

const base32 = /^[A-Z2-7]+=*$/;
/**
 * Checks whether the `target` is base32 encoded
 *
 * @param target The target string
 * @return true if the `target` is base32 encoded, false otherwise
 */
function isBase32(str) {
    assertString(str);
    const len = str.length;
    if (len > 0 && len % 8 === 0 && base32.test(str)) {
        return true;
    }
    return false;
}

const notBase64 = /[^A-Z0-9+\/=]/i;
/**
 * Checks whether the `target` is base64 encoded
 *
 * @param target The target string
 * @return true if the `target` is base64 encoded, false otherwise
 */
function isBase64(str) {
    assertString(str);
    const len = str.length;
    if (!len || len % 4 !== 0 || notBase64.test(str)) {
        return false;
    }
    const firstPaddingChar = str.indexOf('=');
    return firstPaddingChar === -1 ||
        firstPaddingChar === len - 1 ||
        (firstPaddingChar === len - 2 && str[len - 1] === '=');
}

/**
 * Checks whether the `target` date comes before the `arg` date
 *
 * @param target The target date
 * @param arg The argument
 * @return true if the `target` date comes before the `arg` date, false otherwise
 */
function isBefore(target, arg = String(new Date())) {
    assertString(target);
    const comparison = toDate(arg);
    const original = toDate(target);
    return !!(original && comparison && original < comparison);
}

const isBICReg = /^[A-z]{4}[A-z]{2}\w{2}(\w{3})?$/;
/**
 * Checks whether the `target` is BIC encoded
 *
 * @param target The target string
 * @return true if the `target` is BIC encoded, false otherwise
 */
function isBIC(str) {
    assertString(str);
    return isBICReg.test(str);
}

/**
 * Checks whether the `target` is a boolean value
 * meaning it contains of of `['true', 'false', '1', '0']`
 *
 * @param target The target string
 * @return true if the `target` is a boolean value, false otherwise
 */
function isBoolean(str) {
    assertString(str);
    return (['true', 'false', '1', '0'].indexOf(str) >= 0);
}

// supports Bech32 addresses
const btc = /^(bc1|[13])[a-zA-HJ-NP-Z0-9]{25,39}$/;
/**
 * Checks whether the `target` is a btc address
 *
 * @param target The target string
 * @return true if the `target` is a btc address, false otherwise
 */
function isBtcAddress(str) {
    assertString(str);
    return btc.test(str);
}

/* eslint-disable prefer-rest-params */
/**
 * Checks whether the `target` string's length (in UTF-8 bytes)
 * falls in a range.
 *
 * @param target The target string
 * @param options The option parameters containing the min and max length of the string
 * @return true if the `target` strings conforms to the provided range
 */
function isByteLength(target, options) {
    assertString(target);
    let min;
    let max;
    if (typeof (options) === 'object') {
        min = options.min || 0;
        max = options.max;
    }
    else { // backwards compatibility: isByteLength(str, min [, max])
        min = arguments[1];
        max = arguments[2];
    }
    const len = encodeURI(target).split(/%..|./).length - 1;
    return len >= min && (typeof max === 'undefined' || len <= max);
}

/* eslint-disable max-len */
const creditCard = /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11}|6[27][0-9]{14})$/;
/* eslint-enable max-len */
/**
 * Checks whether the `target` string is a credit card number
 *
 * @param target The target string
 * @return true if the `target` is a credit card number, false otherwise
 */
function isCreditCard(target) {
    assertString(target);
    const sanitized = target.replace(/[- ]+/g, '');
    if (!creditCard.test(sanitized)) {
        return false;
    }
    let sum = 0;
    let digit;
    let tmpNum;
    let shouldDouble;
    for (let i = sanitized.length - 1; i >= 0; i--) {
        digit = sanitized.substring(i, (i + 1));
        tmpNum = parseInt(digit, 10);
        if (shouldDouble) {
            tmpNum *= 2;
            if (tmpNum >= 10) {
                sum += ((tmpNum % 10) + 1);
            }
            else {
                sum += tmpNum;
            }
        }
        else {
            sum += tmpNum;
        }
        shouldDouble = !shouldDouble;
    }
    return !!((sum % 10) === 0 ? sanitized : false);
}

function merge(obj = {}, defaults) {
    for (const key in defaults) {
        if (typeof obj[key] === 'undefined') {
            obj[key] = defaults[key];
        }
    }
    return obj;
}

function currencyRegex(options) {
    let decimal_digits = `\\d{${options.digits_after_decimal[0]}}`;
    options.digits_after_decimal.forEach((digit, index) => { if (index !== 0)
        decimal_digits = `${decimal_digits}|\\d{${digit}}`; });
    const symbol = `(\\${options.symbol.replace(/\./g, '\\.')})${(options.require_symbol ? '' : '?')}`, negative = '-?', whole_dollar_amount_without_sep = '[1-9]\\d*', whole_dollar_amount_with_sep = `[1-9]\\d{0,2}(\\${options.thousands_separator}\\d{3})*`, valid_whole_dollar_amounts = [
        '0', whole_dollar_amount_without_sep, whole_dollar_amount_with_sep
    ], whole_dollar_amount = `(${valid_whole_dollar_amounts.join('|')})?`, decimal_amount = `(\\${options.decimal_separator}(${decimal_digits}))${options.require_decimal ? '' : '?'}`;
    let pattern = whole_dollar_amount + (options.allow_decimal || options.require_decimal ? decimal_amount : '');
    // default is negative sign before symbol, but there are two other options (besides parens)
    if (options.allow_negatives && !options.parens_for_negatives) {
        if (options.negative_sign_after_digits) {
            pattern += negative;
        }
        else if (options.negative_sign_before_digits) {
            pattern = negative + pattern;
        }
    }
    // South African Rand, for example, uses R 123 (space) and R-123 (no space)
    if (options.allow_negative_sign_placeholder) {
        pattern = `( (?!\\-))?${pattern}`;
    }
    else if (options.allow_space_after_symbol) {
        pattern = ` ?${pattern}`;
    }
    else if (options.allow_space_after_digits) {
        pattern += '( (?!$))?';
    }
    if (options.symbol_after_digits) {
        pattern += symbol;
    }
    else {
        pattern = symbol + pattern;
    }
    if (options.allow_negatives) {
        if (options.parens_for_negatives) {
            pattern = `(\\(${pattern}\\)|${pattern})`;
        }
        else if (!(options.negative_sign_before_digits || options.negative_sign_after_digits)) {
            pattern = negative + pattern;
        }
    }
    // ensure there's a dollar and/or decimal amount, and that
    // it doesn't start with a space or a negative sign followed by a space
    return new RegExp(`^(?!-? )(?=.*\\d)${pattern}$`);
}
/**
 * The currency default options
 */
const default_currency_options = {
    symbol: '$',
    require_symbol: false,
    allow_space_after_symbol: false,
    symbol_after_digits: false,
    allow_negatives: true,
    parens_for_negatives: false,
    negative_sign_before_digits: false,
    negative_sign_after_digits: false,
    allow_negative_sign_placeholder: false,
    thousands_separator: ',',
    decimal_separator: '.',
    allow_decimal: true,
    require_decimal: false,
    digits_after_decimal: [2],
    allow_space_after_digits: false,
};
/**
 * Checks whether the `target` string is a currency
 *
 * @param target The target string
 * @param options The options
 * @return true if the `target` is a currency, false otherwise
 */
function isCurrency(str, options) {
    assertString(str);
    options = merge(options, default_currency_options);
    return currencyRegex(options).test(str);
}

const validMediaType = /^[a-z]+\/[a-z0-9\-\+]+$/i;
const validAttribute = /^[a-z\-]+=[a-z0-9\-]+$/i;
const validData = /^[a-z0-9!\$&'\(\)\*\+,;=\-\._~:@\/\?%\s]*$/i;
/**
 * Checks whether the `target` string is a data URI
 *
 * @param target The target string
 * @param options The options
 * @return true if the `target` is a data URI, false otherwise
 */
function isDataURI(target) {
    assertString(target);
    let data = target.split(',');
    if (data.length < 2) {
        return false;
    }
    const attributes = data.shift().trim().split(';');
    const schemeAndMediaType = attributes.shift();
    if (schemeAndMediaType.substr(0, 5) !== 'data:') {
        return false;
    }
    const mediaType = schemeAndMediaType.substr(5);
    if (mediaType !== '' && !validMediaType.test(mediaType)) {
        return false;
    }
    for (let i = 0; i < attributes.length; i++) {
        if (i === attributes.length - 1 && attributes[i].toLowerCase() === 'base64') {
            // ok
        }
        else if (!validAttribute.test(attributes[i])) {
            return false;
        }
    }
    for (let i = 0; i < data.length; i++) {
        if (!validData.test(data[i])) {
            return false;
        }
    }
    return true;
}

const includes = (arr, val) => arr.some(arrVal => val === arrVal);

function decimalRegExp(options) {
    const regExp = new RegExp(`^[-+]?([0-9]+)?(\\${decimal[options.locale]}[0-9]{${options.decimal_digits}})${options.force_decimal ? '' : '?'}$`);
    return regExp;
}
/**
 * The default options
 */
const default_decimal_options = {
    force_decimal: false,
    decimal_digits: '1,',
    locale: 'en-US',
};
const blacklist = ['', '-', '+'];
/**
 * Checks whether the `target` string is a decimal
 *
 * @param target The target string
 * @param options The options
 * @return true if the `target` is a decimal, false otherwise
 */
function isDecimal(target, options) {
    assertString(target);
    options = merge(options, default_decimal_options);
    if (options.locale in decimal) {
        return !includes(blacklist, target.replace(/ /g, '')) && decimalRegExp(options).test(target);
    }
    throw new Error(`Invalid locale '${options.locale}'`);
}

/**
 * Checks whether the `target` string is a float
 *
 * @param target The target string
 * @param options The options
 * @return true if the `target` is is a float, false otherwise
 */
function isFloat(str, options) {
    assertString(str);
    options = options || {};
    const float = new RegExp(`^(?:[-+])?(?:[0-9]+)?(?:\\${options.locale ? decimal[options.locale] : '.'}[0-9]*)?(?:[eE][\\+\\-]?(?:[0-9]+))?$`);
    if (str === '' || str === '.' || str === '-' || str === '+') {
        return false;
    }
    const value = parseFloat(str.replace(',', '.'));
    return float.test(str) &&
        (!options.hasOwnProperty('min') || value >= options.min) &&
        (!options.hasOwnProperty('max') || value <= options.max) &&
        (!options.hasOwnProperty('lt') || value < options.lt) &&
        (!options.hasOwnProperty('gt') || value > options.gt);
}
const floatLocales = Object.keys(decimal);

function toFloat(str) {
    if (!isFloat(str))
        return NaN;
    return parseFloat(str);
}

/**
 * Checks whether the `target` is divisible by the arg
 *
 * @param target The target string
 * @param arg The divisor
 * @return true if the `target` is divisible by the `arg`, false otherwise
 */
function isDivisibleBy(target, arg) {
    assertString(target);
    return toFloat(target) % parseInt(arg, 10) === 0;
}

/**
 * The most commonly used EAN standard is
 * the thirteen-digit EAN-13, while the
 * less commonly used 8-digit EAN-8 barcode was
 * introduced for use on small packages.
 * EAN consists of:
 * GS1 prefix, manufacturer code, product code and check digit
 * Reference: https://en.wikipedia.org/wiki/International_Article_Number
 */
/**
 * Define EAN Lenghts; 8 for EAN-8; 13 for EAN-13
 * and Regular Expression for valid EANs (EAN-8, EAN-13),
 * with exact numberic matching of 8 or 13 digits [0-9]
 */
const LENGTH_EAN_8 = 8;
const validEanRegex = /^(\d{8}|\d{13})$/;
/**
 * Get position weight given:
 * EAN length and digit index/position
 *
 * @param {number} length
 * @param {number} index
 * @return {number}
 */
function getPositionWeightThroughLengthAndIndex(length, index) {
    if (length === LENGTH_EAN_8) {
        return (index % 2 === 0) ? 3 : 1;
    }
    return (index % 2 === 0) ? 1 : 3;
}
/**
 * Calculate EAN Check Digit
 * Reference: https://en.wikipedia.org/wiki/International_Article_Number#Calculation_of_checksum_digit
 *
 * @param {string} ean
 * @return {number}
 */
function calculateCheckDigit(ean) {
    const checksum = ean
        .slice(0, -1)
        .split('')
        .map((char, index) => Number(char) * getPositionWeightThroughLengthAndIndex(ean.length, index))
        .reduce((acc, partialSum) => acc + partialSum, 0);
    const remainder = 10 - (checksum % 10);
    return remainder < 10 ? remainder : 0;
}
/**
 * Check if string is valid EAN:
 * Matches EAN-8/EAN-13 regex
 * Has valid check digit.
 *
 * @param target The target string
 * @return true if the `target` is a valid EAN, false otherwise
 */
function isEAN(target) {
    assertString(target);
    const actualCheckDigit = Number(target.slice(-1));
    return validEanRegex.test(target) && actualCheckDigit === calculateCheckDigit(target);
}

const default_fqdn_options = {
    require_tld: true,
    allow_underscores: false,
    allow_trailing_dot: false,
};
/**
 * Checks whether the `target` string is a FQDN
 *
 * @param target The target string
 * @param options The options
 * @return true if the `target` is a FQDN, false otherwise
 */
function isFQDN(str, options) {
    assertString(str);
    options = merge(options, default_fqdn_options);
    /* Remove the optional trailing dot before checking validity */
    if (options.allow_trailing_dot && str[str.length - 1] === '.') {
        str = str.substring(0, str.length - 1);
    }
    const parts = str.split('.');
    for (let i = 0; i < parts.length; i++) {
        if (parts[i].length > 63) {
            return false;
        }
    }
    if (options.require_tld) {
        const tld = parts.pop();
        if (!parts.length || !/^([a-z\u00a1-\uffff]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {
            return false;
        }
        // disallow spaces
        if (/[\s\u2002-\u200B\u202F\u205F\u3000\uFEFF\uDB40\uDC20]/.test(tld)) {
            return false;
        }
    }
    for (let part, i = 0; i < parts.length; i++) {
        part = parts[i];
        if (options.allow_underscores) {
            part = part.replace(/_/g, '');
        }
        if (!/^[a-z\u00a1-\uffff0-9-]+$/i.test(part)) {
            return false;
        }
        // disallow full-width chars
        if (/[\uff01-\uff5e]/.test(part)) {
            return false;
        }
        if (part[0] === '-' || part[part.length - 1] === '-') {
            return false;
        }
    }
    return true;
}

/**
11.3.  Examples

   The following addresses

             fe80::1234 (on the 1st link of the node)
             ff02::5678 (on the 5th link of the node)
             ff08::9abc (on the 10th organization of the node)

   would be represented as follows:

             fe80::1234%1
             ff02::5678%5
             ff08::9abc%10

   (Here we assume a natural translation from a zone index to the
   <zone_id> part, where the Nth zone of any scope is translated into
   "N".)

   If we use interface names as <zone_id>, those addresses could also be
   represented as follows:

            fe80::1234%ne0
            ff02::5678%pvc1.3
            ff08::9abc%interface10

   where the interface "ne0" belongs to the 1st link, "pvc1.3" belongs
   to the 5th link, and "interface10" belongs to the 10th organization.
 * * */
const ipv4Maybe = /^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$/;
const ipv6Block = /^[0-9A-F]{1,4}$/i;
/**
 * Checks whether the `target` string is an int
 *
 * @param target The target string
 * @param version The version
 * @return true if the `target` is an int, false otherwise
 */
function isIP(str, version = '4') {
    assertString(str);
    version = String(version);
    if (!version) {
        return isIP(str, '4') || isIP(str, '6');
    }
    else if (version === '4') {
        if (!ipv4Maybe.test(str)) {
            return false;
        }
        const parts = str.split('.').sort((a, b) => a - b);
        return parseInt(parts[3]) <= 255;
    }
    else if (version === '6') {
        let addressAndZone = [str];
        // ipv6 addresses could have scoped architecture
        // according to https://tools.ietf.org/html/rfc4007#section-11
        if (str.includes('%')) {
            addressAndZone = str.split('%');
            if (addressAndZone.length !== 2) {
                // it must be just two parts
                return false;
            }
            if (!addressAndZone[0].includes(':')) {
                // the first part must be the address
                return false;
            }
            if (addressAndZone[1] === '') {
                // the second part must not be empty
                return false;
            }
        }
        const blocks = addressAndZone[0].split(':');
        let foundOmissionBlock = false; // marker to indicate ::
        // At least some OS accept the last 32 bits of an IPv6 address
        // (i.e. 2 of the blocks) in IPv4 notation, and RFC 3493 says
        // that '::ffff:a.b.c.d' is valid for IPv4-mapped IPv6 addresses,
        // and '::a.b.c.d' is deprecated, but also valid.
        const foundIPv4TransitionBlock = isIP(blocks[blocks.length - 1], '4');
        const expectedNumberOfBlocks = foundIPv4TransitionBlock ? 7 : 8;
        if (blocks.length > expectedNumberOfBlocks) {
            return false;
        }
        // initial or final ::
        if (str === '::') {
            return true;
        }
        else if (str.substr(0, 2) === '::') {
            blocks.shift();
            blocks.shift();
            foundOmissionBlock = true;
        }
        else if (str.substr(str.length - 2) === '::') {
            blocks.pop();
            blocks.pop();
            foundOmissionBlock = true;
        }
        for (let i = 0; i < blocks.length; ++i) {
            // test for a :: which can not be at the string start/end
            // since those cases have been handled above
            if (blocks[i] === '' && i > 0 && i < blocks.length - 1) {
                if (foundOmissionBlock) {
                    return false; // multiple :: in address
                }
                foundOmissionBlock = true;
            }
            else if (foundIPv4TransitionBlock && i === blocks.length - 1) {
                // it has been checked before that the last
                // block is a valid IPv4 address
            }
            else if (!ipv6Block.test(blocks[i])) {
                return false;
            }
        }
        if (foundOmissionBlock) {
            return blocks.length >= 1;
        }
        return blocks.length === expectedNumberOfBlocks;
    }
    return false;
}

const default_email_options = {
    require_display_name: false,
    allow_display_name: false,
    allow_utf8_local_part: true,
    require_tld: true,
};
/* eslint-disable max-len */
/* eslint-disable no-control-regex */
const splitNameAddress = /^([^\x00-\x1F\x7F-\x9F\cX]+)<(.+)>$/i;
const emailUserPart = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~]+$/i;
const gmailUserPart = /^[a-z\d]+$/;
const quotedEmailUser = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f]))*$/i;
const emailUserUtf8Part = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+$/i;
const quotedEmailUserUtf8 = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*$/i;
const defaultMaxEmailLength = 254;
/* eslint-enable max-len */
/* eslint-enable no-control-regex */
/**
 * Validate display name according to the RFC2822: https://tools.ietf.org/html/rfc2822#appendix-A.1.2
 * @param {String} display_name
 */
function validateDisplayName(display_name) {
    const trim_quotes = display_name.match(/^"(.+)"$/i);
    const display_name_without_quotes = trim_quotes ? trim_quotes[1] : display_name;
    // display name with only spaces is not valid
    if (!display_name_without_quotes.trim()) {
        return false;
    }
    // check whether display name contains illegal character
    const contains_illegal = /[\.";<>]/.test(display_name_without_quotes);
    if (contains_illegal) {
        // if contains illegal characters,
        // must to be enclosed in double-quotes, otherwise it's not a valid display name
        if (!trim_quotes) {
            return false;
        }
        // the quotes in display name must start with character symbol \
        const all_start_with_back_slash = display_name_without_quotes.split('"').length === display_name_without_quotes.split('\\"').length;
        if (!all_start_with_back_slash) {
            return false;
        }
    }
    return true;
}
/**
 * Checks whether the `target` string is a valid email address
 *
 * @param target The target string
 * @param options The options
 * @return true if the `target` is a valid email address, false otherwise
 */
function isEmail(str, options) {
    assertString(str);
    options = merge(options, default_email_options);
    if (options.require_display_name || options.allow_display_name) {
        const display_email = str.match(splitNameAddress);
        if (display_email) {
            let display_name;
            [, display_name, str] = display_email;
            // sometimes need to trim the last space to get the display name
            // because there may be a space between display name and email address
            // eg. myname <address@gmail.com>
            // the display name is `myname` instead of `myname `, so need to trim the last space
            if (display_name.endsWith(' ')) {
                display_name = display_name.substr(0, display_name.length - 1);
            }
            if (!validateDisplayName(display_name)) {
                return false;
            }
        }
        else if (options.require_display_name) {
            return false;
        }
    }
    if (!options.ignore_max_length && str.length > defaultMaxEmailLength) {
        return false;
    }
    const parts = str.split('@');
    const domain = parts.pop();
    let user = parts.join('@');
    const lower_domain = domain.toLowerCase();
    if (options.domain_specific_validation && (lower_domain === 'gmail.com' || lower_domain === 'googlemail.com')) {
        /*
          Previously we removed dots for gmail addresses before validating.
          This was removed because it allows `multiple..dots@gmail.com`
          to be reported as valid, but it is not.
          Gmail only normalizes single dots, removing them from here is pointless,
          should be done in normalizeEmail
        */
        user = user.toLowerCase();
        // Removing sub-address from username before gmail validation
        const username = user.split('+')[0];
        // Dots are not included in gmail length restriction
        if (!isByteLength(username.replace('.', ''), { min: 6, max: 30 })) {
            return false;
        }
        const user_parts = username.split('.');
        for (let i = 0; i < user_parts.length; i++) {
            if (!gmailUserPart.test(user_parts[i])) {
                return false;
            }
        }
    }
    if (!isByteLength(user, { max: 64 }) ||
        !isByteLength(domain, { max: 254 })) {
        return false;
    }
    if (!isFQDN(domain, { require_tld: options.require_tld })) {
        if (!options.allow_ip_domain) {
            return false;
        }
        if (!isIP(domain)) {
            if (!domain.startsWith('[') || !domain.endsWith(']')) {
                return false;
            }
            let noBracketdomain = domain.substr(1, domain.length - 2);
            if (noBracketdomain.length === 0 || !isIP(noBracketdomain)) {
                return false;
            }
        }
    }
    if (user[0] === '"') {
        user = user.slice(1, user.length - 1);
        return options.allow_utf8_local_part ?
            quotedEmailUserUtf8.test(user) :
            quotedEmailUser.test(user);
    }
    const pattern = options.allow_utf8_local_part ?
        emailUserUtf8Part : emailUserPart;
    const user_parts = user.split('.');
    for (let i = 0; i < user_parts.length; i++) {
        if (!pattern.test(user_parts[i])) {
            return false;
        }
    }
    return true;
}

const default_is_empty_options = {
    ignore_whitespace: false,
};
/**
 * Checks whether the `target` string is empty
 *
 * Note that `ignore_whitespace` is false by default.
 *
 * @param target The target string
 * @param options The options
 * @return true if the `target` is empty
 */
function isEmpty(str, options) {
    assertString(str);
    options = merge(options, default_is_empty_options);
    return (options.ignore_whitespace ? str.trim().length : str.length) === 0;
}

const eth = /^(0x)[0-9a-f]{40}$/i;
/**
 * Checks whether the `target` is an ethereum address
 *
 * @param target The target string
 * @return true if the `target` is an ethereum address
 */
function isEthereumAddress(str) {
    assertString(str);
    return eth.test(str);
}

const fullWidth = /[^\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;
/**
 * Checks whether the `target` is full width
 *
 * @param target The target string
 * @return true if the `target` is full width, false otherwise
 */
function isFullWidth(str) {
    assertString(str);
    return fullWidth.test(str);
}

const halfWidth = /[\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;
/**
 * Checks whether the `target` is half width
 *
 * @param target The target string
 * @return true if the `target` is half width, false otherwise
 */
function isHalfWidth(str) {
    assertString(str);
    return halfWidth.test(str);
}

const lengths = {
    md5: 32,
    md4: 32,
    sha1: 40,
    sha256: 64,
    sha384: 96,
    sha512: 128,
    ripemd128: 32,
    ripemd160: 40,
    tiger128: 32,
    tiger160: 40,
    tiger192: 48,
    crc32: 8,
    crc32b: 8,
};
/**
 * Checks whether the `target` string is hashed using the `arg` algorithm
 *
 * @param target The target string
 * @param arg The arg
 * @return true if the `target` is hashed using the `arg` algorithm, false otherwise
 */
function isHash(target, arg) {
    assertString(target);
    const hash = new RegExp(`^[a-fA-F0-9]{${lengths[arg]}}$`);
    return hash.test(target);
}

const hexadecimal = /^(0x|0h)?[0-9A-F]+$/i;
/**
 * Checks whether the `target` is hexadecimal
 *
 * @param target The target string
 * @return true if the `target` is hexadecimal, false otherwise
 */
function isHexadecimal(str) {
    assertString(str);
    return hexadecimal.test(str);
}

const hexcolor = /^#?([0-9A-F]{3}|[0-9A-F]{4}|[0-9A-F]{6}|[0-9A-F]{8})$/i;
/**
 * Checks whether the `target` is hexcolor
 *
 * @param target The target string
 * @return true if the `target` is hexcolor, false otherwise
 */
function isHexColor(str) {
    assertString(str);
    return hexcolor.test(str);
}

const hslcomma = /^(hsl)a?\(\s*((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?))(deg|grad|rad|turn|\s*)(\s*,\s*(\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%){2}\s*(,\s*((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%?)\s*)?\)$/i;
const hslspace = /^(hsl)a?\(\s*((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?))(deg|grad|rad|turn|\s)(\s*(\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%){2}\s*(\/\s*((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%?)\s*)?\)$/i;
/**
 * Checks whether the `target` is HSL color
 *
 * @param target The target string
 * @return true if the `target` is HSL color, false otherwise
 */
function isHSL(str) {
    assertString(str);
    return hslcomma.test(str) || hslspace.test(str);
}

/**
 * List of country codes with
 * corresponding IBAN regular expression
 * Reference: https://en.wikipedia.org/wiki/International_Bank_Account_Number
 */
const ibanRegexThroughCountryCode = {
    AD: /^(AD[0-9]{2})\d{8}[A-Z0-9]{12}$/,
    AE: /^(AE[0-9]{2})\d{3}\d{16}$/,
    AL: /^(AL[0-9]{2})\d{8}[A-Z0-9]{16}$/,
    AT: /^(AT[0-9]{2})\d{16}$/,
    AZ: /^(AZ[0-9]{2})[A-Z0-9]{4}\d{20}$/,
    BA: /^(BA[0-9]{2})\d{16}$/,
    BE: /^(BE[0-9]{2})\d{12}$/,
    BG: /^(BG[0-9]{2})[A-Z]{4}\d{6}[A-Z0-9]{8}$/,
    BH: /^(BH[0-9]{2})[A-Z]{4}[A-Z0-9]{14}$/,
    BR: /^(BR[0-9]{2})\d{23}[A-Z]{1}[A-Z0-9]{1}$/,
    BY: /^(BY[0-9]{2})[A-Z0-9]{4}\d{20}$/,
    CH: /^(CH[0-9]{2})\d{5}[A-Z0-9]{12}$/,
    CR: /^(CR[0-9]{2})\d{18}$/,
    CY: /^(CY[0-9]{2})\d{8}[A-Z0-9]{16}$/,
    CZ: /^(CZ[0-9]{2})\d{20}$/,
    DE: /^(DE[0-9]{2})\d{18}$/,
    DK: /^(DK[0-9]{2})\d{14}$/,
    DO: /^(DO[0-9]{2})[A-Z]{4}\d{20}$/,
    EE: /^(EE[0-9]{2})\d{16}$/,
    ES: /^(ES[0-9]{2})\d{20}$/,
    FI: /^(FI[0-9]{2})\d{14}$/,
    FO: /^(FO[0-9]{2})\d{14}$/,
    FR: /^(FR[0-9]{2})\d{10}[A-Z0-9]{11}\d{2}$/,
    GB: /^(GB[0-9]{2})[A-Z]{4}\d{14}$/,
    GE: /^(GE[0-9]{2})[A-Z0-9]{2}\d{16}$/,
    GI: /^(GI[0-9]{2})[A-Z]{4}[A-Z0-9]{15}$/,
    GL: /^(GL[0-9]{2})\d{14}$/,
    GR: /^(GR[0-9]{2})\d{7}[A-Z0-9]{16}$/,
    GT: /^(GT[0-9]{2})[A-Z0-9]{4}[A-Z0-9]{20}$/,
    HR: /^(HR[0-9]{2})\d{17}$/,
    HU: /^(HU[0-9]{2})\d{24}$/,
    IE: /^(IE[0-9]{2})[A-Z0-9]{4}\d{14}$/,
    IL: /^(IL[0-9]{2})\d{19}$/,
    IQ: /^(IQ[0-9]{2})[A-Z]{4}\d{15}$/,
    IS: /^(IS[0-9]{2})\d{22}$/,
    IT: /^(IT[0-9]{2})[A-Z]{1}\d{10}[A-Z0-9]{12}$/,
    JO: /^(JO[0-9]{2})[A-Z]{4}\d{22}$/,
    KW: /^(KW[0-9]{2})[A-Z]{4}[A-Z0-9]{22}$/,
    KZ: /^(KZ[0-9]{2})\d{3}[A-Z0-9]{13}$/,
    LB: /^(LB[0-9]{2})\d{4}[A-Z0-9]{20}$/,
    LC: /^(LC[0-9]{2})[A-Z]{4}[A-Z0-9]{24}$/,
    LI: /^(LI[0-9]{2})\d{5}[A-Z0-9]{12}$/,
    LT: /^(LT[0-9]{2})\d{16}$/,
    LU: /^(LU[0-9]{2})\d{3}[A-Z0-9]{13}$/,
    LV: /^(LV[0-9]{2})[A-Z]{4}[A-Z0-9]{13}$/,
    MC: /^(MC[0-9]{2})\d{10}[A-Z0-9]{11}\d{2}$/,
    MD: /^(MD[0-9]{2})[A-Z0-9]{20}$/,
    ME: /^(ME[0-9]{2})\d{18}$/,
    MK: /^(MK[0-9]{2})\d{3}[A-Z0-9]{10}\d{2}$/,
    MR: /^(MR[0-9]{2})\d{23}$/,
    MT: /^(MT[0-9]{2})[A-Z]{4}\d{5}[A-Z0-9]{18}$/,
    MU: /^(MU[0-9]{2})[A-Z]{4}\d{19}[A-Z]{3}$/,
    NL: /^(NL[0-9]{2})[A-Z]{4}\d{10}$/,
    NO: /^(NO[0-9]{2})\d{11}$/,
    PK: /^(PK[0-9]{2})[A-Z0-9]{4}\d{16}$/,
    PL: /^(PL[0-9]{2})\d{24}$/,
    PS: /^(PS[0-9]{2})[A-Z0-9]{4}\d{21}$/,
    PT: /^(PT[0-9]{2})\d{21}$/,
    QA: /^(QA[0-9]{2})[A-Z]{4}[A-Z0-9]{21}$/,
    RO: /^(RO[0-9]{2})[A-Z]{4}[A-Z0-9]{16}$/,
    RS: /^(RS[0-9]{2})\d{18}$/,
    SA: /^(SA[0-9]{2})\d{2}[A-Z0-9]{18}$/,
    SC: /^(SC[0-9]{2})[A-Z]{4}\d{20}[A-Z]{3}$/,
    SE: /^(SE[0-9]{2})\d{20}$/,
    SI: /^(SI[0-9]{2})\d{15}$/,
    SK: /^(SK[0-9]{2})\d{20}$/,
    SM: /^(SM[0-9]{2})[A-Z]{1}\d{10}[A-Z0-9]{12}$/,
    TL: /^(TL[0-9]{2})\d{19}$/,
    TN: /^(TN[0-9]{2})\d{20}$/,
    TR: /^(TR[0-9]{2})\d{5}[A-Z0-9]{17}$/,
    UA: /^(UA[0-9]{2})\d{6}[A-Z0-9]{19}$/,
    VA: /^(VA[0-9]{2})\d{18}$/,
    VG: /^(VG[0-9]{2})[A-Z0-9]{4}\d{16}$/,
    XK: /^(XK[0-9]{2})\d{16}$/,
};
/**
 * Check whether string has correct universal IBAN format
 * The IBAN consists of up to 34 alphanumeric characters, as follows:
 * Country Code using ISO 3166-1 alpha-2, two letters
 * check digits, two digits and
 * Basic Bank Account Number (BBAN), up to 30 alphanumeric characters.
 * NOTE: Permitted IBAN characters are: digits [0-9] and the 26 latin alphabetic [A-Z]
 *
 * @param {string} str - string under validation
 * @return {boolean}
 */
function hasValidIbanFormat(str) {
    // Strip white spaces and hyphens, keep only digits and A-Z latin alphabetic
    const strippedStr = str.replace(/[^A-Z0-9]+/gi, '').toUpperCase();
    const isoCountryCode = strippedStr.slice(0, 2).toUpperCase();
    return (isoCountryCode in ibanRegexThroughCountryCode) &&
        ibanRegexThroughCountryCode[isoCountryCode].test(strippedStr);
}
/**
   * Check whether string has valid IBAN Checksum
   * by performing basic mod-97 operation and
   * the remainder should equal 1
   * -- Start by rearranging the IBAN by moving the four initial characters to the end of the string
   * -- Replace each letter in the string with two digits, A -> 10, B = 11, Z = 35
   * -- Interpret the string as a decimal integer and
   * -- compute the remainder on division by 97 (mod 97)
   * Reference: https://en.wikipedia.org/wiki/International_Bank_Account_Number
   *
   * @param target The target string
   * @return true if the string has a valid IBAN checksum, false otherwise
   */
function hasValidIbanChecksum(target) {
    const strippedStr = target.replace(/[^A-Z0-9]+/gi, '').toUpperCase(); // Keep only digits and A-Z latin alphabetic
    const rearranged = strippedStr.slice(4) + strippedStr.slice(0, 4);
    const alphaCapsReplacedWithDigits = rearranged.replace(/[A-Z]/g, char => char.charCodeAt(0) - 55);
    const remainder = alphaCapsReplacedWithDigits.match(/\d{1,7}/g)
        .reduce((acc, value) => Number(acc + value) % 97, '');
    return remainder === 1;
}
/**
 * Checks whether the IBAN number has a valid format and checksum.
 *
 * @param target The target string
 * @return true if the target has a valid format and checksum, false otherwise
 */
function isIBAN(target) {
    assertString(target);
    return hasValidIbanFormat(target) && hasValidIbanChecksum(target);
}

const ɵ0 = (str) => {
    assertString(str);
    const DNI = /^[0-9X-Z][0-9]{7}[TRWAGMYFPDXBNJZSQVHLCKE]$/;
    const charsValue = {
        X: 0,
        Y: 1,
        Z: 2,
    };
    const controlDigits = [
        'T', 'R', 'W', 'A', 'G', 'M', 'Y', 'F', 'P', 'D', 'X', 'B',
        'N', 'J', 'Z', 'S', 'Q', 'V', 'H', 'L', 'C', 'K', 'E',
    ];
    // sanitize user input
    const sanitized = str.trim().toUpperCase();
    // validate the data structure
    if (!DNI.test(sanitized)) {
        return false;
    }
    // validate the control digit
    const number = sanitized.slice(0, -1).replace(/[X,Y,Z]/g, char => charsValue[char]);
    return sanitized.endsWith(controlDigits[number % 23]);
}, ɵ1 = (str) => {
    const DNI = /^\d{9}$/;
    // sanitize user input
    const sanitized = str.trim();
    // validate the data structure
    if (!DNI.test(sanitized)) {
        return false;
    }
    const id = sanitized;
    let sum = 0, incNum;
    for (let i = 0; i < id.length; i++) {
        incNum = Number(id[i]) * ((i % 2) + 1); // Multiply number by 1 or 2
        sum += incNum > 9 ? incNum - 9 : incNum; // Sum the digits up and add to total
    }
    return sum % 10 === 0;
}, ɵ2 = (str) => {
    const ALPHABET_CODES = {
        A: 10,
        B: 11,
        C: 12,
        D: 13,
        E: 14,
        F: 15,
        G: 16,
        H: 17,
        I: 34,
        J: 18,
        K: 19,
        L: 20,
        M: 21,
        N: 22,
        O: 35,
        P: 23,
        Q: 24,
        R: 25,
        S: 26,
        T: 27,
        U: 28,
        V: 29,
        W: 32,
        X: 30,
        Y: 31,
        Z: 33,
    };
    const sanitized = str.trim().toUpperCase();
    if (!/^[A-Z][0-9]{9}$/.test(sanitized))
        return false;
    return Array.from(sanitized).reduce((sum, num, index) => {
        if (index === 0) {
            const code = ALPHABET_CODES[num];
            return ((code % 10) * 9) + Math.floor(code / 10);
        }
        if (index === 9) {
            return ((10 - (sum % 10)) - Number(num)) % 10 === 0;
        }
        return sum + (Number(num) * (9 - index));
    }, 0);
};
const validators = {
    ES: ɵ0,
    'he-IL': ɵ1,
    'zh-TW': ɵ2,
};
/**
 * Check if the string is an identity card
 * @param target The target string
 * @param arg The arg
 */
function isIdentityCard(target, arg) {
    assertString(target);
    if (arg in validators) {
        return validators[arg](target);
    }
    else if (arg === 'any') {
        for (const key in validators) {
            // https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md#ignoring-code-for-coverage-purposes
            // istanbul ignore else
            if (validators.hasOwnProperty(key)) {
                const validator = validators[key];
                if (validator(target)) {
                    return true;
                }
            }
        }
        return false;
    }
    throw new Error(`Invalid locale '${arg}'`);
}

/**
 * Checks whether the `target` string is in the array of allowed values
 *
 * @param target The target string
 * @param options The options
 * @return true if the `target` is in the array of allowed values, false otherwise
 */
function isIn(str, options) {
    assertString(str);
    let i;
    if (Object.prototype.toString.call(options) === '[object Array]') {
        const array = [];
        for (i in options) {
            // https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md#ignoring-code-for-coverage-purposes
            // istanbul ignore else
            if ({}.hasOwnProperty.call(options, i)) {
                array[i] = toString(options[i]);
            }
        }
        return array.indexOf(str) >= 0;
    }
    else if (typeof options === 'object') {
        return options.hasOwnProperty(str);
    }
    else if (options && typeof options.indexOf === 'function') {
        return options.indexOf(str) >= 0;
    }
    return false;
}

const int = /^(?:[-+]?(?:0|[1-9][0-9]*))$/;
const intLeadingZeroes = /^[-+]?[0-9]+$/;
/**
 * Checks whether the `target` string is an int
 *
 * @param target The target string
 * @param options The options
 * @return true if the `target` is an int, false otherwise
 */
function isInt(str, options) {
    assertString(str);
    options = options || {};
    // Get the regex to use for testing, based on whether
    // leading zeroes are allowed or not.
    let regex = (options.hasOwnProperty('allow_leading_zeroes') && !options.allow_leading_zeroes ?
        int : intLeadingZeroes);
    // Check min/max/lt/gt
    let minCheckPassed = (!options.hasOwnProperty('min') || str >= options.min);
    let maxCheckPassed = (!options.hasOwnProperty('max') || str <= options.max);
    let ltCheckPassed = (!options.hasOwnProperty('lt') || str < options.lt);
    let gtCheckPassed = (!options.hasOwnProperty('gt') || str > options.gt);
    return regex.test(str) && minCheckPassed && maxCheckPassed && ltCheckPassed && gtCheckPassed;
}

const isbn10Maybe = /^(?:[0-9]{9}X|[0-9]{10})$/;
const isbn13Maybe = /^(?:[0-9]{13})$/;
const factor = [1, 3];
/**
 * Test whether the target string is an ISBN number.
 *
 * @param target The string
 * @param arg The ISBN version
 * @return true if the `target` string is an ISBN number, false otherwise
 */
function isISBN(target, arg = '') {
    assertString(target);
    arg = String(arg);
    if (!arg) {
        return isISBN(target, '10') || isISBN(target, '13');
    }
    const sanitized = target.replace(/[\s-]+/g, '');
    let checksum = 0;
    let i;
    if (arg === '10') {
        if (!isbn10Maybe.test(sanitized)) {
            return false;
        }
        for (i = 0; i < 9; i++) {
            checksum += (i + 1) * parseInt(sanitized.charAt(i));
        }
        if (sanitized.charAt(9) === 'X') {
            checksum += 10 * 10;
        }
        else {
            checksum += 10 * parseInt(sanitized.charAt(9));
        }
        if ((checksum % 11) === 0) {
            return !!sanitized;
        }
    }
    else if (arg === '13') {
        if (!isbn13Maybe.test(sanitized)) {
            return false;
        }
        for (i = 0; i < 12; i++) {
            checksum += factor[i % 2] * parseInt(sanitized.charAt(i));
        }
        if (parseInt(sanitized.charAt(12)) - ((10 - (checksum % 10)) % 10) === 0) {
            return !!sanitized;
        }
    }
    return false;
}

const isin = /^[A-Z]{2}[0-9A-Z]{9}[0-9]$/;
/**
 * Test whether the target string is an ISBN number.
 *
 * @param target The string
 * @return true if the `target` string is an ISIN number, false otherwise
 */
function isISIN(target) {
    assertString(target);
    if (!isin.test(target)) {
        return false;
    }
    const checksumStr = target.replace(/[A-Z]/g, character => {
        const intValue = (parseInt(character, 36));
        return intValue ? intValue.toString() : '';
    });
    let sum = 0;
    let digit;
    let tmpNum;
    let shouldDouble = true;
    for (let i = checksumStr.length - 2; i >= 0; i--) {
        digit = checksumStr.substring(i, (i + 1));
        tmpNum = parseInt(digit, 10);
        if (shouldDouble) {
            tmpNum *= 2;
            if (tmpNum >= 10) {
                sum += tmpNum + 1;
            }
            else {
                sum += tmpNum;
            }
        }
        else {
            sum += tmpNum;
        }
        shouldDouble = !shouldDouble;
    }
    return parseInt(target.substr(target.length - 1), 10) === (10000 - sum) % 10;
}

/* eslint-disable max-len */
// from http://goo.gl/0ejHHW
const iso8601 = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
/* eslint-enable max-len */
const isValidDate = (str) => {
    // str must have passed the ISO8601 check
    // this check is meant to catch invalid dates
    // like 2009-02-31
    // first check for ordinal dates
    const ordinalMatch = str.match(/^(\d{4})-?(\d{3})([ T]{1}\.*|$)/);
    if (ordinalMatch) {
        const oYear = Number(ordinalMatch[1]);
        const oDay = Number(ordinalMatch[2]);
        // if is leap year
        if ((oYear % 4 === 0 && oYear % 100 !== 0) || oYear % 400 === 0)
            return oDay <= 366;
        return oDay <= 365;
    }
    const match = str.match(/(\d{4})-?(\d{0,2})-?(\d*)/).map(Number);
    const year = match[1];
    const month = match[2];
    const day = match[3];
    const monthString = month ? `0${month}`.slice(-2) : month;
    const dayString = day ? `0${day}`.slice(-2) : day;
    // create a date object and compare
    const d = new Date(`${year}-${monthString || '01'}-${dayString || '01'}`);
    if (month && day) {
        return d.getUTCFullYear() === year
            && (d.getUTCMonth() + 1) === month
            && d.getUTCDate() === day;
    }
    return true;
};
const ɵ0$1 = isValidDate;
/**
 * Checks whether the `target` string is a valid ISO8601 date
 *
 * @param target The target string
 * @param options The options
 * @return true if the `target` is a valid ISO8601 date, false otherwise
 */
function isISO8601(str, options) {
    assertString(str);
    const check = iso8601.test(str);
    if (!options)
        return check;
    if (check && options.strict)
        return isValidDate(str);
    return check;
}

// from https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2
const validISO31661Alpha2CountriesCodes = [
    'AD', 'AE', 'AF', 'AG', 'AI', 'AL', 'AM', 'AO', 'AQ', 'AR', 'AS', 'AT', 'AU', 'AW', 'AX', 'AZ',
    'BA', 'BB', 'BD', 'BE', 'BF', 'BG', 'BH', 'BI', 'BJ', 'BL', 'BM', 'BN', 'BO', 'BQ', 'BR', 'BS', 'BT', 'BV', 'BW', 'BY', 'BZ',
    'CA', 'CC', 'CD', 'CF', 'CG', 'CH', 'CI', 'CK', 'CL', 'CM', 'CN', 'CO', 'CR', 'CU', 'CV', 'CW', 'CX', 'CY', 'CZ',
    'DE', 'DJ', 'DK', 'DM', 'DO', 'DZ',
    'EC', 'EE', 'EG', 'EH', 'ER', 'ES', 'ET',
    'FI', 'FJ', 'FK', 'FM', 'FO', 'FR',
    'GA', 'GB', 'GD', 'GE', 'GF', 'GG', 'GH', 'GI', 'GL', 'GM', 'GN', 'GP', 'GQ', 'GR', 'GS', 'GT', 'GU', 'GW', 'GY',
    'HK', 'HM', 'HN', 'HR', 'HT', 'HU',
    'ID', 'IE', 'IL', 'IM', 'IN', 'IO', 'IQ', 'IR', 'IS', 'IT',
    'JE', 'JM', 'JO', 'JP',
    'KE', 'KG', 'KH', 'KI', 'KM', 'KN', 'KP', 'KR', 'KW', 'KY', 'KZ',
    'LA', 'LB', 'LC', 'LI', 'LK', 'LR', 'LS', 'LT', 'LU', 'LV', 'LY',
    'MA', 'MC', 'MD', 'ME', 'MF', 'MG', 'MH', 'MK', 'ML', 'MM', 'MN', 'MO', 'MP', 'MQ', 'MR', 'MS', 'MT', 'MU', 'MV', 'MW', 'MX', 'MY', 'MZ',
    'NA', 'NC', 'NE', 'NF', 'NG', 'NI', 'NL', 'NO', 'NP', 'NR', 'NU', 'NZ',
    'OM',
    'PA', 'PE', 'PF', 'PG', 'PH', 'PK', 'PL', 'PM', 'PN', 'PR', 'PS', 'PT', 'PW', 'PY',
    'QA',
    'RE', 'RO', 'RS', 'RU', 'RW',
    'SA', 'SB', 'SC', 'SD', 'SE', 'SG', 'SH', 'SI', 'SJ', 'SK', 'SL', 'SM', 'SN', 'SO', 'SR', 'SS', 'ST', 'SV', 'SX', 'SY', 'SZ',
    'TC', 'TD', 'TF', 'TG', 'TH', 'TJ', 'TK', 'TL', 'TM', 'TN', 'TO', 'TR', 'TT', 'TV', 'TW', 'TZ',
    'UA', 'UG', 'UM', 'US', 'UY', 'UZ',
    'VA', 'VC', 'VE', 'VG', 'VI', 'VN', 'VU',
    'WF', 'WS',
    'YE', 'YT',
    'ZA', 'ZM', 'ZW',
];
/**
 * Check whether the `target` string is a valid
 * ISO 3166-1 alpha-2 officially assigned country code
 *
 * @param target The target string
 * @return true if the `target` is a valid is a valid ISO 3166-1 alpha-2 officially assigned country code, false otherwise
 */
function isISO31661Alpha2(target) {
    assertString(target);
    return includes(validISO31661Alpha2CountriesCodes, target.toUpperCase());
}

// from https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3
const validISO31661Alpha3CountriesCodes = [
    'AFG', 'ALA', 'ALB', 'DZA', 'ASM', 'AND', 'AGO', 'AIA', 'ATA', 'ATG', 'ARG', 'ARM', 'ABW', 'AUS', 'AUT', 'AZE',
    'BHS', 'BHR', 'BGD', 'BRB', 'BLR', 'BEL', 'BLZ', 'BEN', 'BMU', 'BTN', 'BOL', 'BES', 'BIH', 'BWA', 'BVT', 'BRA',
    'IOT', 'BRN', 'BGR', 'BFA', 'BDI', 'KHM', 'CMR', 'CAN', 'CPV', 'CYM', 'CAF', 'TCD', 'CHL', 'CHN', 'CXR', 'CCK',
    'COL', 'COM', 'COG', 'COD', 'COK', 'CRI', 'CIV', 'HRV', 'CUB', 'CUW', 'CYP', 'CZE', 'DNK', 'DJI', 'DMA', 'DOM',
    'ECU', 'EGY', 'SLV', 'GNQ', 'ERI', 'EST', 'ETH', 'FLK', 'FRO', 'FJI', 'FIN', 'FRA', 'GUF', 'PYF', 'ATF', 'GAB',
    'GMB', 'GEO', 'DEU', 'GHA', 'GIB', 'GRC', 'GRL', 'GRD', 'GLP', 'GUM', 'GTM', 'GGY', 'GIN', 'GNB', 'GUY', 'HTI',
    'HMD', 'VAT', 'HND', 'HKG', 'HUN', 'ISL', 'IND', 'IDN', 'IRN', 'IRQ', 'IRL', 'IMN', 'ISR', 'ITA', 'JAM', 'JPN',
    'JEY', 'JOR', 'KAZ', 'KEN', 'KIR', 'PRK', 'KOR', 'KWT', 'KGZ', 'LAO', 'LVA', 'LBN', 'LSO', 'LBR', 'LBY', 'LIE',
    'LTU', 'LUX', 'MAC', 'MKD', 'MDG', 'MWI', 'MYS', 'MDV', 'MLI', 'MLT', 'MHL', 'MTQ', 'MRT', 'MUS', 'MYT', 'MEX',
    'FSM', 'MDA', 'MCO', 'MNG', 'MNE', 'MSR', 'MAR', 'MOZ', 'MMR', 'NAM', 'NRU', 'NPL', 'NLD', 'NCL', 'NZL', 'NIC',
    'NER', 'NGA', 'NIU', 'NFK', 'MNP', 'NOR', 'OMN', 'PAK', 'PLW', 'PSE', 'PAN', 'PNG', 'PRY', 'PER', 'PHL', 'PCN',
    'POL', 'PRT', 'PRI', 'QAT', 'REU', 'ROU', 'RUS', 'RWA', 'BLM', 'SHN', 'KNA', 'LCA', 'MAF', 'SPM', 'VCT', 'WSM',
    'SMR', 'STP', 'SAU', 'SEN', 'SRB', 'SYC', 'SLE', 'SGP', 'SXM', 'SVK', 'SVN', 'SLB', 'SOM', 'ZAF', 'SGS', 'SSD',
    'ESP', 'LKA', 'SDN', 'SUR', 'SJM', 'SWZ', 'SWE', 'CHE', 'SYR', 'TWN', 'TJK', 'TZA', 'THA', 'TLS', 'TGO', 'TKL',
    'TON', 'TTO', 'TUN', 'TUR', 'TKM', 'TCA', 'TUV', 'UGA', 'UKR', 'ARE', 'GBR', 'USA', 'UMI', 'URY', 'UZB', 'VUT',
    'VEN', 'VNM', 'VGB', 'VIR', 'WLF', 'ESH', 'YEM', 'ZMB', 'ZWE',
];
/**
 * Check whether the `target` string is a valid
 * ISO 3166-1 alpha-3 officially assigned country code
 *
 * @param target The target string
 * @return true if the `target` is a valid is a valid ISO 3166-1 alpha-2 officially assigned country code, false otherwise
 */
function isISO31661Alpha3(target) {
    assertString(target);
    return includes(validISO31661Alpha3CountriesCodes, target.toUpperCase());
}

// see http://isrc.ifpi.org/en/isrc-standard/code-syntax
const isrc = /^[A-Z]{2}[0-9A-Z]{3}\d{2}\d{5}$/;
/**
 * Checks whether the `target` string is a valid ISRC
 *
 * @param target The target string
 * @return true if the `target` is a valid ISRC, false otherwise
 */
function isISRC(target) {
    assertString(target);
    return isrc.test(target);
}

const issn = '^\\d{4}-?\\d{3}[\\dX]$';
/**
 * Checks whether the `target` string is a valid ISSN
 *
 * @param target The target string
 * @param options The options
 * @return true if the `target` is a valid ISSN, false otherwise
 */
function isISSN(str, options = {}) {
    assertString(str);
    let testIssn = issn;
    testIssn = options.require_hyphen ? testIssn.replace('?', '') : testIssn;
    testIssn = options.case_sensitive ? new RegExp(testIssn) : new RegExp(testIssn, 'i');
    if (!testIssn.test(str)) {
        return false;
    }
    const digits = str.replace('-', '').toUpperCase();
    let checksum = 0;
    for (let i = 0; i < digits.length; i++) {
        const digit = digits[i];
        checksum += (digit === 'X' ? 10 : +digit) * (8 - i);
    }
    return checksum % 11 === 0;
}

/**
 * Checks whether the `target` string is valid JSON
 *
 * @param target The target string
 * @return true if the `target` is a valid ISSN, false otherwise
 */
function isJSON(target) {
    assertString(target);
    try {
        const obj = JSON.parse(target);
        return !!obj && typeof obj === 'object';
    }
    catch (e) { /* ignore */ }
    return false;
}

const jwt = /^([A-Za-z0-9\-_~+\/]+[=]{0,2})\.([A-Za-z0-9\-_~+\/]+[=]{0,2})(?:\.([A-Za-z0-9\-_~+\/]+[=]{0,2}))?$/;
/**
 * Checks whether the `target` string is a valid JWT
 *
 * @param target The target string
 * @return true if the `target` is a valid JWT, false otherwise
 */
function isJWT(target) {
    assertString(target);
    return jwt.test(target);
}

const lat = /^\(?[+-]?(90(\.0+)?|[1-8]?\d(\.\d+)?)$/;
const long = /^\s?[+-]?(180(\.0+)?|1[0-7]\d(\.\d+)?|\d{1,2}(\.\d+)?)\)?$/;
/**
 * Checks whether the `target` string is a valid LatLong
 *
 * @param target The target string
 * @return true if the `target` is a valid LatLong, false otherwise
 */
function isLatLong(target) {
    assertString(target);
    if (!target.includes(','))
        return false;
    const pair = target.split(',');
    if ((pair[0].startsWith('(') && !pair[1].endsWith(')'))
        || (pair[1].endsWith(')') && !pair[0].startsWith('(')))
        return false;
    return lat.test(pair[0]) && long.test(pair[1]);
}

/* eslint-disable prefer-rest-params */
/**
 * Checks whether the `target` string length is valid
 *
 * @param target The target string
 * @param options The options
 * @return true if the `target` has a valid length, false otherwise
 */
function isLength(target, options) {
    assertString(target);
    let min;
    let max;
    if (typeof (options) === 'object') {
        min = options.min || 0;
        max = options.max;
    }
    else { // backwards compatibility: isLength(str, min [, max])
        min = arguments[1] || 0;
        max = arguments[2];
    }
    const surrogatePairs = target.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g) || [];
    const len = target.length - surrogatePairs.length;
    return len >= min && (typeof max === 'undefined' || len <= max);
}

const localeReg = /^[A-z]{2,4}([_-]([A-z]{4}|[\d]{3}))?([_-]([A-z]{2}|[\d]{3}))?$/;
/**
 * Checks whether the `target` string is a valid locale
 *
 * @param target The target string
 * @return true if the `target` is a valid locale, false otherwise
 */
function isLocale(target) {
    assertString(target);
    if (target === 'en_US_POSIX' || target === 'ca_ES_VALENCIA') {
        return true;
    }
    return localeReg.test(target);
}

/**
 * Checks whether the `target` string is lowercase
 *
 * @param target The target string
 * @return true if the `target` is lowercase, false otherwise
 */
function isLowercase(target) {
    assertString(target);
    return target === target.toLowerCase();
}

const macAddress = /^([0-9a-fA-F][0-9a-fA-F]:){5}([0-9a-fA-F][0-9a-fA-F])$/;
const macAddressNoColons = /^([0-9a-fA-F]){12}$/;
const macAddressWithHyphen = /^([0-9a-fA-F][0-9a-fA-F]-){5}([0-9a-fA-F][0-9a-fA-F])$/;
const macAddressWithSpaces = /^([0-9a-fA-F][0-9a-fA-F]\s){5}([0-9a-fA-F][0-9a-fA-F])$/;
/**
 * Checks whether the `target` string is a valid MAC Address
 *
 * @param target The target string
 * @param options The options
 * @return true if the `target` is a valid Mac Address, false otherwise
 */
function isMACAddress(target, options) {
    assertString(target);
    if (options && options.no_colons) {
        return macAddressNoColons.test(target);
    }
    return macAddress.test(target) || macAddressWithHyphen.test(target) || macAddressWithSpaces.test(target);
}

const magnetURI = /^magnet:\?xt=urn:[a-z0-9]+:[a-z0-9]{32,40}&dn=.+&tr=.+$/i;
/**
 * Checks whether the `target` string is a valid Magnet URI
 *
 * @param target The target string
 * @return true if the `target` is a valid Magnet URI, false otherwise
 */
function isMagnetURI(target) {
    assertString(target);
    return magnetURI.test(target.trim());
}

const md5 = /^[a-f0-9]{32}$/;
/**
 * Checks whether the `target` string is a valid MD5 checksum
 *
 * @param target The target string
 * @return true if the `target` is a valid MD5 checksum, false otherwise
 */
function isMD5(target) {
    assertString(target);
    return md5.test(target);
}

/*
  Checks if the provided string matches to a correct Media type format (MIME type)

  This function only checks is the string format follows the
  etablished rules by the according RFC specifications.
  This function supports 'charset' in textual media types
  (https://tools.ietf.org/html/rfc6657).

  This function does not check against all the media types listed
  by the IANA (https://www.iana.org/assignments/media-types/media-types.xhtml)
  because of lightness purposes : it would require to include
  all these MIME types in this librairy, which would weigh it
  significantly. This kind of effort maybe is not worth for the use that
  this function has in this entire librairy.

  More informations in the RFC specifications :
  - https://tools.ietf.org/html/rfc2045
  - https://tools.ietf.org/html/rfc2046
  - https://tools.ietf.org/html/rfc7231#section-3.1.1.1
  - https://tools.ietf.org/html/rfc7231#section-3.1.1.5
*/
// Match simple MIME types
// NB :
//   Subtype length must not exceed 100 characters.
//   This rule does not comply to the RFC specs (what is the max length ?).
const mimeTypeSimple = /^(application|audio|font|image|message|model|multipart|text|video)\/[a-zA-Z0-9\.\-\+]{1,100}$/i; // eslint-disable-line max-len
// Handle "charset" in "text/*"
const mimeTypeText = /^text\/[a-zA-Z0-9\.\-\+]{1,100};\s?charset=("[a-zA-Z0-9\.\-\+\s]{0,70}"|[a-zA-Z0-9\.\-\+]{0,70})(\s?\([a-zA-Z0-9\.\-\+\s]{1,20}\))?$/i; // eslint-disable-line max-len
// Handle "boundary" in "multipart/*"
const mimeTypeMultipart = /^multipart\/[a-zA-Z0-9\.\-\+]{1,100}(;\s?(boundary|charset)=("[a-zA-Z0-9\.\-\+\s]{0,70}"|[a-zA-Z0-9\.\-\+]{0,70})(\s?\([a-zA-Z0-9\.\-\+\s]{1,20}\))?){0,2}$/i; // eslint-disable-line max-len
/**
 * Checks whether the `target` string is a valid Mime Type
 *
 * @param target The target string
 * @return true if the `target` is a valid Mime Type, false otherwise
 */
function isMimeType(str) {
    assertString(str);
    return mimeTypeSimple.test(str) || mimeTypeText.test(str) || mimeTypeMultipart.test(str);
}

/* eslint-disable max-len */
const phones = {
    'am-AM': /^(\+?374|0)((10|[9|7][0-9])\d{6}$|[2-4]\d{7}$)/,
    'ar-AE': /^((\+?971)|0)?5[024568]\d{7}$/,
    'ar-BH': /^(\+?973)?(3|6)\d{7}$/,
    'ar-DZ': /^(\+?213|0)(5|6|7)\d{8}$/,
    'ar-EG': /^((\+?20)|0)?1[0125]\d{8}$/,
    'ar-IQ': /^(\+?964|0)?7[0-9]\d{8}$/,
    'ar-JO': /^(\+?962|0)?7[789]\d{7}$/,
    'ar-KW': /^(\+?965)[569]\d{7}$/,
    'ar-SA': /^(!?(\+?966)|0)?5\d{8}$/,
    'ar-SY': /^(!?(\+?963)|0)?9\d{8}$/,
    'ar-TN': /^(\+?216)?[2459]\d{7}$/,
    'be-BY': /^(\+?375)?(24|25|29|33|44)\d{7}$/,
    'bg-BG': /^(\+?359|0)?8[789]\d{7}$/,
    'bn-BD': /^(\+?880|0)1[13456789][0-9]{8}$/,
    'cs-CZ': /^(\+?420)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,
    'da-DK': /^(\+?45)?\s?\d{2}\s?\d{2}\s?\d{2}\s?\d{2}$/,
    'de-DE': /^(\+49)?0?1(5[0-25-9]\d|6([23]|0\d?)|7([0-57-9]|6\d))\d{7}$/,
    'de-AT': /^(\+43|0)\d{1,4}\d{3,12}$/,
    'el-GR': /^(\+?30|0)?(69\d{8})$/,
    'en-AU': /^(\+?61|0)4\d{8}$/,
    'en-GB': /^(\+?44|0)7\d{9}$/,
    'en-GG': /^(\+?44|0)1481\d{6}$/,
    'en-GH': /^(\+233|0)(20|50|24|54|27|57|26|56|23|28)\d{7}$/,
    'en-HK': /^(\+?852[-\s]?)?[456789]\d{3}[-\s]?\d{4}$/,
    'en-MO': /^(\+?853[-\s]?)?[6]\d{3}[-\s]?\d{4}$/,
    'en-IE': /^(\+?353|0)8[356789]\d{7}$/,
    'en-IN': /^(\+?91|0)?[6789]\d{9}$/,
    'en-KE': /^(\+?254|0)(7|1)\d{8}$/,
    'en-MT': /^(\+?356|0)?(99|79|77|21|27|22|25)[0-9]{6}$/,
    'en-MU': /^(\+?230|0)?\d{8}$/,
    'en-NG': /^(\+?234|0)?[789]\d{9}$/,
    'en-NZ': /^(\+?64|0)[28]\d{7,9}$/,
    'en-PK': /^((\+92)|(0092))-{0,1}\d{3}-{0,1}\d{7}$|^\d{11}$|^\d{4}-\d{7}$/,
    'en-RW': /^(\+?250|0)?[7]\d{8}$/,
    'en-SG': /^(\+65)?[89]\d{7}$/,
    'en-TZ': /^(\+?255|0)?[67]\d{8}$/,
    'en-UG': /^(\+?256|0)?[7]\d{8}$/,
    'en-US': /^((\+1|1)?( |-)?)?(\([2-9][0-9]{2}\)|[2-9][0-9]{2})( |-)?([2-9][0-9]{2}( |-)?[0-9]{4})$/,
    'en-ZA': /^(\+?27|0)\d{9}$/,
    'en-ZM': /^(\+?26)?09[567]\d{7}$/,
    'es-CL': /^(\+?56|0)[2-9]\d{1}\d{7}$/,
    'es-EC': /^(\+?593|0)([2-7]|9[2-9])\d{7}$/,
    'es-ES': /^(\+?34)?(6\d{1}|7[1234])\d{7}$/,
    'es-MX': /^(\+?52)?(1|01)?\d{10,11}$/,
    'es-PA': /^(\+?507)\d{7,8}$/,
    'es-PY': /^(\+?595|0)9[9876]\d{7}$/,
    'es-UY': /^(\+598|0)9[1-9][\d]{6}$/,
    'et-EE': /^(\+?372)?\s?(5|8[1-4])\s?([0-9]\s?){6,7}$/,
    'fa-IR': /^(\+?98[\-\s]?|0)9[0-39]\d[\-\s]?\d{3}[\-\s]?\d{4}$/,
    'fi-FI': /^(\+?358|0)\s?(4(0|1|2|4|5|6)?|50)\s?(\d\s?){4,8}\d$/,
    'fj-FJ': /^(\+?679)?\s?\d{3}\s?\d{4}$/,
    'fo-FO': /^(\+?298)?\s?\d{2}\s?\d{2}\s?\d{2}$/,
    'fr-FR': /^(\+?33|0)[67]\d{8}$/,
    'fr-GF': /^(\+?594|0|00594)[67]\d{8}$/,
    'fr-GP': /^(\+?590|0|00590)[67]\d{8}$/,
    'fr-MQ': /^(\+?596|0|00596)[67]\d{8}$/,
    'fr-RE': /^(\+?262|0|00262)[67]\d{8}$/,
    'he-IL': /^(\+972|0)([23489]|5[012345689]|77)[1-9]\d{6}$/,
    'hu-HU': /^(\+?36)(20|30|70)\d{7}$/,
    'id-ID': /^(\+?62|0)8(1[123456789]|2[1238]|3[1238]|5[12356789]|7[78]|9[56789]|8[123456789])([\s?|\d]{5,11})$/,
    'it-IT': /^(\+?39)?\s?3\d{2} ?\d{6,7}$/,
    'ja-JP': /^(\+81[ \-]?(\(0\))?|0)[6789]0[ \-]?\d{4}[ \-]?\d{4}$/,
    'kk-KZ': /^(\+?7|8)?7\d{9}$/,
    'kl-GL': /^(\+?299)?\s?\d{2}\s?\d{2}\s?\d{2}$/,
    'ko-KR': /^((\+?82)[ \-]?)?0?1([0|1|6|7|8|9]{1})[ \-]?\d{3,4}[ \-]?\d{4}$/,
    'lt-LT': /^(\+370|8)\d{8}$/,
    'ms-MY': /^(\+?6?01){1}(([0145]{1}(\-|\s)?\d{7,8})|([236789]{1}(\s|\-)?\d{7}))$/,
    'nb-NO': /^(\+?47)?[49]\d{7}$/,
    'ne-NP': /^(\+?977)?9[78]\d{8}$/,
    'nl-BE': /^(\+?32|0)4?\d{8}$/,
    'nl-NL': /^(\+?31|0)6?\d{8}$/,
    'nn-NO': /^(\+?47)?[49]\d{7}$/,
    'pl-PL': /^(\+?48)? ?[5-8]\d ?\d{3} ?\d{2} ?\d{2}$/,
    'pt-BR': /(?=^(\+?5{2}\-?|0)[1-9]{2}\-?\d{4}\-?\d{4}$)(^(\+?5{2}\-?|0)[1-9]{2}\-?[6-9]{1}\d{3}\-?\d{4}$)|(^(\+?5{2}\-?|0)[1-9]{2}\-?9[6-9]{1}\d{3}\-?\d{4}$)/,
    'pt-PT': /^(\+?351)?9[1236]\d{7}$/,
    'ro-RO': /^(\+?4?0)\s?7\d{2}(\/|\s|\.|\-)?\d{3}(\s|\.|\-)?\d{3}$/,
    'ru-RU': /^(\+?7|8)?9\d{9}$/,
    'sl-SI': /^(\+386\s?|0)(\d{1}\s?\d{3}\s?\d{2}\s?\d{2}|\d{2}\s?\d{3}\s?\d{3})$/,
    'sk-SK': /^(\+?421)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,
    'sr-RS': /^(\+3816|06)[- \d]{5,9}$/,
    'sv-SE': /^(\+?46|0)[\s\-]?7[\s\-]?[02369]([\s\-]?\d){7}$/,
    'th-TH': /^(\+66|66|0)\d{9}$/,
    'tr-TR': /^(\+?90|0)?5\d{9}$/,
    'uk-UA': /^(\+?38|8)?0\d{9}$/,
    'vi-VN': /^(\+?84|0)((3([2-9]))|(5([2689]))|(7([0|6-9]))|(8([1-6|89]))|(9([0-9])))([0-9]{7})$/,
    'zh-CN': /^((\+|00)86)?1([358][0-9]|4[579]|6[67]|7[01235678]|9[189])[0-9]{8}$/,
    'zh-TW': /^(\+?886\-?|0)?9\d{8}$/,
};
/* eslint-enable max-len */
// aliases
phones['en-CA'] = phones['en-US'];
phones['fr-BE'] = phones['nl-BE'];
phones['zh-HK'] = phones['en-HK'];
phones['zh-MO'] = phones['en-MO'];
/**
 * Checks whether the `target` string is a valid Mobile Phone Number
 *
 * @param target The target string
 * @param locale The locale
 * @param options The options
 * @throws Error If the local passed in is not supported.
 * @return true if the `target` is a valid Mobile Phone Number, false otherwise
 */
function isMobilePhone(target, locale, options) {
    assertString(target);
    if (options && options.strictMode && !target.startsWith('+')) {
        return false;
    }
    if (Array.isArray(locale)) {
        return locale.some((key) => {
            // https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md#ignoring-code-for-coverage-purposes
            // istanbul ignore else
            if (phones.hasOwnProperty(key)) {
                const phone = phones[key];
                if (phone.test(target)) {
                    return true;
                }
            }
            return false;
        });
    }
    else if (locale in phones) {
        return phones[locale].test(target);
        // alias falsey locale as 'any'
    }
    else if (!locale || locale === 'any') {
        for (const key in phones) {
            // istanbul ignore else
            if (phones.hasOwnProperty(key)) {
                const phone = phones[key];
                if (phone.test(target)) {
                    return true;
                }
            }
        }
        return false;
    }
    throw new Error(`Invalid locale '${locale}'`);
}
/**
 * The supported locale list.
 */
const isMobilePhoneLocales = Object.keys(phones);

/**
 * Checks whether the `target` string is a valid MongoID
 *
 * @param target The target string
 * @return true if the `target` is a valid MongoID, false otherwise
 */
function isMongoId(target) {
    assertString(target);
    return isHexadecimal(target) && target.length === 24;
}

/* eslint-disable no-control-regex */
const multibyte = /[^\x00-\x7F]/;
/* eslint-enable no-control-regex */
/**
 * Checks whether the `target` string contains one or more multibyte characters
 *
 * @param target The target string
 * @return true if the `target` contains one or more multibyte characters, false otherwise
 */
function isMultibyte(target) {
    assertString(target);
    return multibyte.test(target);
}

const numeric = /^[+-]?([0-9]*[.])?[0-9]+$/;
const numericNoSymbols = /^[0-9]+$/;
/**
 * Checks whether the `target` string contains only numbers
 *
 * @param target The target string
 * @param options The options
 * @return true if the `target` contains only numbers, false otherwise
 */
function isNumeric(str, options) {
    assertString(str);
    if (options && options.no_symbols) {
        return numericNoSymbols.test(str);
    }
    return numeric.test(str);
}

const octal = /^(0o)?[0-7]+$/i;
/**
 * Checks whether the `target` string is a valid Octal number
 *
 * @param target The target string
 * @return true if the `target` is a valid Octal number, false otherwise
 */
function isOctal(target) {
    assertString(target);
    return octal.test(target);
}

/**
 * Reference:
 * https://en.wikipedia.org/ -- Wikipedia
 * https://docs.microsoft.com/en-us/microsoft-365/compliance/eu-passport-number -- EU Passport Number
 * https://countrycode.org/ -- Country Codes
 */
const passportRegexByCountryCode = {
    AM: /^[A-Z]{2}\d{7}$/,
    AR: /^[A-Z]{3}\d{6}$/,
    AT: /^[A-Z]\d{7}$/,
    AU: /^[A-Z]\d{7}$/,
    BE: /^[A-Z]{2}\d{6}$/,
    BG: /^\d{9}$/,
    CA: /^[A-Z]{2}\d{6}$/,
    CH: /^[A-Z]\d{7}$/,
    CN: /^[GE]\d{8}$/,
    CY: /^[A-Z](\d{6}|\d{8})$/,
    CZ: /^\d{8}$/,
    DE: /^[CFGHJKLMNPRTVWXYZ0-9]{9}$/,
    DK: /^\d{9}$/,
    EE: /^([A-Z]\d{7}|[A-Z]{2}\d{7})$/,
    ES: /^[A-Z0-9]{2}([A-Z0-9]?)\d{6}$/,
    FI: /^[A-Z]{2}\d{7}$/,
    FR: /^\d{2}[A-Z]{2}\d{5}$/,
    GB: /^\d{9}$/,
    GR: /^[A-Z]{2}\d{7}$/,
    HR: /^\d{9}$/,
    HU: /^[A-Z]{2}(\d{6}|\d{7})$/,
    IE: /^[A-Z0-9]{2}\d{7}$/,
    IS: /^(A)\d{7}$/,
    IT: /^[A-Z0-9]{2}\d{7}$/,
    JP: /^[A-Z]{2}\d{7}$/,
    KR: /^[MS]\d{8}$/,
    LT: /^[A-Z0-9]{8}$/,
    LU: /^[A-Z0-9]{8}$/,
    LV: /^[A-Z0-9]{2}\d{7}$/,
    MT: /^\d{7}$/,
    NL: /^[A-Z]{2}[A-Z0-9]{6}\d$/,
    PO: /^[A-Z]{2}\d{7}$/,
    PT: /^[A-Z]\d{6}$/,
    RO: /^\d{8,9}$/,
    SE: /^\d{8}$/,
    SL: /^(P)[A-Z]\d{7}$/,
    SK: /^[0-9A-Z]\d{7}$/,
    TR: /^[A-Z]\d{8}$/,
    UA: /^[A-Z]{2}\d{6}$/,
    US: /^\d{9}$/,
};
/**
 * Check if `target` is a valid passport number
 * relative to provided `arg` ISO Country Code.
 *
 * @param target The passport number
 * @param arg The country code
 * @return true if the `target` is a passport number, false otherwise
 */
function isPassportNumber(target, arg) {
    /** Remove All Whitespaces, Convert to UPPERCASE */
    const normalizedStr = target.replace(/\s/g, '').toUpperCase();
    return (arg.toUpperCase() in passportRegexByCountryCode) &&
        passportRegexByCountryCode[arg].test(normalizedStr);
}

/**
 * Check if `target` is a valid port number
 *
 * @param target The port number
 * @return true if the `target` is a port number, false otherwise
 *
 * @example
```
const isPortNumber:boolean = isPort('4200')
```
 */
function isPort(target) {
    return isInt(target, { min: 0, max: 65535 });
}

// common patterns
const threeDigit = /^\d{3}$/;
const fourDigit = /^\d{4}$/;
const fiveDigit = /^\d{5}$/;
const sixDigit = /^\d{6}$/;
const patterns = {
    AD: /^AD\d{3}$/,
    AT: fourDigit,
    AU: fourDigit,
    BE: fourDigit,
    BG: fourDigit,
    BR: /^\d{5}-\d{3}$/,
    CA: /^[ABCEGHJKLMNPRSTVXY]\d[ABCEGHJ-NPRSTV-Z][\s\-]?\d[ABCEGHJ-NPRSTV-Z]\d$/i,
    CH: fourDigit,
    CZ: /^\d{3}\s?\d{2}$/,
    DE: fiveDigit,
    DK: fourDigit,
    DZ: fiveDigit,
    EE: fiveDigit,
    ES: fiveDigit,
    FI: fiveDigit,
    FR: /^\d{2}\s?\d{3}$/,
    GB: /^(gir\s?0aa|[a-z]{1,2}\d[\da-z]?\s?(\d[a-z]{2})?)$/i,
    GR: /^\d{3}\s?\d{2}$/,
    HR: /^([1-5]\d{4}$)/,
    HU: fourDigit,
    ID: fiveDigit,
    IE: /^(?!.*(?:o))[A-z]\d[\dw]\s\w{4}$/i,
    IL: fiveDigit,
    IN: /^((?!10|29|35|54|55|65|66|86|87|88|89)[1-9][0-9]{5})$/,
    IS: threeDigit,
    IT: fiveDigit,
    JP: /^\d{3}\-\d{4}$/,
    KE: fiveDigit,
    LI: /^(948[5-9]|949[0-7])$/,
    LT: /^LT\-\d{5}$/,
    LU: fourDigit,
    LV: /^LV\-\d{4}$/,
    MX: fiveDigit,
    MT: /^[A-Za-z]{3}\s{0,1}\d{4}$/,
    NL: /^\d{4}\s?[a-z]{2}$/i,
    NO: fourDigit,
    NZ: fourDigit,
    PL: /^\d{2}\-\d{3}$/,
    PR: /^00[679]\d{2}([ -]\d{4})?$/,
    PT: /^\d{4}\-\d{3}?$/,
    RO: sixDigit,
    RU: sixDigit,
    SA: fiveDigit,
    SE: /^[1-9]\d{2}\s?\d{2}$/,
    SI: fourDigit,
    SK: /^\d{3}\s?\d{2}$/,
    TN: fourDigit,
    TW: /^\d{3}(\d{2})?$/,
    UA: fiveDigit,
    US: /^\d{5}(-\d{4})?$/,
    ZA: fourDigit,
    ZM: fiveDigit,
};
const postalCodeLocales = Object.keys(patterns);
/**
 * Checks whether the `target` string is a valid postal code
 *
 * @param target The target string
 * @param arg The locale
 * @return true if the `target` is a valid postal code, false otherwise
 */
function isPostalCode(target, arg) {
    assertString(target);
    if (arg in patterns) {
        return patterns[arg].test(target);
    }
    else if (arg === 'any') {
        for (const key in patterns) {
            // https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md#ignoring-code-for-coverage-purposes
            // istanbul ignore else
            if (patterns.hasOwnProperty(key)) {
                const pattern = patterns[key];
                if (pattern.test(target)) {
                    return true;
                }
            }
        }
        return false;
    }
    throw new Error(`Invalid locale '${arg}'`);
}

/* Based on https://tools.ietf.org/html/rfc3339#section-5.6 */
const dateFullYear = /[0-9]{4}/;
const dateMonth = /(0[1-9]|1[0-2])/;
const dateMDay = /([12]\d|0[1-9]|3[01])/;
const timeHour = /([01][0-9]|2[0-3])/;
const timeMinute = /[0-5][0-9]/;
const timeSecond = /([0-5][0-9]|60)/;
const timeSecFrac = /(\.[0-9]+)?/;
const timeNumOffset = new RegExp(`[-+]${timeHour.source}:${timeMinute.source}`);
const timeOffset = new RegExp(`([zZ]|${timeNumOffset.source})`);
const partialTime = new RegExp(`${timeHour.source}:${timeMinute.source}:${timeSecond.source}${timeSecFrac.source}`);
const fullDate = new RegExp(`${dateFullYear.source}-${dateMonth.source}-${dateMDay.source}`);
const fullTime = new RegExp(`${partialTime.source}${timeOffset.source}`);
const rfc3339 = new RegExp(`${fullDate.source}[ tT]${fullTime.source}`);
/**
 * Check if `target` is a valid RFC3339 timestamp
 *
 * @param target The time stamp
 * @return true if the `target` is a valid RFC3339 timestamp, false otherwise
 *
 * @example
```
const isRFC3339:boolean = isRFC3339('2002-10-02T15:00:00Z')
```
 */
function isRFC3339(target) {
    assertString(target);
    return rfc3339.test(target);
}

const rgbColor = /^rgb\((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]),){2}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\)$/;
const rgbaColor = /^rgba\((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]),){3}(0?\.\d|1(\.0)?|0(\.0)?)\)$/;
const rgbColorPercent = /^rgb\((([0-9]%|[1-9][0-9]%|100%),){2}([0-9]%|[1-9][0-9]%|100%)\)/;
const rgbaColorPercent = /^rgba\((([0-9]%|[1-9][0-9]%|100%),){3}(0?\.\d|1(\.0)?|0(\.0)?)\)/;
/**
 * Check if `target` is a valid RGB color
 *
 * @param target The RGB color
 * @return true if the `target` is a valid RGB color, false otherwise
 *
 */
function isRgbColor(target, includePercentValues = `true`) {
    assertString(target);
    if (!includePercentValues) {
        return rgbColor.test(target) || rgbaColor.test(target);
    }
    return rgbColor.test(target) ||
        rgbaColor.test(target) ||
        rgbColorPercent.test(target) ||
        rgbaColorPercent.test(target);
}

/**
 * Build RegExp object from an array
 * of multiple/multi-line regexp parts
 *
 * @param {string[]} parts
 * @param {string} flags
 * @return {object} - RegExp object
 */
function multilineRegexp(parts, flags = '') {
    const regexpAsStringLiteral = parts.join('');
    return new RegExp(regexpAsStringLiteral, flags);
}

/**
 * Regular Expression to match
 * semantic versioning (SemVer)
 * built from multi-line, multi-parts regexp
 * Reference: https://semver.org/
 */
const semanticVersioningRegex = multilineRegexp([
    '^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)',
    '(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))',
    '?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$',
]);
/**
 * Check if `target` is a valid semver version
 *
 * @param target The target
 * @return true if the `target` is a valid semver version, false otherwise
 */
function isSemVer(target) {
    assertString(target);
    return semanticVersioningRegex.test(target);
}

let charsetRegex = /^[^-_](?!.*?[-_]{2,})([a-z0-9\\-]{1,}).*[^-_]$/;
/**
 * Check if `target` is a valid slug
 *
 * @param target The target
 * @return true if the `target` is a valid slug, false otherwise
 */
function isSlug(target) {
    assertString(target);
    return (charsetRegex.test(target));
}

const surrogatePair = /[\uD800-\uDBFF][\uDC00-\uDFFF]/;
/**
 * Check if `target` is a valid surrogate pair
 *
 * @param target The target
 * @return true if the `target` a valid surrogate pair, false otherwise
 */
function isSurrogatePair(target) {
    assertString(target);
    return surrogatePair.test(target);
}

/**
 * Check if `target` is uppercase
 *
 * @param target The target
 * @return true if the `target` is uppercase, false otherwise
 */
function isUppercase(target) {
    assertString(target);
    return target === target.toUpperCase();
}

const default_url_options = {
    protocols: ['http', 'https', 'ftp'],
    require_tld: true,
    require_protocol: false,
    require_host: true,
    require_valid_protocol: true,
    allow_underscores: false,
    allow_trailing_dot: false,
    allow_protocol_relative_urls: false,
};
const wrapped_ipv6 = /^\[([^\]]+)\](?::([0-9]+))?$/;
function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
}
function checkHost(host, matches) {
    for (let i = 0; i < matches.length; i++) {
        let match = matches[i];
        if (host === match || (isRegExp(match) && match.test(host))) {
            return true;
        }
    }
    return false;
}
/**
 * Checks whether the `target` string is valid URL
 *
 * @param target The target string
 * @param options The options
 * @return true if the `target` is a valid URL, false otherwise
 */
function isURL(target, options) {
    assertString(target);
    if (!target || target.length >= 2083 || /[\s<>]/.test(target)) {
        return false;
    }
    if (target.indexOf('mailto:') === 0) {
        return false;
    }
    options = merge(options, default_url_options);
    let protocol, auth, host, hostname, port, port_str, split, ipv6;
    split = target.split('#');
    target = split.shift();
    split = target.split('?');
    target = split.shift();
    split = target.split('://');
    if (split.length > 1) {
        protocol = split.shift().toLowerCase();
        if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {
            return false;
        }
    }
    else if (options.require_protocol) {
        return false;
    }
    else if (target.substr(0, 2) === '//') {
        if (!options.allow_protocol_relative_urls) {
            return false;
        }
        split[0] = target.substr(2);
    }
    target = split.join('://');
    if (target === '') {
        return false;
    }
    split = target.split('/');
    target = split.shift();
    if (target === '' && !options.require_host) {
        return true;
    }
    split = target.split('@');
    if (split.length > 1) {
        if (options.disallow_auth) {
            return false;
        }
        auth = split.shift();
        if (auth.indexOf(':') >= 0 && auth.split(':').length > 2) {
            return false;
        }
    }
    hostname = split.join('@');
    port_str = null;
    ipv6 = null;
    const ipv6_match = hostname.match(wrapped_ipv6);
    if (ipv6_match) {
        host = '';
        ipv6 = ipv6_match[1];
        port_str = ipv6_match[2] || null;
    }
    else {
        split = hostname.split(':');
        host = split.shift();
        if (split.length) {
            port_str = split.join(':');
        }
    }
    if (port_str !== null) {
        port = parseInt(port_str, 10);
        if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {
            return false;
        }
    }
    if (!isIP(host) && !isFQDN(host, options) && (!ipv6 || !isIP(ipv6, '6'))) {
        return false;
    }
    host = host || ipv6;
    if (options.host_whitelist && !checkHost(host, options.host_whitelist)) {
        return false;
    }
    if (options.host_blacklist && checkHost(host, options.host_blacklist)) {
        return false;
    }
    return true;
}

const uuid = {
    3: /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
    4: /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
    5: /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
    all: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
};
/**
 * Checks whether the `target` is a valid UUID
 *
 * @param target The target string
 * @param version The version
 * @return true if the `target` is  a valid UUID, false otherwise
 */
function isUUID(str, version) {
    version = version ? version : 'all';
    assertString(str);
    const pattern = uuid[version];
    return pattern && pattern.test(str);
}

/**
 * Checks whether the `target` is variable width
 *
 * @param target The target string
 * @return true if the `target` is variable width, false otherwise
 */
function isVariableWidth(target) {
    assertString(target);
    return fullWidth.test(target) && halfWidth.test(target);
}

//checks characters if they appear in the whitelist.
/**
 * Checks whether the `target` string appears in the white list `arg`
 *
 * @param target The target string
 * @param arg The white list
 * @return true if the `target` appears in the whitelist, false otherwise
 */
function isWhitelisted(target, arg) {
    assertString(target);
    for (let i = target.length - 1; i >= 0; i--) {
        if (arg.indexOf(target[i]) === -1) {
            return false;
        }
    }
    return true;
}

/**
 * Check whether the target matches the pattern
 * @param target The target
 * @param pattern The RegExp
 * @param modifiers The optional modifier
 * @return true if the target matches, false otherwise
 */
function matches(target, pattern, modifiers) {
    assertString(target);
    if (Object.prototype.toString.call(pattern) !== '[object RegExp]') {
        pattern = new RegExp(pattern, modifiers);
    }
    return pattern.test(target);
}

function blacklist$1(str, chars) {
    assertString(str);
    return str.replace(new RegExp(`[${chars}]+`, 'g'), '');
}

function ltrim(str, chars) {
    assertString(str);
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping
    const pattern = chars ? new RegExp(`^[${chars.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}]+`, 'g') : /^\s+/g;
    return str.replace(pattern, '');
}

function rtrim(str, chars) {
    assertString(str);
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping
    const pattern = chars ? new RegExp(`[${chars.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}]+$`, 'g') : /\s+$/g;
    return str.replace(pattern, '');
}

function stripLow(str, keep_new_lines) {
    assertString(str);
    const chars = keep_new_lines ? '\\x00-\\x09\\x0B\\x0C\\x0E-\\x1F\\x7F' : '\\x00-\\x1F\\x7F';
    return blacklist$1(str, chars);
}

function toBoolean(str, strict) {
    assertString(str);
    if (strict) {
        return str === '1' || /^true$/i.test(str);
    }
    return str !== '0' && !/^false$/i.test(str) && str !== '';
}

function toInt(str, radix) {
    assertString(str);
    return parseInt(str, radix || 10);
}

function trim(str, chars) {
    return rtrim(ltrim(str, chars), chars);
}

function unescape(str) {
    assertString(str);
    return (str.replace(/&amp;/g, '&')
        .replace(/&quot;/g, '"')
        .replace(/&#x27;/g, "'")
        .replace(/&lt;/g, '<')
        .replace(/&gt;/g, '>')
        .replace(/&#x2F;/g, '/')
        .replace(/&#x5C;/g, '\\')
        .replace(/&#96;/g, '`'));
}

function whitelist(str, chars) {
    assertString(str);
    return str.replace(new RegExp(`[^${chars}]+`, 'g'), '');
}

/*
 * Public API Surface of validatorjs
 */

/**
 * Generated bundle index. Do not edit.
 */

export { alpha, alphanumeric, arabicLocales, blacklist$1 as blacklist, commaDecimal, contains, decimal, default_email_options, dotDecimal, englishLocales, equals, escape, floatLocales, fullWidth, halfWidth, isAfter, isAlpha, isAlphaLocales, isAlphaNumeric, isAlphaNumericLocales, isAscii, isBIC, isBase32, isBase64, isBefore, isBoolean, isBtcAddress, isByteLength, isCreditCard, isCurrency, isDataURI, isDecimal, isDivisibleBy, isEAN, isEmail, isEmpty, isEthereumAddress, isFQDN, isFloat, isFullWidth, isHSL, isHalfWidth, isHash, isHexColor, isHexadecimal, isIBAN, isIP, isISBN, isISIN, isISO31661Alpha2, isISO31661Alpha3, isISO8601, isISRC, isISSN, isIdentityCard, isIn, isInt, isJSON, isJWT, isLatLong, isLength, isLocale, isLowercase, isMACAddress, isMD5, isMagnetURI, isMimeType, isMobilePhone, isMobilePhoneLocales, isMongoId, isMultibyte, isNumeric, isOctal, isPassportNumber, isPort, isPostalCode, isRFC3339, isRgbColor, isSemVer, isSlug, isSurrogatePair, isURL, isUUID, isUppercase, isVariableWidth, isWhitelisted, ltrim, matches, postalCodeLocales, rtrim, stripLow, toBoolean, toDate, toFloat, toInt, trim, unescape, whitelist, ɵ0, ɵ1, ɵ2 };
//# sourceMappingURL=fireflysemantics-validatorts.js.map
