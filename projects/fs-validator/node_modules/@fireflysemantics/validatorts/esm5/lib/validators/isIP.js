import { assertString } from '../util/assertString';
/**
11.3.  Examples

   The following addresses

             fe80::1234 (on the 1st link of the node)
             ff02::5678 (on the 5th link of the node)
             ff08::9abc (on the 10th organization of the node)

   would be represented as follows:

             fe80::1234%1
             ff02::5678%5
             ff08::9abc%10

   (Here we assume a natural translation from a zone index to the
   <zone_id> part, where the Nth zone of any scope is translated into
   "N".)

   If we use interface names as <zone_id>, those addresses could also be
   represented as follows:

            fe80::1234%ne0
            ff02::5678%pvc1.3
            ff08::9abc%interface10

   where the interface "ne0" belongs to the 1st link, "pvc1.3" belongs
   to the 5th link, and "interface10" belongs to the 10th organization.
 * * */
var ipv4Maybe = /^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$/;
var ipv6Block = /^[0-9A-F]{1,4}$/i;
/**
 * Checks whether the `target` string is an int
 *
 * @param target The target string
 * @param version The version
 * @return true if the `target` is an int, false otherwise
 */
export function isIP(str, version) {
    if (version === void 0) { version = '4'; }
    assertString(str);
    version = String(version);
    if (!version) {
        return isIP(str, '4') || isIP(str, '6');
    }
    else if (version === '4') {
        if (!ipv4Maybe.test(str)) {
            return false;
        }
        var parts = str.split('.').sort(function (a, b) { return a - b; });
        return parseInt(parts[3]) <= 255;
    }
    else if (version === '6') {
        var addressAndZone = [str];
        // ipv6 addresses could have scoped architecture
        // according to https://tools.ietf.org/html/rfc4007#section-11
        if (str.includes('%')) {
            addressAndZone = str.split('%');
            if (addressAndZone.length !== 2) {
                // it must be just two parts
                return false;
            }
            if (!addressAndZone[0].includes(':')) {
                // the first part must be the address
                return false;
            }
            if (addressAndZone[1] === '') {
                // the second part must not be empty
                return false;
            }
        }
        var blocks = addressAndZone[0].split(':');
        var foundOmissionBlock = false; // marker to indicate ::
        // At least some OS accept the last 32 bits of an IPv6 address
        // (i.e. 2 of the blocks) in IPv4 notation, and RFC 3493 says
        // that '::ffff:a.b.c.d' is valid for IPv4-mapped IPv6 addresses,
        // and '::a.b.c.d' is deprecated, but also valid.
        var foundIPv4TransitionBlock = isIP(blocks[blocks.length - 1], '4');
        var expectedNumberOfBlocks = foundIPv4TransitionBlock ? 7 : 8;
        if (blocks.length > expectedNumberOfBlocks) {
            return false;
        }
        // initial or final ::
        if (str === '::') {
            return true;
        }
        else if (str.substr(0, 2) === '::') {
            blocks.shift();
            blocks.shift();
            foundOmissionBlock = true;
        }
        else if (str.substr(str.length - 2) === '::') {
            blocks.pop();
            blocks.pop();
            foundOmissionBlock = true;
        }
        for (var i = 0; i < blocks.length; ++i) {
            // test for a :: which can not be at the string start/end
            // since those cases have been handled above
            if (blocks[i] === '' && i > 0 && i < blocks.length - 1) {
                if (foundOmissionBlock) {
                    return false; // multiple :: in address
                }
                foundOmissionBlock = true;
            }
            else if (foundIPv4TransitionBlock && i === blocks.length - 1) {
                // it has been checked before that the last
                // block is a valid IPv4 address
            }
            else if (!ipv6Block.test(blocks[i])) {
                return false;
            }
        }
        if (foundOmissionBlock) {
            return blocks.length >= 1;
        }
        return blocks.length === expectedNumberOfBlocks;
    }
    return false;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaXNJUC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BmaXJlZmx5c2VtYW50aWNzL3ZhbGlkYXRvcnRzLyIsInNvdXJjZXMiOlsibGliL3ZhbGlkYXRvcnMvaXNJUC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDcEQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0E0Qk87QUFDUCxJQUFNLFNBQVMsR0FBRywyR0FBMkcsQ0FBQztBQUM5SCxJQUFNLFNBQVMsR0FBRyxrQkFBa0IsQ0FBQztBQUVyQzs7Ozs7O0dBTUc7QUFDSCxNQUFNLFVBQVUsSUFBSSxDQUFDLEdBQVcsRUFBRSxPQUFxQjtJQUFyQix3QkFBQSxFQUFBLGFBQXFCO0lBQ3JELFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNsQixPQUFPLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQzFCLElBQUksQ0FBQyxPQUFPLEVBQUU7UUFDWixPQUFPLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLElBQUksSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztLQUN6QztTQUFNLElBQUksT0FBTyxLQUFLLEdBQUcsRUFBRTtRQUMxQixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUN4QixPQUFPLEtBQUssQ0FBQztTQUNkO1FBQ0QsSUFBTSxLQUFLLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBQyxDQUFNLEVBQUUsQ0FBTSxJQUFLLE9BQUEsQ0FBQyxHQUFHLENBQUMsRUFBTCxDQUFLLENBQUMsQ0FBQztRQUM3RCxPQUFPLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxHQUFHLENBQUM7S0FDbEM7U0FBTSxJQUFJLE9BQU8sS0FBSyxHQUFHLEVBQUU7UUFDMUIsSUFBSSxjQUFj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QzNCO1FBQ0QsT0FBTyxNQUFNLENBQUMsTUFBTSxLQUFLLHNCQUFzQixDQUFDO0tBQ2pEO0lBQ0QsT0FBTyxLQUFLLENBQUM7QUFDZixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXNzZXJ0U3RyaW5nIH0gZnJvbSAnLi4vdXRpbC9hc3NlcnRTdHJpbmcnO1xuLyoqXG4xMS4zLiAgRXhhbXBsZXNcblxuICAgVGhlIGZvbGxvd2luZyBhZGRyZXNzZXNcblxuICAgICAgICAgICAgIGZlODA6OjEyMzQgKG9uIHRoZSAxc3QgbGluayBvZiB0aGUgbm9kZSlcbiAgICAgICAgICAgICBmZjAyOjo1Njc4IChvbiB0aGUgNXRoIGxpbmsgb2YgdGhlIG5vZGUpXG4gICAgICAgICAgICAgZmYwODo6OWFiYyAob24gdGhlIDEwdGggb3JnYW5pemF0aW9uIG9mIHRoZSBub2RlKVxuXG4gICB3b3VsZCBiZSByZXByZXNlbnRlZCBhcyBmb2xsb3dzOlxuXG4gICAgICAgICAgICAgZmU4MDo6MTIzNCUxXG4gICAgICAgICAgICAgZmYwMjo6NTY3OCU1XG4gICAgICAgICAgICAgZmYwODo6OWFiYyUxMFxuXG4gICAoSGVyZSB3ZSBhc3N1bWUgYSBuYXR1cmFsIHRyYW5zbGF0aW9uIGZyb20gYSB6b25lIGluZGV4IHRvIHRoZVxuICAgPHpvbmVfaWQ+IHBhcnQsIHdoZXJlIHRoZSBOdGggem9uZSBvZiBhbnkgc2NvcGUgaXMgdHJhbnNsYXRlZCBpbnRvXG4gICBcIk5cIi4pXG5cbiAgIElmIHdlIHVzZSBpbnRlcmZhY2UgbmFtZXMgYXMgPHpvbmVfaWQ+LCB0aG9zZSBhZGRyZXNzZXMgY291bGQgYWxzbyBiZVxuICAgcmVwcmVzZW50ZWQgYXMgZm9sbG93czpcblxuICAgICAgICAgICAgZmU4MDo6MTIzNCVuZTBcbiAgICAgICAgICAgIGZmMDI6OjU2NzglcHZjMS4zXG4gICAgICAgICAgICBmZjA4Ojo5YWJjJWludGVyZmFjZTEwXG5cbiAgIHdoZXJlIHRoZSBpbnRlcmZhY2UgXCJuZTBcIiBiZWxvbmdzIHRvIHRoZSAxc3QgbGluaywgXCJwdmMxLjNcIiBiZWxvbmdzXG4gICB0byB0aGUgNXRoIGxpbmssIGFuZCBcImludGVyZmFjZTEwXCIgYmVsb25ncyB0byB0aGUgMTB0aCBvcmdhbml6YXRpb24uXG4gKiAqICovXG5jb25zdCBpcHY0TWF5YmUgPSAvXigoWzAtOV18WzEtOV1bMC05XXwxWzAtOV17Mn18MlswLTRdWzAtOV18MjVbMC01XSlcXC4pezN9KFswLTldfFsxLTldWzAtOV18MVswLTldezJ9fDJbMC00XVswLTldfDI1WzAtNV0pJC87XG5jb25zdCBpcHY2QmxvY2sgPSAvXlswLTlBLUZdezEsNH0kL2k7XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIGB0YXJnZXRgIHN0cmluZyBpcyBhbiBpbnRcbiAqIFxuICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IHN0cmluZ1xuICogQHBhcmFtIHZlcnNpb24gVGhlIHZlcnNpb25cbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUgYHRhcmdldGAgaXMgYW4gaW50LCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzSVAoc3RyOiBzdHJpbmcsIHZlcnNpb246IHN0cmluZyA9ICc0Jykge1xuICBhc3NlcnRTdHJpbmcoc3RyKTtcbiAgdmVyc2lvbiA9IFN0cmluZyh2ZXJzaW9uKTtcbiAgaWYgKCF2ZXJzaW9uKSB7XG4gICAgcmV0dXJuIGlzSVAoc3RyLCAnNCcpIHx8IGlzSVAoc3RyLCAnNicpO1xuICB9IGVsc2UgaWYgKHZlcnNpb24gPT09ICc0Jykge1xuICAgIGlmICghaXB2NE1heWJlLnRlc3Qoc3RyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBwYXJ0cyA9IHN0ci5zcGxpdCgnLicpLnNvcnQoKGE6IGFueSwgYjogYW55KSA9PiBhIC0gYik7XG4gICAgcmV0dXJuIHBhcnNlSW50KHBhcnRzWzNdKSA8PSAyNTU7XG4gIH0gZWxzZSBpZiAodmVyc2lvbiA9PT0gJzYnKSB7XG4gICAgbGV0IGFkZHJlc3NBbmRab25lID0gW3N0cl07XG4gICAgLy8gaXB2NiBhZGRyZXNzZXMgY291bGQgaGF2ZSBzY29wZWQgYXJjaGl0ZWN0dXJlXG4gICAgLy8gYWNjb3JkaW5nIHRvIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM0MDA3I3NlY3Rpb24tMTFcbiAgICBpZiAoc3RyLmluY2x1ZGVzKCclJykpIHtcbiAgICAgIGFkZHJlc3NBbmRab25lID0gc3RyLnNwbGl0KCclJyk7XG4gICAgICBpZiAoYWRkcmVzc0FuZFpvbmUubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIC8vIGl0IG11c3QgYmUganVzdCB0d28gcGFydHNcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCFhZGRyZXNzQW5kWm9uZVswXS5pbmNsdWRlcygnOicpKSB7XG4gICAgICAgIC8vIHRoZSBmaXJzdCBwYXJ0IG11c3QgYmUgdGhlIGFkZHJlc3NcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWRkcmVzc0FuZFpvbmVbMV0gPT09ICcnKSB7XG4gICAgICAgIC8vIHRoZSBzZWNvbmQgcGFydCBtdXN0IG5vdCBiZSBlbXB0eVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgYmxvY2tzID0gYWRkcmVzc0FuZFpvbmVbMF0uc3BsaXQoJzonKTtcbiAgICBsZXQgZm91bmRPbWlzc2lvbkJsb2NrID0gZmFsc2U7IC8vIG1hcmtlciB0byBpbmRpY2F0ZSA6OlxuXG4gICAgLy8gQXQgbGVhc3Qgc29tZSBPUyBhY2NlcHQgdGhlIGxhc3QgMzIgYml0cyBvZiBhbiBJUHY2IGFkZHJlc3NcbiAgICAvLyAoaS5lLiAyIG9mIHRoZSBibG9ja3MpIGluIElQdjQgbm90YXRpb24sIGFuZCBSRkMgMzQ5MyBzYXlzXG4gICAgLy8gdGhhdCAnOjpmZmZmOmEuYi5jLmQnIGlzIHZhbGlkIGZvciBJUHY0LW1hcHBlZCBJUHY2IGFkZHJlc3NlcyxcbiAgICAvLyBhbmQgJzo6YS5iLmMuZCcgaXMgZGVwcmVjYXRlZCwgYnV0IGFsc28gdmFsaWQuXG4gICAgY29uc3QgZm91bmRJUHY0VHJhbnNpdGlvbkJsb2NrID0gaXNJUChibG9ja3NbYmxvY2tzLmxlbmd0aCAtIDFdLCAnNCcpO1xuICAgIGNvbnN0IGV4cGVjdGVkTnVtYmVyT2ZCbG9ja3MgPSBmb3VuZElQdjRUcmFuc2l0aW9uQmxvY2sgPyA3IDogODtcblxuICAgIGlmIChibG9ja3MubGVuZ3RoID4gZXhwZWN0ZWROdW1iZXJPZkJsb2Nrcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBpbml0aWFsIG9yIGZpbmFsIDo6XG4gICAgaWYgKHN0ciA9PT0gJzo6Jykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChzdHIuc3Vic3RyKDAsIDIpID09PSAnOjonKSB7XG4gICAgICBibG9ja3Muc2hpZnQoKTtcbiAgICAgIGJsb2Nrcy5zaGlmdCgpO1xuICAgICAgZm91bmRPbWlzc2lvbkJsb2NrID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHN0ci5zdWJzdHIoc3RyLmxlbmd0aCAtIDIpID09PSAnOjonKSB7XG4gICAgICBibG9ja3MucG9wKCk7XG4gICAgICBibG9ja3MucG9wKCk7XG4gICAgICBmb3VuZE9taXNzaW9uQmxvY2sgPSB0cnVlO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2tzLmxlbmd0aDsgKytpKSB7XG4gICAgICAvLyB0ZXN0IGZvciBhIDo6IHdoaWNoIGNhbiBub3QgYmUgYXQgdGhlIHN0cmluZyBzdGFydC9lbmRcbiAgICAgIC8vIHNpbmNlIHRob3NlIGNhc2VzIGhhdmUgYmVlbiBoYW5kbGVkIGFib3ZlXG4gICAgICBpZiAoYmxvY2tzW2ldID09PSAnJyAmJiBpID4gMCAmJiBpIDwgYmxvY2tzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgaWYgKGZvdW5kT21pc3Npb25CbG9jaykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gbXVsdGlwbGUgOjogaW4gYWRkcmVzc1xuICAgICAgICB9XG4gICAgICAgIGZvdW5kT21pc3Npb25CbG9jayA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGZvdW5kSVB2NFRyYW5zaXRpb25CbG9jayAmJiBpID09PSBibG9ja3MubGVuZ3RoIC0gMSkge1xuICAgICAgICAvLyBpdCBoYXMgYmVlbiBjaGVja2VkIGJlZm9yZSB0aGF0IHRoZSBsYXN0XG4gICAgICAgIC8vIGJsb2NrIGlzIGEgdmFsaWQgSVB2NCBhZGRyZXNzXG4gICAgICB9IGVsc2UgaWYgKCFpcHY2QmxvY2sudGVzdChibG9ja3NbaV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZvdW5kT21pc3Npb25CbG9jaykge1xuICAgICAgcmV0dXJuIGJsb2Nrcy5sZW5ndGggPj0gMTtcbiAgICB9XG4gICAgcmV0dXJuIGJsb2Nrcy5sZW5ndGggPT09IGV4cGVjdGVkTnVtYmVyT2ZCbG9ja3M7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuIl19