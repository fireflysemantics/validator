(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define('@fireflysemantics/validatorts', ['exports'], factory) :
    (global = global || self, factory((global.fireflysemantics = global.fireflysemantics || {}, global.fireflysemantics.validatorts = {})));
}(this, (function (exports) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __exportStar(m, exports) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }

    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }

    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    function __importStar(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
    }

    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }

    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }

    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    var alpha = {
        'en-US': /^[A-Z]+$/i,
        'bg-BG': /^[А-Я]+$/i,
        'cs-CZ': /^[A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]+$/i,
        'da-DK': /^[A-ZÆØÅ]+$/i,
        'de-DE': /^[A-ZÄÖÜß]+$/i,
        'el-GR': /^[Α-ώ]+$/i,
        'es-ES': /^[A-ZÁÉÍÑÓÚÜ]+$/i,
        'fr-FR': /^[A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]+$/i,
        'it-IT': /^[A-ZÀÉÈÌÎÓÒÙ]+$/i,
        'nb-NO': /^[A-ZÆØÅ]+$/i,
        'nl-NL': /^[A-ZÁÉËÏÓÖÜÚ]+$/i,
        'nn-NO': /^[A-ZÆØÅ]+$/i,
        'hu-HU': /^[A-ZÁÉÍÓÖŐÚÜŰ]+$/i,
        'pl-PL': /^[A-ZĄĆĘŚŁŃÓŻŹ]+$/i,
        'pt-PT': /^[A-ZÃÁÀÂÄÇÉÊËÍÏÕÓÔÖÚÜ]+$/i,
        'ru-RU': /^[А-ЯЁ]+$/i,
        'sl-SI': /^[A-ZČĆĐŠŽ]+$/i,
        'sk-SK': /^[A-ZÁČĎÉÍŇÓŠŤÚÝŽĹŔĽÄÔ]+$/i,
        'sr-RS@latin': /^[A-ZČĆŽŠĐ]+$/i,
        'sr-RS': /^[А-ЯЂЈЉЊЋЏ]+$/i,
        'sv-SE': /^[A-ZÅÄÖ]+$/i,
        'tr-TR': /^[A-ZÇĞİıÖŞÜ]+$/i,
        'uk-UA': /^[А-ЩЬЮЯЄIЇҐі]+$/i,
        'ku-IQ': /^[ئابپتجچحخدرڕزژسشعغفڤقکگلڵمنوۆھەیێيطؤثآإأكضصةظذ]+$/i,
        ar: /^[ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]+$/,
        he: /^[א-ת]+$/,
        'fa-IR': /^['آابپتثجچهخدذرزژسشصضطظعغفقکگلمنوهی']+$/i,
    };
    var alphanumeric = {
        'en-US': /^[0-9A-Z]+$/i,
        'bg-BG': /^[0-9А-Я]+$/i,
        'cs-CZ': /^[0-9A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]+$/i,
        'da-DK': /^[0-9A-ZÆØÅ]+$/i,
        'de-DE': /^[0-9A-ZÄÖÜß]+$/i,
        'el-GR': /^[0-9Α-ω]+$/i,
        'es-ES': /^[0-9A-ZÁÉÍÑÓÚÜ]+$/i,
        'fr-FR': /^[0-9A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]+$/i,
        'it-IT': /^[0-9A-ZÀÉÈÌÎÓÒÙ]+$/i,
        'hu-HU': /^[0-9A-ZÁÉÍÓÖŐÚÜŰ]+$/i,
        'nb-NO': /^[0-9A-ZÆØÅ]+$/i,
        'nl-NL': /^[0-9A-ZÁÉËÏÓÖÜÚ]+$/i,
        'nn-NO': /^[0-9A-ZÆØÅ]+$/i,
        'pl-PL': /^[0-9A-ZĄĆĘŚŁŃÓŻŹ]+$/i,
        'pt-PT': /^[0-9A-ZÃÁÀÂÄÇÉÊËÍÏÕÓÔÖÚÜ]+$/i,
        'ru-RU': /^[0-9А-ЯЁ]+$/i,
        'sl-SI': /^[0-9A-ZČĆĐŠŽ]+$/i,
        'sk-SK': /^[0-9A-ZÁČĎÉÍŇÓŠŤÚÝŽĹŔĽÄÔ]+$/i,
        'sr-RS@latin': /^[0-9A-ZČĆŽŠĐ]+$/i,
        'sr-RS': /^[0-9А-ЯЂЈЉЊЋЏ]+$/i,
        'sv-SE': /^[0-9A-ZÅÄÖ]+$/i,
        'tr-TR': /^[0-9A-ZÇĞİıÖŞÜ]+$/i,
        'uk-UA': /^[0-9А-ЩЬЮЯЄIЇҐі]+$/i,
        'ku-IQ': /^[٠١٢٣٤٥٦٧٨٩0-9ئابپتجچحخدرڕزژسشعغفڤقکگلڵمنوۆھەیێيطؤثآإأكضصةظذ]+$/i,
        ar: /^[٠١٢٣٤٥٦٧٨٩0-9ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]+$/,
        he: /^[0-9א-ת]+$/,
        'fa-IR': /^['0-9آابپتثجچهخدذرزژسشصضطظعغفقکگلمنوهی۱۲۳۴۵۶۷۸۹۰']+$/i,
    };
    var decimal = {
        'en-US': '.',
        ar: '٫',
    };
    var englishLocales = ['AU', 'GB', 'HK', 'IN', 'NZ', 'ZA', 'ZM'];
    for (var locale = void 0, i = 0; i < englishLocales.length; i++) {
        locale = "en-" + englishLocales[i];
        alpha[locale] = alpha['en-US'];
        alphanumeric[locale] = alphanumeric['en-US'];
        decimal[locale] = decimal['en-US'];
    }
    // Source: http://www.localeplanet.com/java/
    var arabicLocales = [
        'AE', 'BH', 'DZ', 'EG', 'IQ', 'JO', 'KW', 'LB', 'LY',
        'MA', 'QM', 'QA', 'SA', 'SD', 'SY', 'TN', 'YE',
    ];
    for (var locale = void 0, i = 0; i < arabicLocales.length; i++) {
        locale = "ar-" + arabicLocales[i];
        alpha[locale] = alpha.ar;
        alphanumeric[locale] = alphanumeric.ar;
        decimal[locale] = decimal.ar;
    }
    // Source: https://en.wikipedia.org/wiki/Decimal_mark
    var dotDecimal = ['ar-EG', 'ar-LB', 'ar-LY'];
    var commaDecimal = [
        'bg-BG', 'cs-CZ', 'da-DK', 'de-DE', 'el-GR', 'en-ZM', 'es-ES', 'fr-FR', 'it-IT', 'ku-IQ', 'hu-HU', 'nb-NO',
        'nn-NO', 'nl-NL', 'pl-PL', 'pt-PT', 'ru-RU', 'sl-SI', 'sr-RS@latin',
        'sr-RS', 'sv-SE', 'tr-TR', 'uk-UA',
    ];
    for (var i = 0; i < dotDecimal.length; i++) {
        decimal[dotDecimal[i]] = decimal['en-US'];
    }
    for (var i = 0; i < commaDecimal.length; i++) {
        decimal[commaDecimal[i]] = ',';
    }
    alpha['pt-BR'] = alpha['pt-PT'];
    alphanumeric['pt-BR'] = alphanumeric['pt-PT'];
    decimal['pt-BR'] = decimal['pt-PT'];
    // see #862
    alpha['pl-Pl'] = alpha['pl-PL'];
    alphanumeric['pl-Pl'] = alphanumeric['pl-PL'];
    decimal['pl-Pl'] = decimal['pl-PL'];

    /**
     * Tests whether `input` is of type string
     * @param input The value that should be a string
     * @throws TypeError if the value is not a string
     */
    function assertString(input) {
        var isString = (typeof input === 'string' || input instanceof String);
        if (!isString) {
            var invalidType = void 0;
            if (input === null) {
                invalidType = 'null';
            }
            else {
                invalidType = typeof input;
                if (invalidType === 'object' && input.constructor && input.constructor.hasOwnProperty('name')) {
                    invalidType = input.constructor.name;
                }
                else {
                    invalidType = "a " + invalidType;
                }
            }
            throw new TypeError("Expected string but received " + invalidType + ".");
        }
    }

    /**
     * Convert the `input` argument into a string
     * @param input The input that should be converted to a string
     * @return The string value for the `input` argument
     */
    function toString(input) {
        if (typeof input === 'object' && input !== null) {
            if (typeof input.toString === 'function') {
                input = input.toString();
            }
            else {
                input = '[object Object]';
            }
        }
        else if (input === null || typeof input === 'undefined' || (isNaN(input) && !input.length)) {
            input = '';
        }
        return String(input);
    }

    /**
     * Test whether the target string contains the arg.
     *
     * @param target The string that should contains the element
     * @param arg The contained string
     * @return true if the `target` string contains the `arg` string, false otherwise
     */
    function contains(target, arg) {
        assertString(target);
        return target.indexOf(toString(arg)) >= 0;
    }

    /**
     * Compares the `target` and `arg` strings for strict (`===`) equality
     *
     * @param target The target string to compare to
     * @param arg The argument to perform the comparison with
     * @return true if the `target` is strictly equal to the `arg`, false otherwise
     */
    function equals(target, arg) {
        assertString(target);
        return target === arg;
    }

    /**
     * Replaces <, >, &, ', " and / with HTML entities.
     * @param str The string to perform the `escape` operation on.
     */
    function escape(str) {
        assertString(str);
        return (str.replace(/&/g, '&amp;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#x27;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/\//g, '&#x2F;')
            .replace(/\\/g, '&#x5C;')
            .replace(/`/g, '&#96;'));
    }

    function toDate(date) {
        assertString(date);
        var millis = Date.parse(date);
        return !isNaN(millis) ? new Date(date) : null;
    }

    /**
     * Checks whether the `target` date comes after the `arg` date
     *
     * @param target The target date
     * @param arg The argument to perform the comparison with
     * @return true if the `target` date comes after the `arg` date, false otherwise
     */
    function isAfter(target, arg) {
        if (arg === void 0) { arg = String(new Date()); }
        assertString(target);
        var comparison = toDate(arg);
        var original = toDate(target);
        return !!(original && comparison && original > comparison);
    }

    /**
     * Checks whether `arg` is in alpha and if so validates whether
     * the `target` string conforms to the `arg` locale.
     *
     * @param target The target string to compare to
     * @param arg The argument that might equal the target
     * @return true if the `target` date comes after the `arg` date, false otherwise
     */
    function isAlpha(target, arg) {
        if (arg === void 0) { arg = 'en-US'; }
        assertString(target);
        if (arg in alpha) {
            return alpha[arg].test(target);
        }
        throw new Error("Invalid locale '" + arg + "'");
    }
    /**
     * The alpha locales
     */
    var isAlphaLocales = Object.keys(alpha);

    /**
     * Checks whether `arg` is in alphanumeric and if so validates whether
     * the `target` string conforms to the `arg` locale.
     *
     * @param target The target string
     * @param arg The locale (Defaults to 'en-US')
     * @return true if the `target` string conforms to the `arg` locale, false otherwise
     */
    function isAlphaNumeric(target, arg) {
        if (arg === void 0) { arg = 'en-US'; }
        assertString(target);
        if (arg in alphanumeric) {
            return alphanumeric[arg].test(target);
        }
        throw new Error("Invalid locale '" + arg + "'");
    }
    /**
     * The alpha numeric locales
     */
    var isAlphaNumericLocales = Object.keys(alphanumeric);

    /* eslint-disable no-control-regex */
    var ascii = /^[\x00-\x7F]+$/;
    /* eslint-enable no-control-regex */
    /**
     * Checks whether the `target` conforms to the ascii standard
     *
     * @param target The target string
     * @return true if the `target` conforms to the ascii standard, false otherwise
     */
    function isAscii(target) {
        assertString(target);
        return ascii.test(target);
    }

    var base32 = /^[A-Z2-7]+=*$/;
    /**
     * Checks whether the `target` is base32 encoded
     *
     * @param target The target string
     * @return true if the `target` is base32 encoded, false otherwise
     */
    function isBase32(str) {
        assertString(str);
        var len = str.length;
        if (len > 0 && len % 8 === 0 && base32.test(str)) {
            return true;
        }
        return false;
    }

    var notBase64 = /[^A-Z0-9+\/=]/i;
    /**
     * Checks whether the `target` is base64 encoded
     *
     * @param target The target string
     * @return true if the `target` is base64 encoded, false otherwise
     */
    function isBase64(str) {
        assertString(str);
        var len = str.length;
        if (!len || len % 4 !== 0 || notBase64.test(str)) {
            return false;
        }
        var firstPaddingChar = str.indexOf('=');
        return firstPaddingChar === -1 ||
            firstPaddingChar === len - 1 ||
            (firstPaddingChar === len - 2 && str[len - 1] === '=');
    }

    /**
     * Checks whether the `target` date comes before the `arg` date
     *
     * @param target The target date
     * @param arg The argument
     * @return true if the `target` date comes before the `arg` date, false otherwise
     */
    function isBefore(target, arg) {
        if (arg === void 0) { arg = String(new Date()); }
        assertString(target);
        var comparison = toDate(arg);
        var original = toDate(target);
        return !!(original && comparison && original < comparison);
    }

    var isBICReg = /^[A-z]{4}[A-z]{2}\w{2}(\w{3})?$/;
    /**
     * Checks whether the `target` is BIC encoded
     *
     * @param target The target string
     * @return true if the `target` is BIC encoded, false otherwise
     */
    function isBIC(str) {
        assertString(str);
        return isBICReg.test(str);
    }

    /**
     * Checks whether the `target` is a boolean value
     * meaning it contains of of `['true', 'false', '1', '0']`
     *
     * @param target The target string
     * @return true if the `target` is a boolean value, false otherwise
     */
    function isBoolean(str) {
        assertString(str);
        return (['true', 'false', '1', '0'].indexOf(str) >= 0);
    }

    // supports Bech32 addresses
    var btc = /^(bc1|[13])[a-zA-HJ-NP-Z0-9]{25,39}$/;
    /**
     * Checks whether the `target` is a btc address
     *
     * @param target The target string
     * @return true if the `target` is a btc address, false otherwise
     */
    function isBtcAddress(str) {
        assertString(str);
        return btc.test(str);
    }

    /* eslint-disable prefer-rest-params */
    /**
     * Checks whether the `target` string's length (in UTF-8 bytes)
     * falls in a range.
     *
     * @param target The target string
     * @param options The option parameters containing the min and max length of the string
     * @return true if the `target` strings conforms to the provided range
     */
    function isByteLength(target, options) {
        assertString(target);
        var min;
        var max;
        if (typeof (options) === 'object') {
            min = options.min || 0;
            max = options.max;
        }
        else { // backwards compatibility: isByteLength(str, min [, max])
            min = arguments[1];
            max = arguments[2];
        }
        var len = encodeURI(target).split(/%..|./).length - 1;
        return len >= min && (typeof max === 'undefined' || len <= max);
    }

    /* eslint-disable max-len */
    var creditCard = /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11}|6[27][0-9]{14})$/;
    /* eslint-enable max-len */
    /**
     * Checks whether the `target` string is a credit card number
     *
     * @param target The target string
     * @return true if the `target` is a credit card number, false otherwise
     */
    function isCreditCard(target) {
        assertString(target);
        var sanitized = target.replace(/[- ]+/g, '');
        if (!creditCard.test(sanitized)) {
            return false;
        }
        var sum = 0;
        var digit;
        var tmpNum;
        var shouldDouble;
        for (var i = sanitized.length - 1; i >= 0; i--) {
            digit = sanitized.substring(i, (i + 1));
            tmpNum = parseInt(digit, 10);
            if (shouldDouble) {
                tmpNum *= 2;
                if (tmpNum >= 10) {
                    sum += ((tmpNum % 10) + 1);
                }
                else {
                    sum += tmpNum;
                }
            }
            else {
                sum += tmpNum;
            }
            shouldDouble = !shouldDouble;
        }
        return !!((sum % 10) === 0 ? sanitized : false);
    }

    function merge(obj, defaults) {
        if (obj === void 0) { obj = {}; }
        for (var key in defaults) {
            if (typeof obj[key] === 'undefined') {
                obj[key] = defaults[key];
            }
        }
        return obj;
    }

    function currencyRegex(options) {
        var decimal_digits = "\\d{" + options.digits_after_decimal[0] + "}";
        options.digits_after_decimal.forEach(function (digit, index) { if (index !== 0)
            decimal_digits = decimal_digits + "|\\d{" + digit + "}"; });
        var symbol = "(\\" + options.symbol.replace(/\./g, '\\.') + ")" + (options.require_symbol ? '' : '?'), negative = '-?', whole_dollar_amount_without_sep = '[1-9]\\d*', whole_dollar_amount_with_sep = "[1-9]\\d{0,2}(\\" + options.thousands_separator + "\\d{3})*", valid_whole_dollar_amounts = [
            '0', whole_dollar_amount_without_sep, whole_dollar_amount_with_sep
        ], whole_dollar_amount = "(" + valid_whole_dollar_amounts.join('|') + ")?", decimal_amount = "(\\" + options.decimal_separator + "(" + decimal_digits + "))" + (options.require_decimal ? '' : '?');
        var pattern = whole_dollar_amount + (options.allow_decimal || options.require_decimal ? decimal_amount : '');
        // default is negative sign before symbol, but there are two other options (besides parens)
        if (options.allow_negatives && !options.parens_for_negatives) {
            if (options.negative_sign_after_digits) {
                pattern += negative;
            }
            else if (options.negative_sign_before_digits) {
                pattern = negative + pattern;
            }
        }
        // South African Rand, for example, uses R 123 (space) and R-123 (no space)
        if (options.allow_negative_sign_placeholder) {
            pattern = "( (?!\\-))?" + pattern;
        }
        else if (options.allow_space_after_symbol) {
            pattern = " ?" + pattern;
        }
        else if (options.allow_space_after_digits) {
            pattern += '( (?!$))?';
        }
        if (options.symbol_after_digits) {
            pattern += symbol;
        }
        else {
            pattern = symbol + pattern;
        }
        if (options.allow_negatives) {
            if (options.parens_for_negatives) {
                pattern = "(\\(" + pattern + "\\)|" + pattern + ")";
            }
            else if (!(options.negative_sign_before_digits || options.negative_sign_after_digits)) {
                pattern = negative + pattern;
            }
        }
        // ensure there's a dollar and/or decimal amount, and that
        // it doesn't start with a space or a negative sign followed by a space
        return new RegExp("^(?!-? )(?=.*\\d)" + pattern + "$");
    }
    /**
     * The currency default options
     */
    var default_currency_options = {
        symbol: '$',
        require_symbol: false,
        allow_space_after_symbol: false,
        symbol_after_digits: false,
        allow_negatives: true,
        parens_for_negatives: false,
        negative_sign_before_digits: false,
        negative_sign_after_digits: false,
        allow_negative_sign_placeholder: false,
        thousands_separator: ',',
        decimal_separator: '.',
        allow_decimal: true,
        require_decimal: false,
        digits_after_decimal: [2],
        allow_space_after_digits: false,
    };
    /**
     * Checks whether the `target` string is a currency
     *
     * @param target The target string
     * @param options The options
     * @return true if the `target` is a currency, false otherwise
     */
    function isCurrency(str, options) {
        assertString(str);
        options = merge(options, default_currency_options);
        return currencyRegex(options).test(str);
    }

    var validMediaType = /^[a-z]+\/[a-z0-9\-\+]+$/i;
    var validAttribute = /^[a-z\-]+=[a-z0-9\-]+$/i;
    var validData = /^[a-z0-9!\$&'\(\)\*\+,;=\-\._~:@\/\?%\s]*$/i;
    /**
     * Checks whether the `target` string is a data URI
     *
     * @param target The target string
     * @param options The options
     * @return true if the `target` is a data URI, false otherwise
     */
    function isDataURI(target) {
        assertString(target);
        var data = target.split(',');
        if (data.length < 2) {
            return false;
        }
        var attributes = data.shift().trim().split(';');
        var schemeAndMediaType = attributes.shift();
        if (schemeAndMediaType.substr(0, 5) !== 'data:') {
            return false;
        }
        var mediaType = schemeAndMediaType.substr(5);
        if (mediaType !== '' && !validMediaType.test(mediaType)) {
            return false;
        }
        for (var i = 0; i < attributes.length; i++) {
            if (i === attributes.length - 1 && attributes[i].toLowerCase() === 'base64') {
                // ok
            }
            else if (!validAttribute.test(attributes[i])) {
                return false;
            }
        }
        for (var i = 0; i < data.length; i++) {
            if (!validData.test(data[i])) {
                return false;
            }
        }
        return true;
    }

    var includes = function (arr, val) { return arr.some(function (arrVal) { return val === arrVal; }); };

    function decimalRegExp(options) {
        var regExp = new RegExp("^[-+]?([0-9]+)?(\\" + decimal[options.locale] + "[0-9]{" + options.decimal_digits + "})" + (options.force_decimal ? '' : '?') + "$");
        return regExp;
    }
    /**
     * The default options
     */
    var default_decimal_options = {
        force_decimal: false,
        decimal_digits: '1,',
        locale: 'en-US',
    };
    var blacklist = ['', '-', '+'];
    /**
     * Checks whether the `target` string is a decimal
     *
     * @param target The target string
     * @param options The options
     * @return true if the `target` is a decimal, false otherwise
     */
    function isDecimal(target, options) {
        assertString(target);
        options = merge(options, default_decimal_options);
        if (options.locale in decimal) {
            return !includes(blacklist, target.replace(/ /g, '')) && decimalRegExp(options).test(target);
        }
        throw new Error("Invalid locale '" + options.locale + "'");
    }

    /**
     * Checks whether the `target` string is a float
     *
     * @param target The target string
     * @param options The options
     * @return true if the `target` is is a float, false otherwise
     */
    function isFloat(str, options) {
        assertString(str);
        options = options || {};
        var float = new RegExp("^(?:[-+])?(?:[0-9]+)?(?:\\" + (options.locale ? decimal[options.locale] : '.') + "[0-9]*)?(?:[eE][\\+\\-]?(?:[0-9]+))?$");
        if (str === '' || str === '.' || str === '-' || str === '+') {
            return false;
        }
        var value = parseFloat(str.replace(',', '.'));
        return float.test(str) &&
            (!options.hasOwnProperty('min') || value >= options.min) &&
            (!options.hasOwnProperty('max') || value <= options.max) &&
            (!options.hasOwnProperty('lt') || value < options.lt) &&
            (!options.hasOwnProperty('gt') || value > options.gt);
    }
    var floatLocales = Object.keys(decimal);

    function toFloat(str) {
        if (!isFloat(str))
            return NaN;
        return parseFloat(str);
    }

    /**
     * Checks whether the `target` is divisible by the arg
     *
     * @param target The target string
     * @param arg The divisor
     * @return true if the `target` is divisible by the `arg`, false otherwise
     */
    function isDivisibleBy(target, arg) {
        assertString(target);
        return toFloat(target) % parseInt(arg, 10) === 0;
    }

    /**
     * The most commonly used EAN standard is
     * the thirteen-digit EAN-13, while the
     * less commonly used 8-digit EAN-8 barcode was
     * introduced for use on small packages.
     * EAN consists of:
     * GS1 prefix, manufacturer code, product code and check digit
     * Reference: https://en.wikipedia.org/wiki/International_Article_Number
     */
    /**
     * Define EAN Lenghts; 8 for EAN-8; 13 for EAN-13
     * and Regular Expression for valid EANs (EAN-8, EAN-13),
     * with exact numberic matching of 8 or 13 digits [0-9]
     */
    var LENGTH_EAN_8 = 8;
    var validEanRegex = /^(\d{8}|\d{13})$/;
    /**
     * Get position weight given:
     * EAN length and digit index/position
     *
     * @param {number} length
     * @param {number} index
     * @return {number}
     */
    function getPositionWeightThroughLengthAndIndex(length, index) {
        if (length === LENGTH_EAN_8) {
            return (index % 2 === 0) ? 3 : 1;
        }
        return (index % 2 === 0) ? 1 : 3;
    }
    /**
     * Calculate EAN Check Digit
     * Reference: https://en.wikipedia.org/wiki/International_Article_Number#Calculation_of_checksum_digit
     *
     * @param {string} ean
     * @return {number}
     */
    function calculateCheckDigit(ean) {
        var checksum = ean
            .slice(0, -1)
            .split('')
            .map(function (char, index) { return Number(char) * getPositionWeightThroughLengthAndIndex(ean.length, index); })
            .reduce(function (acc, partialSum) { return acc + partialSum; }, 0);
        var remainder = 10 - (checksum % 10);
        return remainder < 10 ? remainder : 0;
    }
    /**
     * Check if string is valid EAN:
     * Matches EAN-8/EAN-13 regex
     * Has valid check digit.
     *
     * @param target The target string
     * @return true if the `target` is a valid EAN, false otherwise
     */
    function isEAN(target) {
        assertString(target);
        var actualCheckDigit = Number(target.slice(-1));
        return validEanRegex.test(target) && actualCheckDigit === calculateCheckDigit(target);
    }

    var default_fqdn_options = {
        require_tld: true,
        allow_underscores: false,
        allow_trailing_dot: false,
    };
    /**
     * Checks whether the `target` string is a FQDN
     *
     * @param target The target string
     * @param options The options
     * @return true if the `target` is a FQDN, false otherwise
     */
    function isFQDN(str, options) {
        assertString(str);
        options = merge(options, default_fqdn_options);
        /* Remove the optional trailing dot before checking validity */
        if (options.allow_trailing_dot && str[str.length - 1] === '.') {
            str = str.substring(0, str.length - 1);
        }
        var parts = str.split('.');
        for (var i = 0; i < parts.length; i++) {
            if (parts[i].length > 63) {
                return false;
            }
        }
        if (options.require_tld) {
            var tld = parts.pop();
            if (!parts.length || !/^([a-z\u00a1-\uffff]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {
                return false;
            }
            // disallow spaces
            if (/[\s\u2002-\u200B\u202F\u205F\u3000\uFEFF\uDB40\uDC20]/.test(tld)) {
                return false;
            }
        }
        for (var part = void 0, i = 0; i < parts.length; i++) {
            part = parts[i];
            if (options.allow_underscores) {
                part = part.replace(/_/g, '');
            }
            if (!/^[a-z\u00a1-\uffff0-9-]+$/i.test(part)) {
                return false;
            }
            // disallow full-width chars
            if (/[\uff01-\uff5e]/.test(part)) {
                return false;
            }
            if (part[0] === '-' || part[part.length - 1] === '-') {
                return false;
            }
        }
        return true;
    }

    /**
    11.3.  Examples

       The following addresses

                 fe80::1234 (on the 1st link of the node)
                 ff02::5678 (on the 5th link of the node)
                 ff08::9abc (on the 10th organization of the node)

       would be represented as follows:

                 fe80::1234%1
                 ff02::5678%5
                 ff08::9abc%10

       (Here we assume a natural translation from a zone index to the
       <zone_id> part, where the Nth zone of any scope is translated into
       "N".)

       If we use interface names as <zone_id>, those addresses could also be
       represented as follows:

                fe80::1234%ne0
                ff02::5678%pvc1.3
                ff08::9abc%interface10

       where the interface "ne0" belongs to the 1st link, "pvc1.3" belongs
       to the 5th link, and "interface10" belongs to the 10th organization.
     * * */
    var ipv4Maybe = /^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$/;
    var ipv6Block = /^[0-9A-F]{1,4}$/i;
    /**
     * Checks whether the `target` string is an int
     *
     * @param target The target string
     * @param version The version
     * @return true if the `target` is an int, false otherwise
     */
    function isIP(str, version) {
        if (version === void 0) { version = '4'; }
        assertString(str);
        version = String(version);
        if (!version) {
            return isIP(str, '4') || isIP(str, '6');
        }
        else if (version === '4') {
            if (!ipv4Maybe.test(str)) {
                return false;
            }
            var parts = str.split('.').sort(function (a, b) { return a - b; });
            return parseInt(parts[3]) <= 255;
        }
        else if (version === '6') {
            var addressAndZone = [str];
            // ipv6 addresses could have scoped architecture
            // according to https://tools.ietf.org/html/rfc4007#section-11
            if (str.includes('%')) {
                addressAndZone = str.split('%');
                if (addressAndZone.length !== 2) {
                    // it must be just two parts
                    return false;
                }
                if (!addressAndZone[0].includes(':')) {
                    // the first part must be the address
                    return false;
                }
                if (addressAndZone[1] === '') {
                    // the second part must not be empty
                    return false;
                }
            }
            var blocks = addressAndZone[0].split(':');
            var foundOmissionBlock = false; // marker to indicate ::
            // At least some OS accept the last 32 bits of an IPv6 address
            // (i.e. 2 of the blocks) in IPv4 notation, and RFC 3493 says
            // that '::ffff:a.b.c.d' is valid for IPv4-mapped IPv6 addresses,
            // and '::a.b.c.d' is deprecated, but also valid.
            var foundIPv4TransitionBlock = isIP(blocks[blocks.length - 1], '4');
            var expectedNumberOfBlocks = foundIPv4TransitionBlock ? 7 : 8;
            if (blocks.length > expectedNumberOfBlocks) {
                return false;
            }
            // initial or final ::
            if (str === '::') {
                return true;
            }
            else if (str.substr(0, 2) === '::') {
                blocks.shift();
                blocks.shift();
                foundOmissionBlock = true;
            }
            else if (str.substr(str.length - 2) === '::') {
                blocks.pop();
                blocks.pop();
                foundOmissionBlock = true;
            }
            for (var i = 0; i < blocks.length; ++i) {
                // test for a :: which can not be at the string start/end
                // since those cases have been handled above
                if (blocks[i] === '' && i > 0 && i < blocks.length - 1) {
                    if (foundOmissionBlock) {
                        return false; // multiple :: in address
                    }
                    foundOmissionBlock = true;
                }
                else if (foundIPv4TransitionBlock && i === blocks.length - 1) {
                    // it has been checked before that the last
                    // block is a valid IPv4 address
                }
                else if (!ipv6Block.test(blocks[i])) {
                    return false;
                }
            }
            if (foundOmissionBlock) {
                return blocks.length >= 1;
            }
            return blocks.length === expectedNumberOfBlocks;
        }
        return false;
    }

    var default_email_options = {
        require_display_name: false,
        allow_display_name: false,
        allow_utf8_local_part: true,
        require_tld: true,
    };
    /* eslint-disable max-len */
    /* eslint-disable no-control-regex */
    var splitNameAddress = /^([^\x00-\x1F\x7F-\x9F\cX]+)<(.+)>$/i;
    var emailUserPart = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~]+$/i;
    var gmailUserPart = /^[a-z\d]+$/;
    var quotedEmailUser = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f]))*$/i;
    var emailUserUtf8Part = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+$/i;
    var quotedEmailUserUtf8 = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*$/i;
    var defaultMaxEmailLength = 254;
    /* eslint-enable max-len */
    /* eslint-enable no-control-regex */
    /**
     * Validate display name according to the RFC2822: https://tools.ietf.org/html/rfc2822#appendix-A.1.2
     * @param {String} display_name
     */
    function validateDisplayName(display_name) {
        var trim_quotes = display_name.match(/^"(.+)"$/i);
        var display_name_without_quotes = trim_quotes ? trim_quotes[1] : display_name;
        // display name with only spaces is not valid
        if (!display_name_without_quotes.trim()) {
            return false;
        }
        // check whether display name contains illegal character
        var contains_illegal = /[\.";<>]/.test(display_name_without_quotes);
        if (contains_illegal) {
            // if contains illegal characters,
            // must to be enclosed in double-quotes, otherwise it's not a valid display name
            if (!trim_quotes) {
                return false;
            }
            // the quotes in display name must start with character symbol \
            var all_start_with_back_slash = display_name_without_quotes.split('"').length === display_name_without_quotes.split('\\"').length;
            if (!all_start_with_back_slash) {
                return false;
            }
        }
        return true;
    }
    /**
     * Checks whether the `target` string is a valid email address
     *
     * @param target The target string
     * @param options The options
     * @return true if the `target` is a valid email address, false otherwise
     */
    function isEmail(str, options) {
        var _a;
        assertString(str);
        options = merge(options, default_email_options);
        if (options.require_display_name || options.allow_display_name) {
            var display_email = str.match(splitNameAddress);
            if (display_email) {
                var display_name = void 0;
                _a = __read(display_email, 3), display_name = _a[1], str = _a[2];
                // sometimes need to trim the last space to get the display name
                // because there may be a space between display name and email address
                // eg. myname <address@gmail.com>
                // the display name is `myname` instead of `myname `, so need to trim the last space
                if (display_name.endsWith(' ')) {
                    display_name = display_name.substr(0, display_name.length - 1);
                }
                if (!validateDisplayName(display_name)) {
                    return false;
                }
            }
            else if (options.require_display_name) {
                return false;
            }
        }
        if (!options.ignore_max_length && str.length > defaultMaxEmailLength) {
            return false;
        }
        var parts = str.split('@');
        var domain = parts.pop();
        var user = parts.join('@');
        var lower_domain = domain.toLowerCase();
        if (options.domain_specific_validation && (lower_domain === 'gmail.com' || lower_domain === 'googlemail.com')) {
            /*
              Previously we removed dots for gmail addresses before validating.
              This was removed because it allows `multiple..dots@gmail.com`
              to be reported as valid, but it is not.
              Gmail only normalizes single dots, removing them from here is pointless,
              should be done in normalizeEmail
            */
            user = user.toLowerCase();
            // Removing sub-address from username before gmail validation
            var username = user.split('+')[0];
            // Dots are not included in gmail length restriction
            if (!isByteLength(username.replace('.', ''), { min: 6, max: 30 })) {
                return false;
            }
            var user_parts_1 = username.split('.');
            for (var i = 0; i < user_parts_1.length; i++) {
                if (!gmailUserPart.test(user_parts_1[i])) {
                    return false;
                }
            }
        }
        if (!isByteLength(user, { max: 64 }) ||
            !isByteLength(domain, { max: 254 })) {
            return false;
        }
        if (!isFQDN(domain, { require_tld: options.require_tld })) {
            if (!options.allow_ip_domain) {
                return false;
            }
            if (!isIP(domain)) {
                if (!domain.startsWith('[') || !domain.endsWith(']')) {
                    return false;
                }
                var noBracketdomain = domain.substr(1, domain.length - 2);
                if (noBracketdomain.length === 0 || !isIP(noBracketdomain)) {
                    return false;
                }
            }
        }
        if (user[0] === '"') {
            user = user.slice(1, user.length - 1);
            return options.allow_utf8_local_part ?
                quotedEmailUserUtf8.test(user) :
                quotedEmailUser.test(user);
        }
        var pattern = options.allow_utf8_local_part ?
            emailUserUtf8Part : emailUserPart;
        var user_parts = user.split('.');
        for (var i = 0; i < user_parts.length; i++) {
            if (!pattern.test(user_parts[i])) {
                return false;
            }
        }
        return true;
    }

    var default_is_empty_options = {
        ignore_whitespace: false,
    };
    /**
     * Checks whether the `target` string is empty
     *
     * Note that `ignore_whitespace` is false by default.
     *
     * @param target The target string
     * @param options The options
     * @return true if the `target` is empty
     */
    function isEmpty(str, options) {
        assertString(str);
        options = merge(options, default_is_empty_options);
        return (options.ignore_whitespace ? str.trim().length : str.length) === 0;
    }

    var eth = /^(0x)[0-9a-f]{40}$/i;
    /**
     * Checks whether the `target` is an ethereum address
     *
     * @param target The target string
     * @return true if the `target` is an ethereum address
     */
    function isEthereumAddress(str) {
        assertString(str);
        return eth.test(str);
    }

    var fullWidth = /[^\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;
    /**
     * Checks whether the `target` is full width
     *
     * @param target The target string
     * @return true if the `target` is full width, false otherwise
     */
    function isFullWidth(str) {
        assertString(str);
        return fullWidth.test(str);
    }

    var halfWidth = /[\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;
    /**
     * Checks whether the `target` is half width
     *
     * @param target The target string
     * @return true if the `target` is half width, false otherwise
     */
    function isHalfWidth(str) {
        assertString(str);
        return halfWidth.test(str);
    }

    var lengths = {
        md5: 32,
        md4: 32,
        sha1: 40,
        sha256: 64,
        sha384: 96,
        sha512: 128,
        ripemd128: 32,
        ripemd160: 40,
        tiger128: 32,
        tiger160: 40,
        tiger192: 48,
        crc32: 8,
        crc32b: 8,
    };
    /**
     * Checks whether the `target` string is hashed using the `arg` algorithm
     *
     * @param target The target string
     * @param arg The arg
     * @return true if the `target` is hashed using the `arg` algorithm, false otherwise
     */
    function isHash(target, arg) {
        assertString(target);
        var hash = new RegExp("^[a-fA-F0-9]{" + lengths[arg] + "}$");
        return hash.test(target);
    }

    var hexadecimal = /^(0x|0h)?[0-9A-F]+$/i;
    /**
     * Checks whether the `target` is hexadecimal
     *
     * @param target The target string
     * @return true if the `target` is hexadecimal, false otherwise
     */
    function isHexadecimal(str) {
        assertString(str);
        return hexadecimal.test(str);
    }

    var hexcolor = /^#?([0-9A-F]{3}|[0-9A-F]{4}|[0-9A-F]{6}|[0-9A-F]{8})$/i;
    /**
     * Checks whether the `target` is hexcolor
     *
     * @param target The target string
     * @return true if the `target` is hexcolor, false otherwise
     */
    function isHexColor(str) {
        assertString(str);
        return hexcolor.test(str);
    }

    var hslcomma = /^(hsl)a?\(\s*((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?))(deg|grad|rad|turn|\s*)(\s*,\s*(\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%){2}\s*(,\s*((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%?)\s*)?\)$/i;
    var hslspace = /^(hsl)a?\(\s*((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?))(deg|grad|rad|turn|\s)(\s*(\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%){2}\s*(\/\s*((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%?)\s*)?\)$/i;
    /**
     * Checks whether the `target` is HSL color
     *
     * @param target The target string
     * @return true if the `target` is HSL color, false otherwise
     */
    function isHSL(str) {
        assertString(str);
        return hslcomma.test(str) || hslspace.test(str);
    }

    /**
     * List of country codes with
     * corresponding IBAN regular expression
     * Reference: https://en.wikipedia.org/wiki/International_Bank_Account_Number
     */
    var ibanRegexThroughCountryCode = {
        AD: /^(AD[0-9]{2})\d{8}[A-Z0-9]{12}$/,
        AE: /^(AE[0-9]{2})\d{3}\d{16}$/,
        AL: /^(AL[0-9]{2})\d{8}[A-Z0-9]{16}$/,
        AT: /^(AT[0-9]{2})\d{16}$/,
        AZ: /^(AZ[0-9]{2})[A-Z0-9]{4}\d{20}$/,
        BA: /^(BA[0-9]{2})\d{16}$/,
        BE: /^(BE[0-9]{2})\d{12}$/,
        BG: /^(BG[0-9]{2})[A-Z]{4}\d{6}[A-Z0-9]{8}$/,
        BH: /^(BH[0-9]{2})[A-Z]{4}[A-Z0-9]{14}$/,
        BR: /^(BR[0-9]{2})\d{23}[A-Z]{1}[A-Z0-9]{1}$/,
        BY: /^(BY[0-9]{2})[A-Z0-9]{4}\d{20}$/,
        CH: /^(CH[0-9]{2})\d{5}[A-Z0-9]{12}$/,
        CR: /^(CR[0-9]{2})\d{18}$/,
        CY: /^(CY[0-9]{2})\d{8}[A-Z0-9]{16}$/,
        CZ: /^(CZ[0-9]{2})\d{20}$/,
        DE: /^(DE[0-9]{2})\d{18}$/,
        DK: /^(DK[0-9]{2})\d{14}$/,
        DO: /^(DO[0-9]{2})[A-Z]{4}\d{20}$/,
        EE: /^(EE[0-9]{2})\d{16}$/,
        ES: /^(ES[0-9]{2})\d{20}$/,
        FI: /^(FI[0-9]{2})\d{14}$/,
        FO: /^(FO[0-9]{2})\d{14}$/,
        FR: /^(FR[0-9]{2})\d{10}[A-Z0-9]{11}\d{2}$/,
        GB: /^(GB[0-9]{2})[A-Z]{4}\d{14}$/,
        GE: /^(GE[0-9]{2})[A-Z0-9]{2}\d{16}$/,
        GI: /^(GI[0-9]{2})[A-Z]{4}[A-Z0-9]{15}$/,
        GL: /^(GL[0-9]{2})\d{14}$/,
        GR: /^(GR[0-9]{2})\d{7}[A-Z0-9]{16}$/,
        GT: /^(GT[0-9]{2})[A-Z0-9]{4}[A-Z0-9]{20}$/,
        HR: /^(HR[0-9]{2})\d{17}$/,
        HU: /^(HU[0-9]{2})\d{24}$/,
        IE: /^(IE[0-9]{2})[A-Z0-9]{4}\d{14}$/,
        IL: /^(IL[0-9]{2})\d{19}$/,
        IQ: /^(IQ[0-9]{2})[A-Z]{4}\d{15}$/,
        IS: /^(IS[0-9]{2})\d{22}$/,
        IT: /^(IT[0-9]{2})[A-Z]{1}\d{10}[A-Z0-9]{12}$/,
        JO: /^(JO[0-9]{2})[A-Z]{4}\d{22}$/,
        KW: /^(KW[0-9]{2})[A-Z]{4}[A-Z0-9]{22}$/,
        KZ: /^(KZ[0-9]{2})\d{3}[A-Z0-9]{13}$/,
        LB: /^(LB[0-9]{2})\d{4}[A-Z0-9]{20}$/,
        LC: /^(LC[0-9]{2})[A-Z]{4}[A-Z0-9]{24}$/,
        LI: /^(LI[0-9]{2})\d{5}[A-Z0-9]{12}$/,
        LT: /^(LT[0-9]{2})\d{16}$/,
        LU: /^(LU[0-9]{2})\d{3}[A-Z0-9]{13}$/,
        LV: /^(LV[0-9]{2})[A-Z]{4}[A-Z0-9]{13}$/,
        MC: /^(MC[0-9]{2})\d{10}[A-Z0-9]{11}\d{2}$/,
        MD: /^(MD[0-9]{2})[A-Z0-9]{20}$/,
        ME: /^(ME[0-9]{2})\d{18}$/,
        MK: /^(MK[0-9]{2})\d{3}[A-Z0-9]{10}\d{2}$/,
        MR: /^(MR[0-9]{2})\d{23}$/,
        MT: /^(MT[0-9]{2})[A-Z]{4}\d{5}[A-Z0-9]{18}$/,
        MU: /^(MU[0-9]{2})[A-Z]{4}\d{19}[A-Z]{3}$/,
        NL: /^(NL[0-9]{2})[A-Z]{4}\d{10}$/,
        NO: /^(NO[0-9]{2})\d{11}$/,
        PK: /^(PK[0-9]{2})[A-Z0-9]{4}\d{16}$/,
        PL: /^(PL[0-9]{2})\d{24}$/,
        PS: /^(PS[0-9]{2})[A-Z0-9]{4}\d{21}$/,
        PT: /^(PT[0-9]{2})\d{21}$/,
        QA: /^(QA[0-9]{2})[A-Z]{4}[A-Z0-9]{21}$/,
        RO: /^(RO[0-9]{2})[A-Z]{4}[A-Z0-9]{16}$/,
        RS: /^(RS[0-9]{2})\d{18}$/,
        SA: /^(SA[0-9]{2})\d{2}[A-Z0-9]{18}$/,
        SC: /^(SC[0-9]{2})[A-Z]{4}\d{20}[A-Z]{3}$/,
        SE: /^(SE[0-9]{2})\d{20}$/,
        SI: /^(SI[0-9]{2})\d{15}$/,
        SK: /^(SK[0-9]{2})\d{20}$/,
        SM: /^(SM[0-9]{2})[A-Z]{1}\d{10}[A-Z0-9]{12}$/,
        TL: /^(TL[0-9]{2})\d{19}$/,
        TN: /^(TN[0-9]{2})\d{20}$/,
        TR: /^(TR[0-9]{2})\d{5}[A-Z0-9]{17}$/,
        UA: /^(UA[0-9]{2})\d{6}[A-Z0-9]{19}$/,
        VA: /^(VA[0-9]{2})\d{18}$/,
        VG: /^(VG[0-9]{2})[A-Z0-9]{4}\d{16}$/,
        XK: /^(XK[0-9]{2})\d{16}$/,
    };
    /**
     * Check whether string has correct universal IBAN format
     * The IBAN consists of up to 34 alphanumeric characters, as follows:
     * Country Code using ISO 3166-1 alpha-2, two letters
     * check digits, two digits and
     * Basic Bank Account Number (BBAN), up to 30 alphanumeric characters.
     * NOTE: Permitted IBAN characters are: digits [0-9] and the 26 latin alphabetic [A-Z]
     *
     * @param {string} str - string under validation
     * @return {boolean}
     */
    function hasValidIbanFormat(str) {
        // Strip white spaces and hyphens, keep only digits and A-Z latin alphabetic
        var strippedStr = str.replace(/[^A-Z0-9]+/gi, '').toUpperCase();
        var isoCountryCode = strippedStr.slice(0, 2).toUpperCase();
        return (isoCountryCode in ibanRegexThroughCountryCode) &&
            ibanRegexThroughCountryCode[isoCountryCode].test(strippedStr);
    }
    /**
       * Check whether string has valid IBAN Checksum
       * by performing basic mod-97 operation and
       * the remainder should equal 1
       * -- Start by rearranging the IBAN by moving the four initial characters to the end of the string
       * -- Replace each letter in the string with two digits, A -> 10, B = 11, Z = 35
       * -- Interpret the string as a decimal integer and
       * -- compute the remainder on division by 97 (mod 97)
       * Reference: https://en.wikipedia.org/wiki/International_Bank_Account_Number
       *
       * @param target The target string
       * @return true if the string has a valid IBAN checksum, false otherwise
       */
    function hasValidIbanChecksum(target) {
        var strippedStr = target.replace(/[^A-Z0-9]+/gi, '').toUpperCase(); // Keep only digits and A-Z latin alphabetic
        var rearranged = strippedStr.slice(4) + strippedStr.slice(0, 4);
        var alphaCapsReplacedWithDigits = rearranged.replace(/[A-Z]/g, function (char) { return char.charCodeAt(0) - 55; });
        var remainder = alphaCapsReplacedWithDigits.match(/\d{1,7}/g)
            .reduce(function (acc, value) { return Number(acc + value) % 97; }, '');
        return remainder === 1;
    }
    /**
     * Checks whether the IBAN number has a valid format and checksum.
     *
     * @param target The target string
     * @return true if the target has a valid format and checksum, false otherwise
     */
    function isIBAN(target) {
        assertString(target);
        return hasValidIbanFormat(target) && hasValidIbanChecksum(target);
    }

    var ɵ0 = function (str) {
        assertString(str);
        var DNI = /^[0-9X-Z][0-9]{7}[TRWAGMYFPDXBNJZSQVHLCKE]$/;
        var charsValue = {
            X: 0,
            Y: 1,
            Z: 2,
        };
        var controlDigits = [
            'T', 'R', 'W', 'A', 'G', 'M', 'Y', 'F', 'P', 'D', 'X', 'B',
            'N', 'J', 'Z', 'S', 'Q', 'V', 'H', 'L', 'C', 'K', 'E',
        ];
        // sanitize user input
        var sanitized = str.trim().toUpperCase();
        // validate the data structure
        if (!DNI.test(sanitized)) {
            return false;
        }
        // validate the control digit
        var number = sanitized.slice(0, -1).replace(/[X,Y,Z]/g, function (char) { return charsValue[char]; });
        return sanitized.endsWith(controlDigits[number % 23]);
    }, ɵ1 = function (str) {
        var DNI = /^\d{9}$/;
        // sanitize user input
        var sanitized = str.trim();
        // validate the data structure
        if (!DNI.test(sanitized)) {
            return false;
        }
        var id = sanitized;
        var sum = 0, incNum;
        for (var i = 0; i < id.length; i++) {
            incNum = Number(id[i]) * ((i % 2) + 1); // Multiply number by 1 or 2
            sum += incNum > 9 ? incNum - 9 : incNum; // Sum the digits up and add to total
        }
        return sum % 10 === 0;
    }, ɵ2 = function (str) {
        var ALPHABET_CODES = {
            A: 10,
            B: 11,
            C: 12,
            D: 13,
            E: 14,
            F: 15,
            G: 16,
            H: 17,
            I: 34,
            J: 18,
            K: 19,
            L: 20,
            M: 21,
            N: 22,
            O: 35,
            P: 23,
            Q: 24,
            R: 25,
            S: 26,
            T: 27,
            U: 28,
            V: 29,
            W: 32,
            X: 30,
            Y: 31,
            Z: 33,
        };
        var sanitized = str.trim().toUpperCase();
        if (!/^[A-Z][0-9]{9}$/.test(sanitized))
            return false;
        return Array.from(sanitized).reduce(function (sum, num, index) {
            if (index === 0) {
                var code = ALPHABET_CODES[num];
                return ((code % 10) * 9) + Math.floor(code / 10);
            }
            if (index === 9) {
                return ((10 - (sum % 10)) - Number(num)) % 10 === 0;
            }
            return sum + (Number(num) * (9 - index));
        }, 0);
    };
    var validators = {
        ES: ɵ0,
        'he-IL': ɵ1,
        'zh-TW': ɵ2,
    };
    /**
     * Check if the string is an identity card
     * @param target The target string
     * @param arg The arg
     */
    function isIdentityCard(target, arg) {
        assertString(target);
        if (arg in validators) {
            return validators[arg](target);
        }
        else if (arg === 'any') {
            for (var key in validators) {
                // https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md#ignoring-code-for-coverage-purposes
                // istanbul ignore else
                if (validators.hasOwnProperty(key)) {
                    var validator = validators[key];
                    if (validator(target)) {
                        return true;
                    }
                }
            }
            return false;
        }
        throw new Error("Invalid locale '" + arg + "'");
    }

    /**
     * Checks whether the `target` string is in the array of allowed values
     *
     * @param target The target string
     * @param options The options
     * @return true if the `target` is in the array of allowed values, false otherwise
     */
    function isIn(str, options) {
        assertString(str);
        var i;
        if (Object.prototype.toString.call(options) === '[object Array]') {
            var array = [];
            for (i in options) {
                // https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md#ignoring-code-for-coverage-purposes
                // istanbul ignore else
                if ({}.hasOwnProperty.call(options, i)) {
                    array[i] = toString(options[i]);
                }
            }
            return array.indexOf(str) >= 0;
        }
        else if (typeof options === 'object') {
            return options.hasOwnProperty(str);
        }
        else if (options && typeof options.indexOf === 'function') {
            return options.indexOf(str) >= 0;
        }
        return false;
    }

    var int = /^(?:[-+]?(?:0|[1-9][0-9]*))$/;
    var intLeadingZeroes = /^[-+]?[0-9]+$/;
    /**
     * Checks whether the `target` string is an int
     *
     * @param target The target string
     * @param options The options
     * @return true if the `target` is an int, false otherwise
     */
    function isInt(str, options) {
        assertString(str);
        options = options || {};
        // Get the regex to use for testing, based on whether
        // leading zeroes are allowed or not.
        var regex = (options.hasOwnProperty('allow_leading_zeroes') && !options.allow_leading_zeroes ?
            int : intLeadingZeroes);
        // Check min/max/lt/gt
        var minCheckPassed = (!options.hasOwnProperty('min') || str >= options.min);
        var maxCheckPassed = (!options.hasOwnProperty('max') || str <= options.max);
        var ltCheckPassed = (!options.hasOwnProperty('lt') || str < options.lt);
        var gtCheckPassed = (!options.hasOwnProperty('gt') || str > options.gt);
        return regex.test(str) && minCheckPassed && maxCheckPassed && ltCheckPassed && gtCheckPassed;
    }

    var isbn10Maybe = /^(?:[0-9]{9}X|[0-9]{10})$/;
    var isbn13Maybe = /^(?:[0-9]{13})$/;
    var factor = [1, 3];
    /**
     * Test whether the target string is an ISBN number.
     *
     * @param target The string
     * @param arg The ISBN version
     * @return true if the `target` string is an ISBN number, false otherwise
     */
    function isISBN(target, arg) {
        if (arg === void 0) { arg = ''; }
        assertString(target);
        arg = String(arg);
        if (!arg) {
            return isISBN(target, '10') || isISBN(target, '13');
        }
        var sanitized = target.replace(/[\s-]+/g, '');
        var checksum = 0;
        var i;
        if (arg === '10') {
            if (!isbn10Maybe.test(sanitized)) {
                return false;
            }
            for (i = 0; i < 9; i++) {
                checksum += (i + 1) * parseInt(sanitized.charAt(i));
            }
            if (sanitized.charAt(9) === 'X') {
                checksum += 10 * 10;
            }
            else {
                checksum += 10 * parseInt(sanitized.charAt(9));
            }
            if ((checksum % 11) === 0) {
                return !!sanitized;
            }
        }
        else if (arg === '13') {
            if (!isbn13Maybe.test(sanitized)) {
                return false;
            }
            for (i = 0; i < 12; i++) {
                checksum += factor[i % 2] * parseInt(sanitized.charAt(i));
            }
            if (parseInt(sanitized.charAt(12)) - ((10 - (checksum % 10)) % 10) === 0) {
                return !!sanitized;
            }
        }
        return false;
    }

    var isin = /^[A-Z]{2}[0-9A-Z]{9}[0-9]$/;
    /**
     * Test whether the target string is an ISBN number.
     *
     * @param target The string
     * @return true if the `target` string is an ISIN number, false otherwise
     */
    function isISIN(target) {
        assertString(target);
        if (!isin.test(target)) {
            return false;
        }
        var checksumStr = target.replace(/[A-Z]/g, function (character) {
            var intValue = (parseInt(character, 36));
            return intValue ? intValue.toString() : '';
        });
        var sum = 0;
        var digit;
        var tmpNum;
        var shouldDouble = true;
        for (var i = checksumStr.length - 2; i >= 0; i--) {
            digit = checksumStr.substring(i, (i + 1));
            tmpNum = parseInt(digit, 10);
            if (shouldDouble) {
                tmpNum *= 2;
                if (tmpNum >= 10) {
                    sum += tmpNum + 1;
                }
                else {
                    sum += tmpNum;
                }
            }
            else {
                sum += tmpNum;
            }
            shouldDouble = !shouldDouble;
        }
        return parseInt(target.substr(target.length - 1), 10) === (10000 - sum) % 10;
    }

    /* eslint-disable max-len */
    // from http://goo.gl/0ejHHW
    var iso8601 = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
    /* eslint-enable max-len */
    var isValidDate = function (str) {
        // str must have passed the ISO8601 check
        // this check is meant to catch invalid dates
        // like 2009-02-31
        // first check for ordinal dates
        var ordinalMatch = str.match(/^(\d{4})-?(\d{3})([ T]{1}\.*|$)/);
        if (ordinalMatch) {
            var oYear = Number(ordinalMatch[1]);
            var oDay = Number(ordinalMatch[2]);
            // if is leap year
            if ((oYear % 4 === 0 && oYear % 100 !== 0) || oYear % 400 === 0)
                return oDay <= 366;
            return oDay <= 365;
        }
        var match = str.match(/(\d{4})-?(\d{0,2})-?(\d*)/).map(Number);
        var year = match[1];
        var month = match[2];
        var day = match[3];
        var monthString = month ? ("0" + month).slice(-2) : month;
        var dayString = day ? ("0" + day).slice(-2) : day;
        // create a date object and compare
        var d = new Date(year + "-" + (monthString || '01') + "-" + (dayString || '01'));
        if (month && day) {
            return d.getUTCFullYear() === year
                && (d.getUTCMonth() + 1) === month
                && d.getUTCDate() === day;
        }
        return true;
    };
    var ɵ0$1 = isValidDate;
    /**
     * Checks whether the `target` string is a valid ISO8601 date
     *
     * @param target The target string
     * @param options The options
     * @return true if the `target` is a valid ISO8601 date, false otherwise
     */
    function isISO8601(str, options) {
        assertString(str);
        var check = iso8601.test(str);
        if (!options)
            return check;
        if (check && options.strict)
            return isValidDate(str);
        return check;
    }

    // from https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2
    var validISO31661Alpha2CountriesCodes = [
        'AD', 'AE', 'AF', 'AG', 'AI', 'AL', 'AM', 'AO', 'AQ', 'AR', 'AS', 'AT', 'AU', 'AW', 'AX', 'AZ',
        'BA', 'BB', 'BD', 'BE', 'BF', 'BG', 'BH', 'BI', 'BJ', 'BL', 'BM', 'BN', 'BO', 'BQ', 'BR', 'BS', 'BT', 'BV', 'BW', 'BY', 'BZ',
        'CA', 'CC', 'CD', 'CF', 'CG', 'CH', 'CI', 'CK', 'CL', 'CM', 'CN', 'CO', 'CR', 'CU', 'CV', 'CW', 'CX', 'CY', 'CZ',
        'DE', 'DJ', 'DK', 'DM', 'DO', 'DZ',
        'EC', 'EE', 'EG', 'EH', 'ER', 'ES', 'ET',
        'FI', 'FJ', 'FK', 'FM', 'FO', 'FR',
        'GA', 'GB', 'GD', 'GE', 'GF', 'GG', 'GH', 'GI', 'GL', 'GM', 'GN', 'GP', 'GQ', 'GR', 'GS', 'GT', 'GU', 'GW', 'GY',
        'HK', 'HM', 'HN', 'HR', 'HT', 'HU',
        'ID', 'IE', 'IL', 'IM', 'IN', 'IO', 'IQ', 'IR', 'IS', 'IT',
        'JE', 'JM', 'JO', 'JP',
        'KE', 'KG', 'KH', 'KI', 'KM', 'KN', 'KP', 'KR', 'KW', 'KY', 'KZ',
        'LA', 'LB', 'LC', 'LI', 'LK', 'LR', 'LS', 'LT', 'LU', 'LV', 'LY',
        'MA', 'MC', 'MD', 'ME', 'MF', 'MG', 'MH', 'MK', 'ML', 'MM', 'MN', 'MO', 'MP', 'MQ', 'MR', 'MS', 'MT', 'MU', 'MV', 'MW', 'MX', 'MY', 'MZ',
        'NA', 'NC', 'NE', 'NF', 'NG', 'NI', 'NL', 'NO', 'NP', 'NR', 'NU', 'NZ',
        'OM',
        'PA', 'PE', 'PF', 'PG', 'PH', 'PK', 'PL', 'PM', 'PN', 'PR', 'PS', 'PT', 'PW', 'PY',
        'QA',
        'RE', 'RO', 'RS', 'RU', 'RW',
        'SA', 'SB', 'SC', 'SD', 'SE', 'SG', 'SH', 'SI', 'SJ', 'SK', 'SL', 'SM', 'SN', 'SO', 'SR', 'SS', 'ST', 'SV', 'SX', 'SY', 'SZ',
        'TC', 'TD', 'TF', 'TG', 'TH', 'TJ', 'TK', 'TL', 'TM', 'TN', 'TO', 'TR', 'TT', 'TV', 'TW', 'TZ',
        'UA', 'UG', 'UM', 'US', 'UY', 'UZ',
        'VA', 'VC', 'VE', 'VG', 'VI', 'VN', 'VU',
        'WF', 'WS',
        'YE', 'YT',
        'ZA', 'ZM', 'ZW',
    ];
    /**
     * Check whether the `target` string is a valid
     * ISO 3166-1 alpha-2 officially assigned country code
     *
     * @param target The target string
     * @return true if the `target` is a valid is a valid ISO 3166-1 alpha-2 officially assigned country code, false otherwise
     */
    function isISO31661Alpha2(target) {
        assertString(target);
        return includes(validISO31661Alpha2CountriesCodes, target.toUpperCase());
    }

    // from https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3
    var validISO31661Alpha3CountriesCodes = [
        'AFG', 'ALA', 'ALB', 'DZA', 'ASM', 'AND', 'AGO', 'AIA', 'ATA', 'ATG', 'ARG', 'ARM', 'ABW', 'AUS', 'AUT', 'AZE',
        'BHS', 'BHR', 'BGD', 'BRB', 'BLR', 'BEL', 'BLZ', 'BEN', 'BMU', 'BTN', 'BOL', 'BES', 'BIH', 'BWA', 'BVT', 'BRA',
        'IOT', 'BRN', 'BGR', 'BFA', 'BDI', 'KHM', 'CMR', 'CAN', 'CPV', 'CYM', 'CAF', 'TCD', 'CHL', 'CHN', 'CXR', 'CCK',
        'COL', 'COM', 'COG', 'COD', 'COK', 'CRI', 'CIV', 'HRV', 'CUB', 'CUW', 'CYP', 'CZE', 'DNK', 'DJI', 'DMA', 'DOM',
        'ECU', 'EGY', 'SLV', 'GNQ', 'ERI', 'EST', 'ETH', 'FLK', 'FRO', 'FJI', 'FIN', 'FRA', 'GUF', 'PYF', 'ATF', 'GAB',
        'GMB', 'GEO', 'DEU', 'GHA', 'GIB', 'GRC', 'GRL', 'GRD', 'GLP', 'GUM', 'GTM', 'GGY', 'GIN', 'GNB', 'GUY', 'HTI',
        'HMD', 'VAT', 'HND', 'HKG', 'HUN', 'ISL', 'IND', 'IDN', 'IRN', 'IRQ', 'IRL', 'IMN', 'ISR', 'ITA', 'JAM', 'JPN',
        'JEY', 'JOR', 'KAZ', 'KEN', 'KIR', 'PRK', 'KOR', 'KWT', 'KGZ', 'LAO', 'LVA', 'LBN', 'LSO', 'LBR', 'LBY', 'LIE',
        'LTU', 'LUX', 'MAC', 'MKD', 'MDG', 'MWI', 'MYS', 'MDV', 'MLI', 'MLT', 'MHL', 'MTQ', 'MRT', 'MUS', 'MYT', 'MEX',
        'FSM', 'MDA', 'MCO', 'MNG', 'MNE', 'MSR', 'MAR', 'MOZ', 'MMR', 'NAM', 'NRU', 'NPL', 'NLD', 'NCL', 'NZL', 'NIC',
        'NER', 'NGA', 'NIU', 'NFK', 'MNP', 'NOR', 'OMN', 'PAK', 'PLW', 'PSE', 'PAN', 'PNG', 'PRY', 'PER', 'PHL', 'PCN',
        'POL', 'PRT', 'PRI', 'QAT', 'REU', 'ROU', 'RUS', 'RWA', 'BLM', 'SHN', 'KNA', 'LCA', 'MAF', 'SPM', 'VCT', 'WSM',
        'SMR', 'STP', 'SAU', 'SEN', 'SRB', 'SYC', 'SLE', 'SGP', 'SXM', 'SVK', 'SVN', 'SLB', 'SOM', 'ZAF', 'SGS', 'SSD',
        'ESP', 'LKA', 'SDN', 'SUR', 'SJM', 'SWZ', 'SWE', 'CHE', 'SYR', 'TWN', 'TJK', 'TZA', 'THA', 'TLS', 'TGO', 'TKL',
        'TON', 'TTO', 'TUN', 'TUR', 'TKM', 'TCA', 'TUV', 'UGA', 'UKR', 'ARE', 'GBR', 'USA', 'UMI', 'URY', 'UZB', 'VUT',
        'VEN', 'VNM', 'VGB', 'VIR', 'WLF', 'ESH', 'YEM', 'ZMB', 'ZWE',
    ];
    /**
     * Check whether the `target` string is a valid
     * ISO 3166-1 alpha-3 officially assigned country code
     *
     * @param target The target string
     * @return true if the `target` is a valid is a valid ISO 3166-1 alpha-2 officially assigned country code, false otherwise
     */
    function isISO31661Alpha3(target) {
        assertString(target);
        return includes(validISO31661Alpha3CountriesCodes, target.toUpperCase());
    }

    // see http://isrc.ifpi.org/en/isrc-standard/code-syntax
    var isrc = /^[A-Z]{2}[0-9A-Z]{3}\d{2}\d{5}$/;
    /**
     * Checks whether the `target` string is a valid ISRC
     *
     * @param target The target string
     * @return true if the `target` is a valid ISRC, false otherwise
     */
    function isISRC(target) {
        assertString(target);
        return isrc.test(target);
    }

    var issn = '^\\d{4}-?\\d{3}[\\dX]$';
    /**
     * Checks whether the `target` string is a valid ISSN
     *
     * @param target The target string
     * @param options The options
     * @return true if the `target` is a valid ISSN, false otherwise
     */
    function isISSN(str, options) {
        if (options === void 0) { options = {}; }
        assertString(str);
        var testIssn = issn;
        testIssn = options.require_hyphen ? testIssn.replace('?', '') : testIssn;
        testIssn = options.case_sensitive ? new RegExp(testIssn) : new RegExp(testIssn, 'i');
        if (!testIssn.test(str)) {
            return false;
        }
        var digits = str.replace('-', '').toUpperCase();
        var checksum = 0;
        for (var i = 0; i < digits.length; i++) {
            var digit = digits[i];
            checksum += (digit === 'X' ? 10 : +digit) * (8 - i);
        }
        return checksum % 11 === 0;
    }

    /**
     * Checks whether the `target` string is valid JSON
     *
     * @param target The target string
     * @return true if the `target` is a valid ISSN, false otherwise
     */
    function isJSON(target) {
        assertString(target);
        try {
            var obj = JSON.parse(target);
            return !!obj && typeof obj === 'object';
        }
        catch (e) { /* ignore */ }
        return false;
    }

    var jwt = /^([A-Za-z0-9\-_~+\/]+[=]{0,2})\.([A-Za-z0-9\-_~+\/]+[=]{0,2})(?:\.([A-Za-z0-9\-_~+\/]+[=]{0,2}))?$/;
    /**
     * Checks whether the `target` string is a valid JWT
     *
     * @param target The target string
     * @return true if the `target` is a valid JWT, false otherwise
     */
    function isJWT(target) {
        assertString(target);
        return jwt.test(target);
    }

    var lat = /^\(?[+-]?(90(\.0+)?|[1-8]?\d(\.\d+)?)$/;
    var long = /^\s?[+-]?(180(\.0+)?|1[0-7]\d(\.\d+)?|\d{1,2}(\.\d+)?)\)?$/;
    /**
     * Checks whether the `target` string is a valid LatLong
     *
     * @param target The target string
     * @return true if the `target` is a valid LatLong, false otherwise
     */
    function isLatLong(target) {
        assertString(target);
        if (!target.includes(','))
            return false;
        var pair = target.split(',');
        if ((pair[0].startsWith('(') && !pair[1].endsWith(')'))
            || (pair[1].endsWith(')') && !pair[0].startsWith('(')))
            return false;
        return lat.test(pair[0]) && long.test(pair[1]);
    }

    /* eslint-disable prefer-rest-params */
    /**
     * Checks whether the `target` string length is valid
     *
     * @param target The target string
     * @param options The options
     * @return true if the `target` has a valid length, false otherwise
     */
    function isLength(target, options) {
        assertString(target);
        var min;
        var max;
        if (typeof (options) === 'object') {
            min = options.min || 0;
            max = options.max;
        }
        else { // backwards compatibility: isLength(str, min [, max])
            min = arguments[1] || 0;
            max = arguments[2];
        }
        var surrogatePairs = target.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g) || [];
        var len = target.length - surrogatePairs.length;
        return len >= min && (typeof max === 'undefined' || len <= max);
    }

    var localeReg = /^[A-z]{2,4}([_-]([A-z]{4}|[\d]{3}))?([_-]([A-z]{2}|[\d]{3}))?$/;
    /**
     * Checks whether the `target` string is a valid locale
     *
     * @param target The target string
     * @return true if the `target` is a valid locale, false otherwise
     */
    function isLocale(target) {
        assertString(target);
        if (target === 'en_US_POSIX' || target === 'ca_ES_VALENCIA') {
            return true;
        }
        return localeReg.test(target);
    }

    /**
     * Checks whether the `target` string is lowercase
     *
     * @param target The target string
     * @return true if the `target` is lowercase, false otherwise
     */
    function isLowercase(target) {
        assertString(target);
        return target === target.toLowerCase();
    }

    var macAddress = /^([0-9a-fA-F][0-9a-fA-F]:){5}([0-9a-fA-F][0-9a-fA-F])$/;
    var macAddressNoColons = /^([0-9a-fA-F]){12}$/;
    var macAddressWithHyphen = /^([0-9a-fA-F][0-9a-fA-F]-){5}([0-9a-fA-F][0-9a-fA-F])$/;
    var macAddressWithSpaces = /^([0-9a-fA-F][0-9a-fA-F]\s){5}([0-9a-fA-F][0-9a-fA-F])$/;
    /**
     * Checks whether the `target` string is a valid MAC Address
     *
     * @param target The target string
     * @param options The options
     * @return true if the `target` is a valid Mac Address, false otherwise
     */
    function isMACAddress(target, options) {
        assertString(target);
        if (options && options.no_colons) {
            return macAddressNoColons.test(target);
        }
        return macAddress.test(target) || macAddressWithHyphen.test(target) || macAddressWithSpaces.test(target);
    }

    var magnetURI = /^magnet:\?xt=urn:[a-z0-9]+:[a-z0-9]{32,40}&dn=.+&tr=.+$/i;
    /**
     * Checks whether the `target` string is a valid Magnet URI
     *
     * @param target The target string
     * @return true if the `target` is a valid Magnet URI, false otherwise
     */
    function isMagnetURI(target) {
        assertString(target);
        return magnetURI.test(target.trim());
    }

    var md5 = /^[a-f0-9]{32}$/;
    /**
     * Checks whether the `target` string is a valid MD5 checksum
     *
     * @param target The target string
     * @return true if the `target` is a valid MD5 checksum, false otherwise
     */
    function isMD5(target) {
        assertString(target);
        return md5.test(target);
    }

    /*
      Checks if the provided string matches to a correct Media type format (MIME type)

      This function only checks is the string format follows the
      etablished rules by the according RFC specifications.
      This function supports 'charset' in textual media types
      (https://tools.ietf.org/html/rfc6657).

      This function does not check against all the media types listed
      by the IANA (https://www.iana.org/assignments/media-types/media-types.xhtml)
      because of lightness purposes : it would require to include
      all these MIME types in this librairy, which would weigh it
      significantly. This kind of effort maybe is not worth for the use that
      this function has in this entire librairy.

      More informations in the RFC specifications :
      - https://tools.ietf.org/html/rfc2045
      - https://tools.ietf.org/html/rfc2046
      - https://tools.ietf.org/html/rfc7231#section-3.1.1.1
      - https://tools.ietf.org/html/rfc7231#section-3.1.1.5
    */
    // Match simple MIME types
    // NB :
    //   Subtype length must not exceed 100 characters.
    //   This rule does not comply to the RFC specs (what is the max length ?).
    var mimeTypeSimple = /^(application|audio|font|image|message|model|multipart|text|video)\/[a-zA-Z0-9\.\-\+]{1,100}$/i; // eslint-disable-line max-len
    // Handle "charset" in "text/*"
    var mimeTypeText = /^text\/[a-zA-Z0-9\.\-\+]{1,100};\s?charset=("[a-zA-Z0-9\.\-\+\s]{0,70}"|[a-zA-Z0-9\.\-\+]{0,70})(\s?\([a-zA-Z0-9\.\-\+\s]{1,20}\))?$/i; // eslint-disable-line max-len
    // Handle "boundary" in "multipart/*"
    var mimeTypeMultipart = /^multipart\/[a-zA-Z0-9\.\-\+]{1,100}(;\s?(boundary|charset)=("[a-zA-Z0-9\.\-\+\s]{0,70}"|[a-zA-Z0-9\.\-\+]{0,70})(\s?\([a-zA-Z0-9\.\-\+\s]{1,20}\))?){0,2}$/i; // eslint-disable-line max-len
    /**
     * Checks whether the `target` string is a valid Mime Type
     *
     * @param target The target string
     * @return true if the `target` is a valid Mime Type, false otherwise
     */
    function isMimeType(str) {
        assertString(str);
        return mimeTypeSimple.test(str) || mimeTypeText.test(str) || mimeTypeMultipart.test(str);
    }

    /* eslint-disable max-len */
    var phones = {
        'am-AM': /^(\+?374|0)((10|[9|7][0-9])\d{6}$|[2-4]\d{7}$)/,
        'ar-AE': /^((\+?971)|0)?5[024568]\d{7}$/,
        'ar-BH': /^(\+?973)?(3|6)\d{7}$/,
        'ar-DZ': /^(\+?213|0)(5|6|7)\d{8}$/,
        'ar-EG': /^((\+?20)|0)?1[0125]\d{8}$/,
        'ar-IQ': /^(\+?964|0)?7[0-9]\d{8}$/,
        'ar-JO': /^(\+?962|0)?7[789]\d{7}$/,
        'ar-KW': /^(\+?965)[569]\d{7}$/,
        'ar-SA': /^(!?(\+?966)|0)?5\d{8}$/,
        'ar-SY': /^(!?(\+?963)|0)?9\d{8}$/,
        'ar-TN': /^(\+?216)?[2459]\d{7}$/,
        'be-BY': /^(\+?375)?(24|25|29|33|44)\d{7}$/,
        'bg-BG': /^(\+?359|0)?8[789]\d{7}$/,
        'bn-BD': /^(\+?880|0)1[13456789][0-9]{8}$/,
        'cs-CZ': /^(\+?420)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,
        'da-DK': /^(\+?45)?\s?\d{2}\s?\d{2}\s?\d{2}\s?\d{2}$/,
        'de-DE': /^(\+49)?0?1(5[0-25-9]\d|6([23]|0\d?)|7([0-57-9]|6\d))\d{7}$/,
        'de-AT': /^(\+43|0)\d{1,4}\d{3,12}$/,
        'el-GR': /^(\+?30|0)?(69\d{8})$/,
        'en-AU': /^(\+?61|0)4\d{8}$/,
        'en-GB': /^(\+?44|0)7\d{9}$/,
        'en-GG': /^(\+?44|0)1481\d{6}$/,
        'en-GH': /^(\+233|0)(20|50|24|54|27|57|26|56|23|28)\d{7}$/,
        'en-HK': /^(\+?852[-\s]?)?[456789]\d{3}[-\s]?\d{4}$/,
        'en-MO': /^(\+?853[-\s]?)?[6]\d{3}[-\s]?\d{4}$/,
        'en-IE': /^(\+?353|0)8[356789]\d{7}$/,
        'en-IN': /^(\+?91|0)?[6789]\d{9}$/,
        'en-KE': /^(\+?254|0)(7|1)\d{8}$/,
        'en-MT': /^(\+?356|0)?(99|79|77|21|27|22|25)[0-9]{6}$/,
        'en-MU': /^(\+?230|0)?\d{8}$/,
        'en-NG': /^(\+?234|0)?[789]\d{9}$/,
        'en-NZ': /^(\+?64|0)[28]\d{7,9}$/,
        'en-PK': /^((\+92)|(0092))-{0,1}\d{3}-{0,1}\d{7}$|^\d{11}$|^\d{4}-\d{7}$/,
        'en-RW': /^(\+?250|0)?[7]\d{8}$/,
        'en-SG': /^(\+65)?[89]\d{7}$/,
        'en-TZ': /^(\+?255|0)?[67]\d{8}$/,
        'en-UG': /^(\+?256|0)?[7]\d{8}$/,
        'en-US': /^((\+1|1)?( |-)?)?(\([2-9][0-9]{2}\)|[2-9][0-9]{2})( |-)?([2-9][0-9]{2}( |-)?[0-9]{4})$/,
        'en-ZA': /^(\+?27|0)\d{9}$/,
        'en-ZM': /^(\+?26)?09[567]\d{7}$/,
        'es-CL': /^(\+?56|0)[2-9]\d{1}\d{7}$/,
        'es-EC': /^(\+?593|0)([2-7]|9[2-9])\d{7}$/,
        'es-ES': /^(\+?34)?(6\d{1}|7[1234])\d{7}$/,
        'es-MX': /^(\+?52)?(1|01)?\d{10,11}$/,
        'es-PA': /^(\+?507)\d{7,8}$/,
        'es-PY': /^(\+?595|0)9[9876]\d{7}$/,
        'es-UY': /^(\+598|0)9[1-9][\d]{6}$/,
        'et-EE': /^(\+?372)?\s?(5|8[1-4])\s?([0-9]\s?){6,7}$/,
        'fa-IR': /^(\+?98[\-\s]?|0)9[0-39]\d[\-\s]?\d{3}[\-\s]?\d{4}$/,
        'fi-FI': /^(\+?358|0)\s?(4(0|1|2|4|5|6)?|50)\s?(\d\s?){4,8}\d$/,
        'fj-FJ': /^(\+?679)?\s?\d{3}\s?\d{4}$/,
        'fo-FO': /^(\+?298)?\s?\d{2}\s?\d{2}\s?\d{2}$/,
        'fr-FR': /^(\+?33|0)[67]\d{8}$/,
        'fr-GF': /^(\+?594|0|00594)[67]\d{8}$/,
        'fr-GP': /^(\+?590|0|00590)[67]\d{8}$/,
        'fr-MQ': /^(\+?596|0|00596)[67]\d{8}$/,
        'fr-RE': /^(\+?262|0|00262)[67]\d{8}$/,
        'he-IL': /^(\+972|0)([23489]|5[012345689]|77)[1-9]\d{6}$/,
        'hu-HU': /^(\+?36)(20|30|70)\d{7}$/,
        'id-ID': /^(\+?62|0)8(1[123456789]|2[1238]|3[1238]|5[12356789]|7[78]|9[56789]|8[123456789])([\s?|\d]{5,11})$/,
        'it-IT': /^(\+?39)?\s?3\d{2} ?\d{6,7}$/,
        'ja-JP': /^(\+81[ \-]?(\(0\))?|0)[6789]0[ \-]?\d{4}[ \-]?\d{4}$/,
        'kk-KZ': /^(\+?7|8)?7\d{9}$/,
        'kl-GL': /^(\+?299)?\s?\d{2}\s?\d{2}\s?\d{2}$/,
        'ko-KR': /^((\+?82)[ \-]?)?0?1([0|1|6|7|8|9]{1})[ \-]?\d{3,4}[ \-]?\d{4}$/,
        'lt-LT': /^(\+370|8)\d{8}$/,
        'ms-MY': /^(\+?6?01){1}(([0145]{1}(\-|\s)?\d{7,8})|([236789]{1}(\s|\-)?\d{7}))$/,
        'nb-NO': /^(\+?47)?[49]\d{7}$/,
        'ne-NP': /^(\+?977)?9[78]\d{8}$/,
        'nl-BE': /^(\+?32|0)4?\d{8}$/,
        'nl-NL': /^(\+?31|0)6?\d{8}$/,
        'nn-NO': /^(\+?47)?[49]\d{7}$/,
        'pl-PL': /^(\+?48)? ?[5-8]\d ?\d{3} ?\d{2} ?\d{2}$/,
        'pt-BR': /(?=^(\+?5{2}\-?|0)[1-9]{2}\-?\d{4}\-?\d{4}$)(^(\+?5{2}\-?|0)[1-9]{2}\-?[6-9]{1}\d{3}\-?\d{4}$)|(^(\+?5{2}\-?|0)[1-9]{2}\-?9[6-9]{1}\d{3}\-?\d{4}$)/,
        'pt-PT': /^(\+?351)?9[1236]\d{7}$/,
        'ro-RO': /^(\+?4?0)\s?7\d{2}(\/|\s|\.|\-)?\d{3}(\s|\.|\-)?\d{3}$/,
        'ru-RU': /^(\+?7|8)?9\d{9}$/,
        'sl-SI': /^(\+386\s?|0)(\d{1}\s?\d{3}\s?\d{2}\s?\d{2}|\d{2}\s?\d{3}\s?\d{3})$/,
        'sk-SK': /^(\+?421)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,
        'sr-RS': /^(\+3816|06)[- \d]{5,9}$/,
        'sv-SE': /^(\+?46|0)[\s\-]?7[\s\-]?[02369]([\s\-]?\d){7}$/,
        'th-TH': /^(\+66|66|0)\d{9}$/,
        'tr-TR': /^(\+?90|0)?5\d{9}$/,
        'uk-UA': /^(\+?38|8)?0\d{9}$/,
        'vi-VN': /^(\+?84|0)((3([2-9]))|(5([2689]))|(7([0|6-9]))|(8([1-6|89]))|(9([0-9])))([0-9]{7})$/,
        'zh-CN': /^((\+|00)86)?1([358][0-9]|4[579]|6[67]|7[01235678]|9[189])[0-9]{8}$/,
        'zh-TW': /^(\+?886\-?|0)?9\d{8}$/,
    };
    /* eslint-enable max-len */
    // aliases
    phones['en-CA'] = phones['en-US'];
    phones['fr-BE'] = phones['nl-BE'];
    phones['zh-HK'] = phones['en-HK'];
    phones['zh-MO'] = phones['en-MO'];
    /**
     * Checks whether the `target` string is a valid Mobile Phone Number
     *
     * @param target The target string
     * @param locale The locale
     * @param options The options
     * @throws Error If the local passed in is not supported.
     * @return true if the `target` is a valid Mobile Phone Number, false otherwise
     */
    function isMobilePhone(target, locale, options) {
        assertString(target);
        if (options && options.strictMode && !target.startsWith('+')) {
            return false;
        }
        if (Array.isArray(locale)) {
            return locale.some(function (key) {
                // https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md#ignoring-code-for-coverage-purposes
                // istanbul ignore else
                if (phones.hasOwnProperty(key)) {
                    var phone = phones[key];
                    if (phone.test(target)) {
                        return true;
                    }
                }
                return false;
            });
        }
        else if (locale in phones) {
            return phones[locale].test(target);
            // alias falsey locale as 'any'
        }
        else if (!locale || locale === 'any') {
            for (var key in phones) {
                // istanbul ignore else
                if (phones.hasOwnProperty(key)) {
                    var phone = phones[key];
                    if (phone.test(target)) {
                        return true;
                    }
                }
            }
            return false;
        }
        throw new Error("Invalid locale '" + locale + "'");
    }
    /**
     * The supported locale list.
     */
    var isMobilePhoneLocales = Object.keys(phones);

    /**
     * Checks whether the `target` string is a valid MongoID
     *
     * @param target The target string
     * @return true if the `target` is a valid MongoID, false otherwise
     */
    function isMongoId(target) {
        assertString(target);
        return isHexadecimal(target) && target.length === 24;
    }

    /* eslint-disable no-control-regex */
    var multibyte = /[^\x00-\x7F]/;
    /* eslint-enable no-control-regex */
    /**
     * Checks whether the `target` string contains one or more multibyte characters
     *
     * @param target The target string
     * @return true if the `target` contains one or more multibyte characters, false otherwise
     */
    function isMultibyte(target) {
        assertString(target);
        return multibyte.test(target);
    }

    var numeric = /^[+-]?([0-9]*[.])?[0-9]+$/;
    var numericNoSymbols = /^[0-9]+$/;
    /**
     * Checks whether the `target` string contains only numbers
     *
     * @param target The target string
     * @param options The options
     * @return true if the `target` contains only numbers, false otherwise
     */
    function isNumeric(str, options) {
        assertString(str);
        if (options && options.no_symbols) {
            return numericNoSymbols.test(str);
        }
        return numeric.test(str);
    }

    var octal = /^(0o)?[0-7]+$/i;
    /**
     * Checks whether the `target` string is a valid Octal number
     *
     * @param target The target string
     * @return true if the `target` is a valid Octal number, false otherwise
     */
    function isOctal(target) {
        assertString(target);
        return octal.test(target);
    }

    /**
     * Reference:
     * https://en.wikipedia.org/ -- Wikipedia
     * https://docs.microsoft.com/en-us/microsoft-365/compliance/eu-passport-number -- EU Passport Number
     * https://countrycode.org/ -- Country Codes
     */
    var passportRegexByCountryCode = {
        AM: /^[A-Z]{2}\d{7}$/,
        AR: /^[A-Z]{3}\d{6}$/,
        AT: /^[A-Z]\d{7}$/,
        AU: /^[A-Z]\d{7}$/,
        BE: /^[A-Z]{2}\d{6}$/,
        BG: /^\d{9}$/,
        CA: /^[A-Z]{2}\d{6}$/,
        CH: /^[A-Z]\d{7}$/,
        CN: /^[GE]\d{8}$/,
        CY: /^[A-Z](\d{6}|\d{8})$/,
        CZ: /^\d{8}$/,
        DE: /^[CFGHJKLMNPRTVWXYZ0-9]{9}$/,
        DK: /^\d{9}$/,
        EE: /^([A-Z]\d{7}|[A-Z]{2}\d{7})$/,
        ES: /^[A-Z0-9]{2}([A-Z0-9]?)\d{6}$/,
        FI: /^[A-Z]{2}\d{7}$/,
        FR: /^\d{2}[A-Z]{2}\d{5}$/,
        GB: /^\d{9}$/,
        GR: /^[A-Z]{2}\d{7}$/,
        HR: /^\d{9}$/,
        HU: /^[A-Z]{2}(\d{6}|\d{7})$/,
        IE: /^[A-Z0-9]{2}\d{7}$/,
        IS: /^(A)\d{7}$/,
        IT: /^[A-Z0-9]{2}\d{7}$/,
        JP: /^[A-Z]{2}\d{7}$/,
        KR: /^[MS]\d{8}$/,
        LT: /^[A-Z0-9]{8}$/,
        LU: /^[A-Z0-9]{8}$/,
        LV: /^[A-Z0-9]{2}\d{7}$/,
        MT: /^\d{7}$/,
        NL: /^[A-Z]{2}[A-Z0-9]{6}\d$/,
        PO: /^[A-Z]{2}\d{7}$/,
        PT: /^[A-Z]\d{6}$/,
        RO: /^\d{8,9}$/,
        SE: /^\d{8}$/,
        SL: /^(P)[A-Z]\d{7}$/,
        SK: /^[0-9A-Z]\d{7}$/,
        TR: /^[A-Z]\d{8}$/,
        UA: /^[A-Z]{2}\d{6}$/,
        US: /^\d{9}$/,
    };
    /**
     * Check if `target` is a valid passport number
     * relative to provided `arg` ISO Country Code.
     *
     * @param target The passport number
     * @param arg The country code
     * @return true if the `target` is a passport number, false otherwise
     */
    function isPassportNumber(target, arg) {
        /** Remove All Whitespaces, Convert to UPPERCASE */
        var normalizedStr = target.replace(/\s/g, '').toUpperCase();
        return (arg.toUpperCase() in passportRegexByCountryCode) &&
            passportRegexByCountryCode[arg].test(normalizedStr);
    }

    /**
     * Check if `target` is a valid port number
     *
     * @param target The port number
     * @return true if the `target` is a port number, false otherwise
     *
     * @example
    ```
    const isPortNumber:boolean = isPort('4200')
    ```
     */
    function isPort(target) {
        return isInt(target, { min: 0, max: 65535 });
    }

    // common patterns
    var threeDigit = /^\d{3}$/;
    var fourDigit = /^\d{4}$/;
    var fiveDigit = /^\d{5}$/;
    var sixDigit = /^\d{6}$/;
    var patterns = {
        AD: /^AD\d{3}$/,
        AT: fourDigit,
        AU: fourDigit,
        BE: fourDigit,
        BG: fourDigit,
        BR: /^\d{5}-\d{3}$/,
        CA: /^[ABCEGHJKLMNPRSTVXY]\d[ABCEGHJ-NPRSTV-Z][\s\-]?\d[ABCEGHJ-NPRSTV-Z]\d$/i,
        CH: fourDigit,
        CZ: /^\d{3}\s?\d{2}$/,
        DE: fiveDigit,
        DK: fourDigit,
        DZ: fiveDigit,
        EE: fiveDigit,
        ES: fiveDigit,
        FI: fiveDigit,
        FR: /^\d{2}\s?\d{3}$/,
        GB: /^(gir\s?0aa|[a-z]{1,2}\d[\da-z]?\s?(\d[a-z]{2})?)$/i,
        GR: /^\d{3}\s?\d{2}$/,
        HR: /^([1-5]\d{4}$)/,
        HU: fourDigit,
        ID: fiveDigit,
        IE: /^(?!.*(?:o))[A-z]\d[\dw]\s\w{4}$/i,
        IL: fiveDigit,
        IN: /^((?!10|29|35|54|55|65|66|86|87|88|89)[1-9][0-9]{5})$/,
        IS: threeDigit,
        IT: fiveDigit,
        JP: /^\d{3}\-\d{4}$/,
        KE: fiveDigit,
        LI: /^(948[5-9]|949[0-7])$/,
        LT: /^LT\-\d{5}$/,
        LU: fourDigit,
        LV: /^LV\-\d{4}$/,
        MX: fiveDigit,
        MT: /^[A-Za-z]{3}\s{0,1}\d{4}$/,
        NL: /^\d{4}\s?[a-z]{2}$/i,
        NO: fourDigit,
        NZ: fourDigit,
        PL: /^\d{2}\-\d{3}$/,
        PR: /^00[679]\d{2}([ -]\d{4})?$/,
        PT: /^\d{4}\-\d{3}?$/,
        RO: sixDigit,
        RU: sixDigit,
        SA: fiveDigit,
        SE: /^[1-9]\d{2}\s?\d{2}$/,
        SI: fourDigit,
        SK: /^\d{3}\s?\d{2}$/,
        TN: fourDigit,
        TW: /^\d{3}(\d{2})?$/,
        UA: fiveDigit,
        US: /^\d{5}(-\d{4})?$/,
        ZA: fourDigit,
        ZM: fiveDigit,
    };
    var postalCodeLocales = Object.keys(patterns);
    /**
     * Checks whether the `target` string is a valid postal code
     *
     * @param target The target string
     * @param arg The locale
     * @return true if the `target` is a valid postal code, false otherwise
     */
    function isPostalCode(target, arg) {
        assertString(target);
        if (arg in patterns) {
            return patterns[arg].test(target);
        }
        else if (arg === 'any') {
            for (var key in patterns) {
                // https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md#ignoring-code-for-coverage-purposes
                // istanbul ignore else
                if (patterns.hasOwnProperty(key)) {
                    var pattern = patterns[key];
                    if (pattern.test(target)) {
                        return true;
                    }
                }
            }
            return false;
        }
        throw new Error("Invalid locale '" + arg + "'");
    }

    /* Based on https://tools.ietf.org/html/rfc3339#section-5.6 */
    var dateFullYear = /[0-9]{4}/;
    var dateMonth = /(0[1-9]|1[0-2])/;
    var dateMDay = /([12]\d|0[1-9]|3[01])/;
    var timeHour = /([01][0-9]|2[0-3])/;
    var timeMinute = /[0-5][0-9]/;
    var timeSecond = /([0-5][0-9]|60)/;
    var timeSecFrac = /(\.[0-9]+)?/;
    var timeNumOffset = new RegExp("[-+]" + timeHour.source + ":" + timeMinute.source);
    var timeOffset = new RegExp("([zZ]|" + timeNumOffset.source + ")");
    var partialTime = new RegExp(timeHour.source + ":" + timeMinute.source + ":" + timeSecond.source + timeSecFrac.source);
    var fullDate = new RegExp(dateFullYear.source + "-" + dateMonth.source + "-" + dateMDay.source);
    var fullTime = new RegExp("" + partialTime.source + timeOffset.source);
    var rfc3339 = new RegExp(fullDate.source + "[ tT]" + fullTime.source);
    /**
     * Check if `target` is a valid RFC3339 timestamp
     *
     * @param target The time stamp
     * @return true if the `target` is a valid RFC3339 timestamp, false otherwise
     *
     * @example
    ```
    const isRFC3339:boolean = isRFC3339('2002-10-02T15:00:00Z')
    ```
     */
    function isRFC3339(target) {
        assertString(target);
        return rfc3339.test(target);
    }

    var rgbColor = /^rgb\((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]),){2}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\)$/;
    var rgbaColor = /^rgba\((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]),){3}(0?\.\d|1(\.0)?|0(\.0)?)\)$/;
    var rgbColorPercent = /^rgb\((([0-9]%|[1-9][0-9]%|100%),){2}([0-9]%|[1-9][0-9]%|100%)\)/;
    var rgbaColorPercent = /^rgba\((([0-9]%|[1-9][0-9]%|100%),){3}(0?\.\d|1(\.0)?|0(\.0)?)\)/;
    /**
     * Check if `target` is a valid RGB color
     *
     * @param target The RGB color
     * @return true if the `target` is a valid RGB color, false otherwise
     *
     */
    function isRgbColor(target, includePercentValues) {
        if (includePercentValues === void 0) { includePercentValues = "true"; }
        assertString(target);
        if (!includePercentValues) {
            return rgbColor.test(target) || rgbaColor.test(target);
        }
        return rgbColor.test(target) ||
            rgbaColor.test(target) ||
            rgbColorPercent.test(target) ||
            rgbaColorPercent.test(target);
    }

    /**
     * Build RegExp object from an array
     * of multiple/multi-line regexp parts
     *
     * @param {string[]} parts
     * @param {string} flags
     * @return {object} - RegExp object
     */
    function multilineRegexp(parts, flags) {
        if (flags === void 0) { flags = ''; }
        var regexpAsStringLiteral = parts.join('');
        return new RegExp(regexpAsStringLiteral, flags);
    }

    /**
     * Regular Expression to match
     * semantic versioning (SemVer)
     * built from multi-line, multi-parts regexp
     * Reference: https://semver.org/
     */
    var semanticVersioningRegex = multilineRegexp([
        '^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)',
        '(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))',
        '?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$',
    ]);
    /**
     * Check if `target` is a valid semver version
     *
     * @param target The target
     * @return true if the `target` is a valid semver version, false otherwise
     */
    function isSemVer(target) {
        assertString(target);
        return semanticVersioningRegex.test(target);
    }

    var charsetRegex = /^[^-_](?!.*?[-_]{2,})([a-z0-9\\-]{1,}).*[^-_]$/;
    /**
     * Check if `target` is a valid slug
     *
     * @param target The target
     * @return true if the `target` is a valid slug, false otherwise
     */
    function isSlug(target) {
        assertString(target);
        return (charsetRegex.test(target));
    }

    var surrogatePair = /[\uD800-\uDBFF][\uDC00-\uDFFF]/;
    /**
     * Check if `target` is a valid surrogate pair
     *
     * @param target The target
     * @return true if the `target` a valid surrogate pair, false otherwise
     */
    function isSurrogatePair(target) {
        assertString(target);
        return surrogatePair.test(target);
    }

    /**
     * Check if `target` is uppercase
     *
     * @param target The target
     * @return true if the `target` is uppercase, false otherwise
     */
    function isUppercase(target) {
        assertString(target);
        return target === target.toUpperCase();
    }

    var default_url_options = {
        protocols: ['http', 'https', 'ftp'],
        require_tld: true,
        require_protocol: false,
        require_host: true,
        require_valid_protocol: true,
        allow_underscores: false,
        allow_trailing_dot: false,
        allow_protocol_relative_urls: false,
    };
    var wrapped_ipv6 = /^\[([^\]]+)\](?::([0-9]+))?$/;
    function isRegExp(obj) {
        return Object.prototype.toString.call(obj) === '[object RegExp]';
    }
    function checkHost(host, matches) {
        for (var i = 0; i < matches.length; i++) {
            var match = matches[i];
            if (host === match || (isRegExp(match) && match.test(host))) {
                return true;
            }
        }
        return false;
    }
    /**
     * Checks whether the `target` string is valid URL
     *
     * @param target The target string
     * @param options The options
     * @return true if the `target` is a valid URL, false otherwise
     */
    function isURL(target, options) {
        assertString(target);
        if (!target || target.length >= 2083 || /[\s<>]/.test(target)) {
            return false;
        }
        if (target.indexOf('mailto:') === 0) {
            return false;
        }
        options = merge(options, default_url_options);
        var protocol, auth, host, hostname, port, port_str, split, ipv6;
        split = target.split('#');
        target = split.shift();
        split = target.split('?');
        target = split.shift();
        split = target.split('://');
        if (split.length > 1) {
            protocol = split.shift().toLowerCase();
            if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {
                return false;
            }
        }
        else if (options.require_protocol) {
            return false;
        }
        else if (target.substr(0, 2) === '//') {
            if (!options.allow_protocol_relative_urls) {
                return false;
            }
            split[0] = target.substr(2);
        }
        target = split.join('://');
        if (target === '') {
            return false;
        }
        split = target.split('/');
        target = split.shift();
        if (target === '' && !options.require_host) {
            return true;
        }
        split = target.split('@');
        if (split.length > 1) {
            if (options.disallow_auth) {
                return false;
            }
            auth = split.shift();
            if (auth.indexOf(':') >= 0 && auth.split(':').length > 2) {
                return false;
            }
        }
        hostname = split.join('@');
        port_str = null;
        ipv6 = null;
        var ipv6_match = hostname.match(wrapped_ipv6);
        if (ipv6_match) {
            host = '';
            ipv6 = ipv6_match[1];
            port_str = ipv6_match[2] || null;
        }
        else {
            split = hostname.split(':');
            host = split.shift();
            if (split.length) {
                port_str = split.join(':');
            }
        }
        if (port_str !== null) {
            port = parseInt(port_str, 10);
            if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {
                return false;
            }
        }
        if (!isIP(host) && !isFQDN(host, options) && (!ipv6 || !isIP(ipv6, '6'))) {
            return false;
        }
        host = host || ipv6;
        if (options.host_whitelist && !checkHost(host, options.host_whitelist)) {
            return false;
        }
        if (options.host_blacklist && checkHost(host, options.host_blacklist)) {
            return false;
        }
        return true;
    }

    var uuid = {
        3: /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
        4: /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
        5: /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
        all: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
    };
    /**
     * Checks whether the `target` is a valid UUID
     *
     * @param target The target string
     * @param version The version
     * @return true if the `target` is  a valid UUID, false otherwise
     */
    function isUUID(str, version) {
        version = version ? version : 'all';
        assertString(str);
        var pattern = uuid[version];
        return pattern && pattern.test(str);
    }

    /**
     * Checks whether the `target` is variable width
     *
     * @param target The target string
     * @return true if the `target` is variable width, false otherwise
     */
    function isVariableWidth(target) {
        assertString(target);
        return fullWidth.test(target) && halfWidth.test(target);
    }

    //checks characters if they appear in the whitelist.
    /**
     * Checks whether the `target` string appears in the white list `arg`
     *
     * @param target The target string
     * @param arg The white list
     * @return true if the `target` appears in the whitelist, false otherwise
     */
    function isWhitelisted(target, arg) {
        assertString(target);
        for (var i = target.length - 1; i >= 0; i--) {
            if (arg.indexOf(target[i]) === -1) {
                return false;
            }
        }
        return true;
    }

    /**
     * Check whether the target matches the pattern
     * @param target The target
     * @param pattern The RegExp
     * @param modifiers The optional modifier
     * @return true if the target matches, false otherwise
     */
    function matches(target, pattern, modifiers) {
        assertString(target);
        if (Object.prototype.toString.call(pattern) !== '[object RegExp]') {
            pattern = new RegExp(pattern, modifiers);
        }
        return pattern.test(target);
    }

    function blacklist$1(str, chars) {
        assertString(str);
        return str.replace(new RegExp("[" + chars + "]+", 'g'), '');
    }

    function ltrim(str, chars) {
        assertString(str);
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping
        var pattern = chars ? new RegExp("^[" + chars.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + "]+", 'g') : /^\s+/g;
        return str.replace(pattern, '');
    }

    function rtrim(str, chars) {
        assertString(str);
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping
        var pattern = chars ? new RegExp("[" + chars.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + "]+$", 'g') : /\s+$/g;
        return str.replace(pattern, '');
    }

    function stripLow(str, keep_new_lines) {
        assertString(str);
        var chars = keep_new_lines ? '\\x00-\\x09\\x0B\\x0C\\x0E-\\x1F\\x7F' : '\\x00-\\x1F\\x7F';
        return blacklist$1(str, chars);
    }

    function toBoolean(str, strict) {
        assertString(str);
        if (strict) {
            return str === '1' || /^true$/i.test(str);
        }
        return str !== '0' && !/^false$/i.test(str) && str !== '';
    }

    function toInt(str, radix) {
        assertString(str);
        return parseInt(str, radix || 10);
    }

    function trim(str, chars) {
        return rtrim(ltrim(str, chars), chars);
    }

    function unescape(str) {
        assertString(str);
        return (str.replace(/&amp;/g, '&')
            .replace(/&quot;/g, '"')
            .replace(/&#x27;/g, "'")
            .replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>')
            .replace(/&#x2F;/g, '/')
            .replace(/&#x5C;/g, '\\')
            .replace(/&#96;/g, '`'));
    }

    function whitelist(str, chars) {
        assertString(str);
        return str.replace(new RegExp("[^" + chars + "]+", 'g'), '');
    }

    exports.alpha = alpha;
    exports.alphanumeric = alphanumeric;
    exports.arabicLocales = arabicLocales;
    exports.blacklist = blacklist$1;
    exports.commaDecimal = commaDecimal;
    exports.contains = contains;
    exports.decimal = decimal;
    exports.default_email_options = default_email_options;
    exports.dotDecimal = dotDecimal;
    exports.englishLocales = englishLocales;
    exports.equals = equals;
    exports.escape = escape;
    exports.floatLocales = floatLocales;
    exports.fullWidth = fullWidth;
    exports.halfWidth = halfWidth;
    exports.isAfter = isAfter;
    exports.isAlpha = isAlpha;
    exports.isAlphaLocales = isAlphaLocales;
    exports.isAlphaNumeric = isAlphaNumeric;
    exports.isAlphaNumericLocales = isAlphaNumericLocales;
    exports.isAscii = isAscii;
    exports.isBIC = isBIC;
    exports.isBase32 = isBase32;
    exports.isBase64 = isBase64;
    exports.isBefore = isBefore;
    exports.isBoolean = isBoolean;
    exports.isBtcAddress = isBtcAddress;
    exports.isByteLength = isByteLength;
    exports.isCreditCard = isCreditCard;
    exports.isCurrency = isCurrency;
    exports.isDataURI = isDataURI;
    exports.isDecimal = isDecimal;
    exports.isDivisibleBy = isDivisibleBy;
    exports.isEAN = isEAN;
    exports.isEmail = isEmail;
    exports.isEmpty = isEmpty;
    exports.isEthereumAddress = isEthereumAddress;
    exports.isFQDN = isFQDN;
    exports.isFloat = isFloat;
    exports.isFullWidth = isFullWidth;
    exports.isHSL = isHSL;
    exports.isHalfWidth = isHalfWidth;
    exports.isHash = isHash;
    exports.isHexColor = isHexColor;
    exports.isHexadecimal = isHexadecimal;
    exports.isIBAN = isIBAN;
    exports.isIP = isIP;
    exports.isISBN = isISBN;
    exports.isISIN = isISIN;
    exports.isISO31661Alpha2 = isISO31661Alpha2;
    exports.isISO31661Alpha3 = isISO31661Alpha3;
    exports.isISO8601 = isISO8601;
    exports.isISRC = isISRC;
    exports.isISSN = isISSN;
    exports.isIdentityCard = isIdentityCard;
    exports.isIn = isIn;
    exports.isInt = isInt;
    exports.isJSON = isJSON;
    exports.isJWT = isJWT;
    exports.isLatLong = isLatLong;
    exports.isLength = isLength;
    exports.isLocale = isLocale;
    exports.isLowercase = isLowercase;
    exports.isMACAddress = isMACAddress;
    exports.isMD5 = isMD5;
    exports.isMagnetURI = isMagnetURI;
    exports.isMimeType = isMimeType;
    exports.isMobilePhone = isMobilePhone;
    exports.isMobilePhoneLocales = isMobilePhoneLocales;
    exports.isMongoId = isMongoId;
    exports.isMultibyte = isMultibyte;
    exports.isNumeric = isNumeric;
    exports.isOctal = isOctal;
    exports.isPassportNumber = isPassportNumber;
    exports.isPort = isPort;
    exports.isPostalCode = isPostalCode;
    exports.isRFC3339 = isRFC3339;
    exports.isRgbColor = isRgbColor;
    exports.isSemVer = isSemVer;
    exports.isSlug = isSlug;
    exports.isSurrogatePair = isSurrogatePair;
    exports.isURL = isURL;
    exports.isUUID = isUUID;
    exports.isUppercase = isUppercase;
    exports.isVariableWidth = isVariableWidth;
    exports.isWhitelisted = isWhitelisted;
    exports.ltrim = ltrim;
    exports.matches = matches;
    exports.postalCodeLocales = postalCodeLocales;
    exports.rtrim = rtrim;
    exports.stripLow = stripLow;
    exports.toBoolean = toBoolean;
    exports.toDate = toDate;
    exports.toFloat = toFloat;
    exports.toInt = toInt;
    exports.trim = trim;
    exports.unescape = unescape;
    exports.whitelist = whitelist;
    exports.ɵ0 = ɵ0;
    exports.ɵ1 = ɵ1;
    exports.ɵ2 = ɵ2;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=fireflysemantics-validatorts.umd.js.map
