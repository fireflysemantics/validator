{"version":3,"sources":["../../../node_modules/tslib/tslib.es6.js","ng://@fireflysemantics/validatorts/lib/validators/alpha.ts","ng://@fireflysemantics/validatorts/lib/util/assertString.ts","ng://@fireflysemantics/validatorts/lib/util/toString.ts","ng://@fireflysemantics/validatorts/lib/sanitizers/toDate.ts","ng://@fireflysemantics/validatorts/lib/validators/isAlpha.ts","ng://@fireflysemantics/validatorts/lib/validators/isAlphaNumeric.ts","ng://@fireflysemantics/validatorts/lib/validators/isAscii.ts","ng://@fireflysemantics/validatorts/lib/validators/isBase32.ts","ng://@fireflysemantics/validatorts/lib/validators/isBase64.ts","ng://@fireflysemantics/validatorts/lib/validators/isBIC.ts","ng://@fireflysemantics/validatorts/lib/validators/isBtcAddress.ts","ng://@fireflysemantics/validatorts/lib/validators/isByteLength.ts","ng://@fireflysemantics/validatorts/lib/validators/isCreditCard.ts","ng://@fireflysemantics/validatorts/lib/util/merge.ts","ng://@fireflysemantics/validatorts/lib/validators/isCurrency.ts","ng://@fireflysemantics/validatorts/lib/validators/isDataURI.ts","ng://@fireflysemantics/validatorts/lib/util/includes.ts","ng://@fireflysemantics/validatorts/lib/validators/isDecimal.ts","ng://@fireflysemantics/validatorts/lib/validators/isFloat.ts","ng://@fireflysemantics/validatorts/lib/sanitizers/toFloat.ts","ng://@fireflysemantics/validatorts/lib/validators/isEAN.ts","ng://@fireflysemantics/validatorts/lib/validators/isFQDN.ts","ng://@fireflysemantics/validatorts/lib/validators/isIP.ts","ng://@fireflysemantics/validatorts/lib/validators/isEmail.ts","ng://@fireflysemantics/validatorts/lib/validators/isEmpty.ts","ng://@fireflysemantics/validatorts/lib/validators/isEthereumAddress.ts","ng://@fireflysemantics/validatorts/lib/validators/isFullWidth.ts","ng://@fireflysemantics/validatorts/lib/validators/isHalfWidth.ts","ng://@fireflysemantics/validatorts/lib/validators/isHash.ts","ng://@fireflysemantics/validatorts/lib/validators/isHexadecimal.ts","ng://@fireflysemantics/validatorts/lib/validators/isHexColor.ts","ng://@fireflysemantics/validatorts/lib/validators/isHSL.ts","ng://@fireflysemantics/validatorts/lib/validators/isIBAN.ts","ng://@fireflysemantics/validatorts/lib/validators/isIdentityCard.ts","ng://@fireflysemantics/validatorts/lib/validators/isInt.ts","ng://@fireflysemantics/validatorts/lib/validators/isISBN.ts","ng://@fireflysemantics/validatorts/lib/validators/isISIN.ts","ng://@fireflysemantics/validatorts/lib/validators/isISO8601.ts","ng://@fireflysemantics/validatorts/lib/validators/isISO31661Alpha2.ts","ng://@fireflysemantics/validatorts/lib/validators/isISO31661Alpha3.ts","ng://@fireflysemantics/validatorts/lib/validators/isISRC.ts","ng://@fireflysemantics/validatorts/lib/validators/isJWT.ts","ng://@fireflysemantics/validatorts/lib/validators/isLatLong.ts","ng://@fireflysemantics/validatorts/lib/validators/isLocale.ts","ng://@fireflysemantics/validatorts/lib/validators/isMACAddress.ts","ng://@fireflysemantics/validatorts/lib/validators/isMagnetURI.ts","ng://@fireflysemantics/validatorts/lib/validators/isMD5.ts","ng://@fireflysemantics/validatorts/lib/validators/isMimeType.ts","ng://@fireflysemantics/validatorts/lib/validators/isMobilePhone.ts","ng://@fireflysemantics/validatorts/lib/validators/isMultibyte.ts","ng://@fireflysemantics/validatorts/lib/validators/isNumeric.ts","ng://@fireflysemantics/validatorts/lib/validators/isOctal.ts","ng://@fireflysemantics/validatorts/lib/validators/isPassportNumber.ts","ng://@fireflysemantics/validatorts/lib/validators/isPostalCode.ts","ng://@fireflysemantics/validatorts/lib/validators/isRFC3339.ts","ng://@fireflysemantics/validatorts/lib/validators/isRgbColor.ts","ng://@fireflysemantics/validatorts/lib/validators/isSemVer.ts","ng://@fireflysemantics/validatorts/lib/util/multilineRegex.ts","ng://@fireflysemantics/validatorts/lib/validators/isSlug.ts","ng://@fireflysemantics/validatorts/lib/validators/isSurrogatePair.ts","ng://@fireflysemantics/validatorts/lib/validators/isURL.ts","ng://@fireflysemantics/validatorts/lib/validators/isUUID.ts","ng://@fireflysemantics/validatorts/lib/sanitizers/blacklist.ts","ng://@fireflysemantics/validatorts/lib/sanitizers/ltrim.ts","ng://@fireflysemantics/validatorts/lib/sanitizers/rtrim.ts","ng://@fireflysemantics/validatorts/lib/validators/contains.ts","ng://@fireflysemantics/validatorts/lib/validators/equals.ts","ng://@fireflysemantics/validatorts/lib/sanitizers/escape.ts","ng://@fireflysemantics/validatorts/lib/validators/isAfter.ts","ng://@fireflysemantics/validatorts/lib/validators/isBefore.ts","ng://@fireflysemantics/validatorts/lib/validators/isBoolean.ts","ng://@fireflysemantics/validatorts/lib/validators/isDivisibleBy.ts","ng://@fireflysemantics/validatorts/lib/validators/isISSN.ts","ng://@fireflysemantics/validatorts/lib/validators/isIn.ts","ng://@fireflysemantics/validatorts/lib/validators/isJSON.ts","ng://@fireflysemantics/validatorts/lib/validators/isLength.ts","ng://@fireflysemantics/validatorts/lib/validators/isLowercase.ts","ng://@fireflysemantics/validatorts/lib/validators/isMongoId.ts","ng://@fireflysemantics/validatorts/lib/validators/isPort.ts","ng://@fireflysemantics/validatorts/lib/validators/isUppercase.ts","ng://@fireflysemantics/validatorts/lib/validators/isVariableWidth.ts","ng://@fireflysemantics/validatorts/lib/validators/isWhitelisted.ts","ng://@fireflysemantics/validatorts/lib/validators/matches.ts","ng://@fireflysemantics/validatorts/lib/sanitizers/stripLow.ts","ng://@fireflysemantics/validatorts/lib/sanitizers/toBoolean.ts","ng://@fireflysemantics/validatorts/lib/sanitizers/toInt.ts","ng://@fireflysemantics/validatorts/lib/sanitizers/trim.ts","ng://@fireflysemantics/validatorts/lib/sanitizers/unescape.ts","ng://@fireflysemantics/validatorts/lib/sanitizers/whitelist.ts"],"names":["__read","o","n","m","Symbol","iterator","r","e","i","call","ar","next","done","push","value","error","alpha","en-US","bg-BG","cs-CZ","da-DK","de-DE","el-GR","es-ES","fr-FR","it-IT","nb-NO","nl-NL","nn-NO","hu-HU","pl-PL","pt-PT","ru-RU","sl-SI","sk-SK","sr-RS@latin","sr-RS","sv-SE","tr-TR","uk-UA","ku-IQ","he","fa-IR","alphanumeric","decimal","englishLocales","locale","length","arabicLocales","dotDecimal","commaDecimal","assertString","input","String","invalidType","constructor","hasOwnProperty","name","TypeError","toString","isNaN","toDate","date","millis","Date","parse","isAlphaLocales","Object","keys","isAlphaNumericLocales","ascii","base32","notBase64","isBICReg","btc","isByteLength","target","options","min","max","arguments","len","encodeURI","split","creditCard","merge","obj","defaults","key","default_currency_options","symbol","require_symbol","allow_space_after_symbol","symbol_after_digits","allow_negatives","parens_for_negatives","negative_sign_before_digits","negative_sign_after_digits","allow_negative_sign_placeholder","thousands_separator","decimal_separator","allow_decimal","require_decimal","digits_after_decimal","allow_space_after_digits","validMediaType","validAttribute","validData","includes","arr","val","some","arrVal","default_decimal_options","force_decimal","decimal_digits","blacklist","isFloat","str","float","RegExp","parseFloat","replace","test","lt","gt","floatLocales","toFloat","NaN","validEanRegex","default_fqdn_options","require_tld","allow_underscores","allow_trailing_dot","isFQDN","substring","parts","tld","pop","part","ipv4Maybe","ipv6Block","isIP","version","sort","a","b","parseInt","addressAndZone","blocks","foundOmissionBlock","foundIPv4TransitionBlock","expectedNumberOfBlocks","substr","shift","default_email_options","require_display_name","allow_display_name","allow_utf8_local_part","splitNameAddress","emailUserPart","gmailUserPart","quotedEmailUser","emailUserUtf8Part","quotedEmailUserUtf8","default_is_empty_options","ignore_whitespace","eth","fullWidth","halfWidth","lengths","md5","md4","sha1","sha256","sha384","sha512","ripemd128","ripemd160","tiger128","tiger160","tiger192","crc32","crc32b","hexadecimal","isHexadecimal","hexcolor","hslcomma","hslspace","ibanRegexThroughCountryCode","AD","AE","AL","AT","AZ","BA","BE","BG","BH","BR","BY","CH","CR","CY","CZ","DE","DK","DO","EE","ES","FI","FO","FR","GB","GE","GI","GL","GR","GT","HR","HU","IE","IL","IQ","IS","IT","JO","KW","KZ","LB","LC","LI","LT","LU","LV","MC","MD","ME","MK","MR","MT","MU","NL","NO","PK","PL","PS","PT","QA","RO","RS","SA","SC","SE","SI","SK","SM","TL","TN","TR","UA","VA","VG","XK","charsValue","X","Y","Z","sanitized","trim","toUpperCase","number","slice","char","endsWith","ɵ1","incNum","id","sum","Number","ɵ2","ALPHABET_CODES","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","Array","from","reduce","num","index","code","Math","floor","validators","ɵ0","he-IL","zh-TW","int","intLeadingZeroes","isInt","regex","allow_leading_zeroes","minCheckPassed","maxCheckPassed","ltCheckPassed","gtCheckPassed","isbn10Maybe","isbn13Maybe","factor","isin","iso8601","isValidDate","ordinalMatch","match","oYear","oDay","map","year","month","day","monthString","dayString","d","getUTCFullYear","getUTCMonth","getUTCDate","validISO31661Alpha2CountriesCodes","validISO31661Alpha3CountriesCodes","isrc","jwt","lat","long","localeReg","macAddress","macAddressNoColons","macAddressWithHyphen","macAddressWithSpaces","magnetURI","mimeTypeSimple","mimeTypeText","mimeTypeMultipart","phones","am-AM","ar-AE","ar-BH","ar-DZ","ar-EG","ar-IQ","ar-JO","ar-KW","ar-SA","ar-SY","ar-TN","be-BY","bn-BD","de-AT","en-AU","en-GB","en-GG","en-GH","en-HK","en-MO","en-IE","en-IN","en-KE","en-MT","en-MU","en-NG","en-NZ","en-PK","en-RW","en-SG","en-TZ","en-UG","en-ZA","en-ZM","es-CL","es-EC","es-MX","es-PA","es-PY","es-UY","et-EE","fi-FI","fj-FJ","fo-FO","fr-GF","fr-GP","fr-MQ","fr-RE","id-ID","ja-JP","kk-KZ","kl-GL","ko-KR","lt-LT","ms-MY","ne-NP","nl-BE","pt-BR","ro-RO","th-TH","vi-VN","zh-CN","isMobilePhoneLocales","multibyte","numeric","numericNoSymbols","octal","passportRegexByCountryCode","AM","AR","AU","CA","CN","JP","KR","PO","SL","US","fourDigit","fiveDigit","sixDigit","patterns","DZ","ID","IN","KE","MX","NZ","PR","RU","TW","ZA","ZM","postalCodeLocales","timeHour","timeMinute","timeNumOffset","source","timeOffset","partialTime","fullDate","fullTime","rfc3339","rgbColor","rgbaColor","rgbColorPercent","rgbaColorPercent","semanticVersioningRegex","flags","regexpAsStringLiteral","join","multilineRegexp","charsetRegex","surrogatePair","default_url_options","protocols","require_protocol","require_host","require_valid_protocol","allow_protocol_relative_urls","wrapped_ipv6","checkHost","host","matches","prototype","uuid","3","4","5","all","chars","ltrim","pattern","rtrim","arg","indexOf","comparison","original","Error","firstPaddingChar","digit","tmpNum","shouldDouble","forEach","whole_dollar_amount","decimal_amount","currencyRegex","data","attributes","schemeAndMediaType","mediaType","toLowerCase","decimalRegExp","ean","remainder","actualCheckDigit","getPositionWeightThroughLengthAndIndex","acc","partialSum","display_email","display_name","_a","trim_quotes","display_name_without_quotes","validateDisplayName","ignore_max_length","domain","user","lower_domain","domain_specific_validation","username","user_parts_1","allow_ip_domain","startsWith","noBracketdomain","user_parts","strippedStr","isoCountryCode","charCodeAt","hasValidIbanChecksum","isISBN","checksum","charAt","checksumStr","character","intValue","check","strict","testIssn","require_hyphen","case_sensitive","digits","validator","array","JSON","pair","surrogatePairs","no_colons","strictMode","isArray","no_symbols","normalizedStr","includePercentValues","protocol","auth","hostname","port","port_str","ipv6","disallow_auth","ipv6_match","host_whitelist","host_blacklist","modifiers","keep_new_lines","radix"],"mappings":"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,KACpC,KAAM,KACN,KAAM,KACN,KAAM,KAAM,MCzBd,IAAMC,GAAoC,CACxC,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACzG,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACzG,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACzG,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACzG,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACzG,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACzG,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACzG,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACzG,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACzG,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACzG,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACzG,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACzG,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACzG,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACzG,MAAO,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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","export const alpha = {\n  'en-US': /^[A-Z]+$/i,\n  'bg-BG': /^[А-Я]+$/i,\n  'cs-CZ': /^[A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]+$/i,\n  'da-DK': /^[A-ZÆØÅ]+$/i,\n  'de-DE': /^[A-ZÄÖÜß]+$/i,\n  'el-GR': /^[Α-ώ]+$/i,\n  'es-ES': /^[A-ZÁÉÍÑÓÚÜ]+$/i,\n  'fr-FR': /^[A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]+$/i,\n  'it-IT': /^[A-ZÀÉÈÌÎÓÒÙ]+$/i,\n  'nb-NO': /^[A-ZÆØÅ]+$/i,\n  'nl-NL': /^[A-ZÁÉËÏÓÖÜÚ]+$/i,\n  'nn-NO': /^[A-ZÆØÅ]+$/i,\n  'hu-HU': /^[A-ZÁÉÍÓÖŐÚÜŰ]+$/i,\n  'pl-PL': /^[A-ZĄĆĘŚŁŃÓŻŹ]+$/i,\n  'pt-PT': /^[A-ZÃÁÀÂÄÇÉÊËÍÏÕÓÔÖÚÜ]+$/i,\n  'ru-RU': /^[А-ЯЁ]+$/i,\n  'sl-SI': /^[A-ZČĆĐŠŽ]+$/i,\n  'sk-SK': /^[A-ZÁČĎÉÍŇÓŠŤÚÝŽĹŔĽÄÔ]+$/i,\n  'sr-RS@latin': /^[A-ZČĆŽŠĐ]+$/i,\n  'sr-RS': /^[А-ЯЂЈЉЊЋЏ]+$/i,\n  'sv-SE': /^[A-ZÅÄÖ]+$/i,\n  'tr-TR': /^[A-ZÇĞİıÖŞÜ]+$/i,\n  'uk-UA': /^[А-ЩЬЮЯЄIЇҐі]+$/i,\n  'ku-IQ': /^[ئابپتجچحخدرڕزژسشعغفڤقکگلڵمنوۆھەیێيطؤثآإأكضصةظذ]+$/i,\n  ar: /^[ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]+$/,\n  he: /^[א-ת]+$/,\n  'fa-IR': /^['آابپتثجچهخدذرزژسشصضطظعغفقکگلمنوهی']+$/i,\n};\n\nexport const alphanumeric = {\n  'en-US': /^[0-9A-Z]+$/i,\n  'bg-BG': /^[0-9А-Я]+$/i,\n  'cs-CZ': /^[0-9A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]+$/i,\n  'da-DK': /^[0-9A-ZÆØÅ]+$/i,\n  'de-DE': /^[0-9A-ZÄÖÜß]+$/i,\n  'el-GR': /^[0-9Α-ω]+$/i,\n  'es-ES': /^[0-9A-ZÁÉÍÑÓÚÜ]+$/i,\n  'fr-FR': /^[0-9A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]+$/i,\n  'it-IT': /^[0-9A-ZÀÉÈÌÎÓÒÙ]+$/i,\n  'hu-HU': /^[0-9A-ZÁÉÍÓÖŐÚÜŰ]+$/i,\n  'nb-NO': /^[0-9A-ZÆØÅ]+$/i,\n  'nl-NL': /^[0-9A-ZÁÉËÏÓÖÜÚ]+$/i,\n  'nn-NO': /^[0-9A-ZÆØÅ]+$/i,\n  'pl-PL': /^[0-9A-ZĄĆĘŚŁŃÓŻŹ]+$/i,\n  'pt-PT': /^[0-9A-ZÃÁÀÂÄÇÉÊËÍÏÕÓÔÖÚÜ]+$/i,\n  'ru-RU': /^[0-9А-ЯЁ]+$/i,\n  'sl-SI': /^[0-9A-ZČĆĐŠŽ]+$/i,\n  'sk-SK': /^[0-9A-ZÁČĎÉÍŇÓŠŤÚÝŽĹŔĽÄÔ]+$/i,\n  'sr-RS@latin': /^[0-9A-ZČĆŽŠĐ]+$/i,\n  'sr-RS': /^[0-9А-ЯЂЈЉЊЋЏ]+$/i,\n  'sv-SE': /^[0-9A-ZÅÄÖ]+$/i,\n  'tr-TR': /^[0-9A-ZÇĞİıÖŞÜ]+$/i,\n  'uk-UA': /^[0-9А-ЩЬЮЯЄIЇҐі]+$/i,\n  'ku-IQ': /^[٠١٢٣٤٥٦٧٨٩0-9ئابپتجچحخدرڕزژسشعغفڤقکگلڵمنوۆھەیێيطؤثآإأكضصةظذ]+$/i,\n  ar: /^[٠١٢٣٤٥٦٧٨٩0-9ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]+$/,\n  he: /^[0-9א-ת]+$/,\n  'fa-IR': /^['0-9آابپتثجچهخدذرزژسشصضطظعغفقکگلمنوهی۱۲۳۴۵۶۷۸۹۰']+$/i,\n};\n\nexport const decimal = {\n  'en-US': '.',\n  ar: '٫',\n};\n\n\nexport const englishLocales = ['AU', 'GB', 'HK', 'IN', 'NZ', 'ZA', 'ZM'];\n\nfor (let locale, i = 0; i < englishLocales.length; i++) {\n  locale = `en-${englishLocales[i]}`;\n  alpha[locale] = alpha['en-US'];\n  alphanumeric[locale] = alphanumeric['en-US'];\n  decimal[locale] = decimal['en-US'];\n}\n\n// Source: http://www.localeplanet.com/java/\nexport const arabicLocales = [\n  'AE', 'BH', 'DZ', 'EG', 'IQ', 'JO', 'KW', 'LB', 'LY',\n  'MA', 'QM', 'QA', 'SA', 'SD', 'SY', 'TN', 'YE',\n];\n\nfor (let locale, i = 0; i < arabicLocales.length; i++) {\n  locale = `ar-${arabicLocales[i]}`;\n  alpha[locale] = alpha.ar;\n  alphanumeric[locale] = alphanumeric.ar;\n  decimal[locale] = decimal.ar;\n}\n\n// Source: https://en.wikipedia.org/wiki/Decimal_mark\nexport const dotDecimal = ['ar-EG', 'ar-LB', 'ar-LY'];\nexport const commaDecimal = [\n  'bg-BG', 'cs-CZ', 'da-DK', 'de-DE', 'el-GR', 'en-ZM', 'es-ES', 'fr-FR', 'it-IT', 'ku-IQ', 'hu-HU', 'nb-NO',\n  'nn-NO', 'nl-NL', 'pl-PL', 'pt-PT', 'ru-RU', 'sl-SI', 'sr-RS@latin',\n  'sr-RS', 'sv-SE', 'tr-TR', 'uk-UA',\n];\n\nfor (let i = 0; i < dotDecimal.length; i++) {\n  decimal[dotDecimal[i]] = decimal['en-US'];\n}\n\nfor (let i = 0; i < commaDecimal.length; i++) {\n  decimal[commaDecimal[i]] = ',';\n}\n\nalpha['pt-BR'] = alpha['pt-PT'];\nalphanumeric['pt-BR'] = alphanumeric['pt-PT'];\ndecimal['pt-BR'] = decimal['pt-PT'];\n\n// see #862\nalpha['pl-Pl'] = alpha['pl-PL'];\nalphanumeric['pl-Pl'] = alphanumeric['pl-PL'];\ndecimal['pl-Pl'] = decimal['pl-PL'];\n","/**\n * Tests whether `input` is of type string\n * @param input The value that should be a string\n * @throws TypeError if the value is not a string \n */\nexport function assertString(input:any) {\n  const isString = (typeof input === 'string' || input instanceof String);\n\n  if (!isString) {\n    let invalidType;\n    if (input === null) {\n      invalidType = 'null';\n    } else {\n      invalidType = typeof input;\n      if (invalidType === 'object' && input.constructor && input.constructor.hasOwnProperty('name')) {\n        invalidType = input.constructor.name;\n      } else {\n        invalidType = `a ${invalidType}`;\n      }\n    }\n    throw new TypeError(`Expected string but received ${invalidType}.`);\n  }\n}\n","/**\n * Convert the `input` argument into a string\n * @param input The input that should be converted to a string\n * @return The string value for the `input` argument\n */\nexport function toString(input) {\n  if (typeof input === 'object' && input !== null) {\n    if (typeof input.toString === 'function') {\n      input = input.toString();\n    } else {\n      input = '[object Object]';\n    }\n  } else if (input === null || typeof input === 'undefined' || (isNaN(input) && !input.length)) {\n    input = '';\n  }\n  return String(input);\n}\n","import { assertString } from '../util/assertString';\n\nexport function toDate(date: string) {\n  assertString(date);\n  const millis: number = Date.parse(date);\n  return !isNaN(millis) ? new Date(date) : null;\n}\n","import { assertString } from '../util/assertString';\nimport { alpha } from './alpha';\n\n/**\n * Checks whether `arg` is in alpha and if so validates whether\n * the `target` string conforms to the `arg` locale.\n * \n * @param target The target string to compare to\n * @param arg The argument that might equal the target \n * @return true if the `target` date comes after the `arg` date, false otherwise\n */\nexport function isAlpha(target: string, arg: string = 'en-US') {\n  assertString(target);\n  if (arg in alpha) {\n    return alpha[arg].test(target);\n  }\n  throw new Error(`Invalid locale '${arg}'`);\n}\n\n/**\n * The alpha locales\n */\nexport const isAlphaLocales = Object.keys(alpha);","import { assertString } from '../util/assertString';\nimport { alphanumeric } from './alpha';\n\n/**\n * Checks whether `arg` is in alphanumeric and if so validates whether\n * the `target` string conforms to the `arg` locale.\n * \n * @param target The target string\n * @param arg The locale (Defaults to 'en-US') \n * @return true if the `target` string conforms to the `arg` locale, false otherwise\n */\nexport function isAlphaNumeric(target: string, arg: string = 'en-US') {\n  assertString(target);\n  if (arg in alphanumeric) {\n    return alphanumeric[arg].test(target);\n  }\n  throw new Error(`Invalid locale '${arg}'`);\n}\n\n/**\n * The alpha numeric locales\n */\nexport const isAlphaNumericLocales = Object.keys(alphanumeric);","import { assertString } from '../util/assertString';\n\n/* eslint-disable no-control-regex */\nconst ascii = /^[\\x00-\\x7F]+$/;\n/* eslint-enable no-control-regex */\n\n/**\n * Checks whether the `target` conforms to the ascii standard\n * \n * @param target The target string\n * @return true if the `target` conforms to the ascii standard, false otherwise\n */\nexport function isAscii(target: string) {\n  assertString(target);\n  return ascii.test(target);\n}","import { assertString } from '../util/assertString';\n\nconst base32 = /^[A-Z2-7]+=*$/;\n\n/**\n * Checks whether the `target` is base32 encoded\n * \n * @param target The target string\n * @return true if the `target` is base32 encoded, false otherwise\n */\nexport function isBase32(str: string) {\n  assertString(str);\n  const len = str.length;\n  if (len > 0 && len % 8 === 0 && base32.test(str)) {\n    return true;\n  }\n  return false;\n}\n","import { assertString } from '../util/assertString';\n\nconst notBase64 = /[^A-Z0-9+\\/=]/i;\n\n/**\n * Checks whether the `target` is base64 encoded\n * \n * @param target The target string\n * @return true if the `target` is base64 encoded, false otherwise\n */\nexport function isBase64(str: string) {\n  assertString(str);\n  const len = str.length;\n  if (!len || len % 4 !== 0 || notBase64.test(str)) {\n    return false;\n  }\n  const firstPaddingChar = str.indexOf('=');\n  return firstPaddingChar === -1 ||\n    firstPaddingChar === len - 1 ||\n    (firstPaddingChar === len - 2 && str[len - 1] === '=');\n}\n","import { assertString } from '../util/assertString';\n\nconst isBICReg = /^[A-z]{4}[A-z]{2}\\w{2}(\\w{3})?$/;\n\n\n/**\n * Checks whether the `target` is BIC encoded\n * \n * @param target The target string\n * @return true if the `target` is BIC encoded, false otherwise\n */\nexport function isBIC(str: string) {\n  assertString(str);\n  return isBICReg.test(str);\n}\n","import { assertString } from '../util/assertString';\n\n// supports Bech32 addresses\nconst btc = /^(bc1|[13])[a-zA-HJ-NP-Z0-9]{25,39}$/;\n\n/**\n * Checks whether the `target` is a btc address \n * \n * @param target The target string\n * @return true if the `target` is a btc address, false otherwise\n */\nexport function isBtcAddress(str: string) {\n  assertString(str);\n  return btc.test(str);\n}\n","import { assertString } from '../util/assertString';\n\n/* eslint-disable prefer-rest-params */\n\n/**\n * Checks whether the `target` string's length (in UTF-8 bytes) \n * falls in a range.\n * \n * @param target The target string\n * @param options The option parameters containing the min and max length of the string \n * @return true if the `target` strings conforms to the provided range\n */\nexport function isByteLength(target: string, options?: any) {\n  assertString(target);\n  let min;\n  let max;\n  if (typeof (options) === 'object') {\n    min = options.min || 0;\n    max = options.max;\n  } else { // backwards compatibility: isByteLength(str, min [, max])\n    min = arguments[1];\n    max = arguments[2];\n  }\n  const len = encodeURI(target).split(/%..|./).length - 1;\n  return len >= min && (typeof max === 'undefined' || len <= max);\n}","import { assertString } from '../util/assertString';\n\n/* eslint-disable max-len */\nconst creditCard = /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\\d{3})\\d{11}|6[27][0-9]{14})$/;\n/* eslint-enable max-len */\n\n/**\n * Checks whether the `target` string is a credit card number\n * \n * @param target The target string\n * @return true if the `target` is a credit card number, false otherwise\n */\nexport function isCreditCard(target: string) {\n  assertString(target);\n  const sanitized = target.replace(/[- ]+/g, '');\n  if (!creditCard.test(sanitized)) {\n    return false;\n  }\n  let sum = 0;\n  let digit;\n  let tmpNum;\n  let shouldDouble;\n  for (let i = sanitized.length - 1; i >= 0; i--) {\n    digit = sanitized.substring(i, (i + 1));\n    tmpNum = parseInt(digit, 10);\n    if (shouldDouble) {\n      tmpNum *= 2;\n      if (tmpNum >= 10) {\n        sum += ((tmpNum % 10) + 1);\n      } else {\n        sum += tmpNum;\n      }\n    } else {\n      sum += tmpNum;\n    }\n    shouldDouble = !shouldDouble;\n  }\n  return !!((sum % 10) === 0 ? sanitized : false);\n}\n","export function merge(obj = { }, defaults) {\n  for (const key in defaults) {\n    if (typeof obj[key] === 'undefined') {\n      obj[key] = defaults[key];\n    }\n  }\n  return obj;\n}\n","import { merge } from '../util/merge';\nimport { assertString } from '../util/assertString';\n\nfunction currencyRegex(options) {\n  let decimal_digits = `\\\\d{${options.digits_after_decimal[0]}}`;\n  options.digits_after_decimal.forEach((digit, index) => { if (index !== 0) decimal_digits = `${decimal_digits}|\\\\d{${digit}}`; });\n  const symbol =\n    `(\\\\${options.symbol.replace(/\\./g, '\\\\.')})${(options.require_symbol ? '' : '?')}`,\n    negative = '-?',\n    whole_dollar_amount_without_sep = '[1-9]\\\\d*',\n    whole_dollar_amount_with_sep = `[1-9]\\\\d{0,2}(\\\\${options.thousands_separator}\\\\d{3})*`,\n    valid_whole_dollar_amounts = [\n      '0', whole_dollar_amount_without_sep, whole_dollar_amount_with_sep],\n    whole_dollar_amount = `(${valid_whole_dollar_amounts.join('|')})?`,\n    decimal_amount = `(\\\\${options.decimal_separator}(${decimal_digits}))${options.require_decimal ? '' : '?'}`;\n  let pattern = whole_dollar_amount + (options.allow_decimal || options.require_decimal ? decimal_amount : '');\n\n  // default is negative sign before symbol, but there are two other options (besides parens)\n  if (options.allow_negatives && !options.parens_for_negatives) {\n    if (options.negative_sign_after_digits) {\n      pattern += negative;\n    } else if (options.negative_sign_before_digits) {\n      pattern = negative + pattern;\n    }\n  }\n\n  // South African Rand, for example, uses R 123 (space) and R-123 (no space)\n  if (options.allow_negative_sign_placeholder) {\n    pattern = `( (?!\\\\-))?${pattern}`;\n  } else if (options.allow_space_after_symbol) {\n    pattern = ` ?${pattern}`;\n  } else if (options.allow_space_after_digits) {\n    pattern += '( (?!$))?';\n  }\n\n  if (options.symbol_after_digits) {\n    pattern += symbol;\n  } else {\n    pattern = symbol + pattern;\n  }\n\n  if (options.allow_negatives) {\n    if (options.parens_for_negatives) {\n      pattern = `(\\\\(${pattern}\\\\)|${pattern})`;\n    } else if (!(options.negative_sign_before_digits || options.negative_sign_after_digits)) {\n      pattern = negative + pattern;\n    }\n  }\n\n  // ensure there's a dollar and/or decimal amount, and that\n  // it doesn't start with a space or a negative sign followed by a space\n  return new RegExp(`^(?!-? )(?=.*\\\\d)${pattern}$`);\n}\n\n/**\n * IsCurrency Options.\n */\nexport interface IsCurrencyOptions {\n  symbol?: string\n  require_symbol?: boolean\n  allow_space_after_symbol?: boolean\n  symbol_after_digits?: boolean\n  allow_negatives?: boolean\n  parens_for_negatives?: boolean\n  negative_sign_before_digits?: boolean\n  negative_sign_after_digits?: boolean\n  allow_negative_sign_placeholder?: boolean\n  thousands_separator?: string\n  decimal_separator?: string\n  allow_decimal: boolean\n  require_decimal: boolean\n  digits_after_decimal: number[]\n  allow_space_after_digits?: boolean\n}\n\n\n/**\n * The currency default options\n */\nconst default_currency_options:IsCurrencyOptions = {\n  symbol: '$',\n  require_symbol: false,\n  allow_space_after_symbol: false,\n  symbol_after_digits: false,\n  allow_negatives: true,\n  parens_for_negatives: false,\n  negative_sign_before_digits: false,\n  negative_sign_after_digits: false,\n  allow_negative_sign_placeholder: false,\n  thousands_separator: ',',\n  decimal_separator: '.',\n  allow_decimal: true,\n  require_decimal: false,\n  digits_after_decimal: [2],\n  allow_space_after_digits: false,\n};\n\n/**\n * Checks whether the `target` string is a currency\n * \n * @param target The target string\n * @param options The options\n * @return true if the `target` is a currency, false otherwise\n */\nexport function isCurrency(str: string, options) {\n  assertString(str);\n  options = merge(options, default_currency_options);\n  return currencyRegex(options).test(str);\n}\n","import { assertString } from '../util/assertString';\n\nconst validMediaType = /^[a-z]+\\/[a-z0-9\\-\\+]+$/i;\n\nconst validAttribute = /^[a-z\\-]+=[a-z0-9\\-]+$/i;\n\nconst validData = /^[a-z0-9!\\$&'\\(\\)\\*\\+,;=\\-\\._~:@\\/\\?%\\s]*$/i;\n\n/**\n * Checks whether the `target` string is a data URI\n * \n * @param target The target string\n * @param options The options\n * @return true if the `target` is a data URI, false otherwise\n */\nexport function isDataURI(target: string) {\n  assertString(target);\n  let data = target.split(',');\n  if (data.length < 2) {\n    return false;\n  }\n  const attributes = data.shift().trim().split(';');\n  const schemeAndMediaType = attributes.shift();\n  if (schemeAndMediaType.substr(0, 5) !== 'data:') {\n    return false;\n  }\n  const mediaType = schemeAndMediaType.substr(5);\n  if (mediaType !== '' && !validMediaType.test(mediaType)) {\n    return false;\n  }\n  for (let i = 0; i < attributes.length; i++) {\n    if (i === attributes.length - 1 && attributes[i].toLowerCase() === 'base64') {\n      // ok\n    } else if (!validAttribute.test(attributes[i])) {\n      return false;\n    }\n  }\n  for (let i = 0; i < data.length; i++) {\n    if (!validData.test(data[i])) {\n      return false;\n    }\n  }\n  return true;\n}","export const includes = (arr, val) => arr.some(arrVal => val === arrVal);","import { merge } from '../util/merge';\nimport { assertString } from '../util/assertString';\nimport { includes } from '../util/includes';\nimport { decimal } from './alpha';\n\nfunction decimalRegExp(options) {\n  const regExp = new RegExp(`^[-+]?([0-9]+)?(\\\\${decimal[options.locale]}[0-9]{${options.decimal_digits}})${options.force_decimal ? '' : '?'}$`);\n  return regExp;\n}\n\n/**\n * The default options\n */\nconst default_decimal_options = {\n  force_decimal: false,\n  decimal_digits: '1,',\n  locale: 'en-US',\n};\n\nconst blacklist = ['', '-', '+'];\n\n/**\n * Checks whether the `target` string is a decimal\n * \n * @param target The target string\n * @param options The options\n * @return true if the `target` is a decimal, false otherwise\n */\nexport function isDecimal(target: string, options) {\n  assertString(target);\n  options = merge(options, default_decimal_options);\n  if (options.locale in decimal) {\n    return !includes(blacklist, target.replace(/ /g, '')) && decimalRegExp(options).test(target);\n  }\n  throw new Error(`Invalid locale '${options.locale}'`);\n}\n","import { assertString } from '../util/assertString';\nimport { decimal } from './alpha';\n\n/**\n * Checks whether the `target` string is a float\n * \n * @param target The target string\n * @param options The options\n * @return true if the `target` is is a float, false otherwise\n */\nexport function isFloat(str: string, options?) {\n  assertString(str);\n  options = options || {};\n  const float = new RegExp(`^(?:[-+])?(?:[0-9]+)?(?:\\\\${options.locale ? decimal[options.locale] : '.'}[0-9]*)?(?:[eE][\\\\+\\\\-]?(?:[0-9]+))?$`);\n  if (str === '' || str === '.' || str === '-' || str === '+') {\n    return false;\n  }\n  const value = parseFloat(str.replace(',', '.'));\n  return float.test(str) &&\n    (!options.hasOwnProperty('min') || value >= options.min) &&\n    (!options.hasOwnProperty('max') || value <= options.max) &&\n    (!options.hasOwnProperty('lt') || value < options.lt) &&\n    (!options.hasOwnProperty('gt') || value > options.gt);\n}\n\nexport const floatLocales = Object.keys(decimal);\n","import { isFloat } from '../validators/isFloat';\n\nexport function toFloat(str) {\n  if (!isFloat(str)) return NaN;\n\n  return parseFloat(str);\n}\n","/**\n * The most commonly used EAN standard is\n * the thirteen-digit EAN-13, while the\n * less commonly used 8-digit EAN-8 barcode was\n * introduced for use on small packages.\n * EAN consists of:\n * GS1 prefix, manufacturer code, product code and check digit\n * Reference: https://en.wikipedia.org/wiki/International_Article_Number\n */\n\nimport { assertString } from '../util/assertString';\n\n/**\n * Define EAN Lenghts; 8 for EAN-8; 13 for EAN-13\n * and Regular Expression for valid EANs (EAN-8, EAN-13),\n * with exact numberic matching of 8 or 13 digits [0-9]\n */\nconst LENGTH_EAN_8 = 8;\nconst validEanRegex = /^(\\d{8}|\\d{13})$/;\n\n\n/**\n * Get position weight given:\n * EAN length and digit index/position\n *\n * @param {number} length\n * @param {number} index\n * @return {number}\n */\nfunction getPositionWeightThroughLengthAndIndex(length, index) {\n  if (length === LENGTH_EAN_8) {\n    return (index % 2 === 0) ? 3 : 1;\n  }\n\n  return (index % 2 === 0) ? 1 : 3;\n}\n\n/**\n * Calculate EAN Check Digit\n * Reference: https://en.wikipedia.org/wiki/International_Article_Number#Calculation_of_checksum_digit\n *\n * @param {string} ean\n * @return {number}\n */\nfunction calculateCheckDigit(ean) {\n  const checksum = ean\n    .slice(0, -1)\n    .split('')\n    .map((char, index) => Number(char) * getPositionWeightThroughLengthAndIndex(ean.length, index))\n    .reduce((acc, partialSum) => acc + partialSum, 0);\n\n  const remainder = 10 - (checksum % 10);\n\n  return remainder < 10 ? remainder : 0;\n}\n\n/**\n * Check if string is valid EAN:\n * Matches EAN-8/EAN-13 regex\n * Has valid check digit.\n * \n * @param target The target string\n * @return true if the `target` is a valid EAN, false otherwise\n */\n export function isEAN(target: string) {\n  assertString(target);\n  const actualCheckDigit = Number(target.slice(-1));\n\n  return validEanRegex.test(target) && actualCheckDigit === calculateCheckDigit(target);\n}\n","import { assertString } from '../util/assertString';\nimport { merge } from '../util/merge';\n\n/**\n *  IsFQDN Options\n */\nexport interface IsFQDNOptions {\n  require_tld?: boolean;\n  allow_underscores?: boolean;\n  allow_trailing_dot?: boolean;\n}\n\nconst default_fqdn_options:IsFQDNOptions = {\n  require_tld: true,\n  allow_underscores: false,\n  allow_trailing_dot: false,\n};\n\n/**\n * Checks whether the `target` string is a FQDN\n * \n * @param target The target string\n * @param options The options\n * @return true if the `target` is a FQDN, false otherwise\n */\nexport function isFQDN(str: string, options) {\n  assertString(str);\n  options = merge(options, default_fqdn_options);\n\n  /* Remove the optional trailing dot before checking validity */\n  if (options.allow_trailing_dot && str[str.length - 1] === '.') {\n    str = str.substring(0, str.length - 1);\n  }\n  const parts = str.split('.');\n  for (let i = 0; i < parts.length; i++) {\n    if (parts[i].length > 63) {\n      return false;\n    }\n  }\n  if (options.require_tld) {\n    const tld = parts.pop();\n    if (!parts.length || !/^([a-z\\u00a1-\\uffff]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {\n      return false;\n    }\n    // disallow spaces\n    if (/[\\s\\u2002-\\u200B\\u202F\\u205F\\u3000\\uFEFF\\uDB40\\uDC20]/.test(tld)) {\n      return false;\n    }\n  }\n  for (let part, i = 0; i < parts.length; i++) {\n    part = parts[i];\n    if (options.allow_underscores) {\n      part = part.replace(/_/g, '');\n    }\n    if (!/^[a-z\\u00a1-\\uffff0-9-]+$/i.test(part)) {\n      return false;\n    }\n    // disallow full-width chars\n    if (/[\\uff01-\\uff5e]/.test(part)) {\n      return false;\n    }\n    if (part[0] === '-' || part[part.length - 1] === '-') {\n      return false;\n    }\n  }\n  return true;\n}\n","import { assertString } from '../util/assertString';\n/**\n11.3.  Examples\n\n   The following addresses\n\n             fe80::1234 (on the 1st link of the node)\n             ff02::5678 (on the 5th link of the node)\n             ff08::9abc (on the 10th organization of the node)\n\n   would be represented as follows:\n\n             fe80::1234%1\n             ff02::5678%5\n             ff08::9abc%10\n\n   (Here we assume a natural translation from a zone index to the\n   <zone_id> part, where the Nth zone of any scope is translated into\n   \"N\".)\n\n   If we use interface names as <zone_id>, those addresses could also be\n   represented as follows:\n\n            fe80::1234%ne0\n            ff02::5678%pvc1.3\n            ff08::9abc%interface10\n\n   where the interface \"ne0\" belongs to the 1st link, \"pvc1.3\" belongs\n   to the 5th link, and \"interface10\" belongs to the 10th organization.\n * * */\nconst ipv4Maybe = /^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$/;\nconst ipv6Block = /^[0-9A-F]{1,4}$/i;\n\n/**\n * Checks whether the `target` string is an int\n * \n * @param target The target string\n * @param version The version\n * @return true if the `target` is an int, false otherwise\n */\nexport function isIP(str: string, version: string = '4') {\n  assertString(str);\n  version = String(version);\n  if (!version) {\n    return isIP(str, '4') || isIP(str, '6');\n  } else if (version === '4') {\n    if (!ipv4Maybe.test(str)) {\n      return false;\n    }\n    const parts = str.split('.').sort((a: any, b: any) => a - b);\n    return parseInt(parts[3]) <= 255;\n  } else if (version === '6') {\n    let addressAndZone = [str];\n    // ipv6 addresses could have scoped architecture\n    // according to https://tools.ietf.org/html/rfc4007#section-11\n    if (str.includes('%')) {\n      addressAndZone = str.split('%');\n      if (addressAndZone.length !== 2) {\n        // it must be just two parts\n        return false;\n      }\n      if (!addressAndZone[0].includes(':')) {\n        // the first part must be the address\n        return false;\n      }\n\n      if (addressAndZone[1] === '') {\n        // the second part must not be empty\n        return false;\n      }\n    }\n\n    const blocks = addressAndZone[0].split(':');\n    let foundOmissionBlock = false; // marker to indicate ::\n\n    // At least some OS accept the last 32 bits of an IPv6 address\n    // (i.e. 2 of the blocks) in IPv4 notation, and RFC 3493 says\n    // that '::ffff:a.b.c.d' is valid for IPv4-mapped IPv6 addresses,\n    // and '::a.b.c.d' is deprecated, but also valid.\n    const foundIPv4TransitionBlock = isIP(blocks[blocks.length - 1], '4');\n    const expectedNumberOfBlocks = foundIPv4TransitionBlock ? 7 : 8;\n\n    if (blocks.length > expectedNumberOfBlocks) {\n      return false;\n    }\n    // initial or final ::\n    if (str === '::') {\n      return true;\n    } else if (str.substr(0, 2) === '::') {\n      blocks.shift();\n      blocks.shift();\n      foundOmissionBlock = true;\n    } else if (str.substr(str.length - 2) === '::') {\n      blocks.pop();\n      blocks.pop();\n      foundOmissionBlock = true;\n    }\n\n    for (let i = 0; i < blocks.length; ++i) {\n      // test for a :: which can not be at the string start/end\n      // since those cases have been handled above\n      if (blocks[i] === '' && i > 0 && i < blocks.length - 1) {\n        if (foundOmissionBlock) {\n          return false; // multiple :: in address\n        }\n        foundOmissionBlock = true;\n      } else if (foundIPv4TransitionBlock && i === blocks.length - 1) {\n        // it has been checked before that the last\n        // block is a valid IPv4 address\n      } else if (!ipv6Block.test(blocks[i])) {\n        return false;\n      }\n    }\n    if (foundOmissionBlock) {\n      return blocks.length >= 1;\n    }\n    return blocks.length === expectedNumberOfBlocks;\n  }\n  return false;\n}\n","import { assertString } from '../util/assertString';\n\nimport { merge } from '../util/merge';\nimport { isByteLength } from './isByteLength';\nimport { isFQDN } from './isFQDN';\nimport { isIP } from './isIP';\n\n/**\n * IsEmail Options.\n */\nexport interface IsEmailOptions {\n  require_display_name?:boolean\n  allow_display_name?: boolean\n  allow_utf8_local_part?: boolean\n  require_tld?: boolean\n}\n\nexport const default_email_options:IsEmailOptions = {\n  require_display_name: false,\n  allow_display_name: false,\n  allow_utf8_local_part: true,\n  require_tld: true,\n}\n\n/* eslint-disable max-len */\n/* eslint-disable no-control-regex */\nconst splitNameAddress = /^([^\\x00-\\x1F\\x7F-\\x9F\\cX]+)<(.+)>$/i;\nconst emailUserPart = /^[a-z\\d!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]+$/i;\nconst gmailUserPart = /^[a-z\\d]+$/;\nconst quotedEmailUser = /^([\\s\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f\\x21\\x23-\\x5b\\x5d-\\x7e]|(\\\\[\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]))*$/i;\nconst emailUserUtf8Part = /^[a-z\\d!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]+$/i;\nconst quotedEmailUserUtf8 = /^([\\s\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f\\x21\\x23-\\x5b\\x5d-\\x7e\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]|(\\\\[\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))*$/i;\nconst defaultMaxEmailLength = 254;\n/* eslint-enable max-len */\n/* eslint-enable no-control-regex */\n\n/**\n * Validate display name according to the RFC2822: https://tools.ietf.org/html/rfc2822#appendix-A.1.2\n * @param {String} display_name\n */\nfunction validateDisplayName(display_name) {\n  const trim_quotes = display_name.match(/^\"(.+)\"$/i);\n  const display_name_without_quotes = trim_quotes ? trim_quotes[1] : display_name;\n\n  // display name with only spaces is not valid\n  if (!display_name_without_quotes.trim()) {\n    return false;\n  }\n\n  // check whether display name contains illegal character\n  const contains_illegal = /[\\.\";<>]/.test(display_name_without_quotes);\n  if (contains_illegal) {\n    // if contains illegal characters,\n    // must to be enclosed in double-quotes, otherwise it's not a valid display name\n    if (!trim_quotes) {\n      return false;\n    }\n\n    // the quotes in display name must start with character symbol \\\n    const all_start_with_back_slash =\n      display_name_without_quotes.split('\"').length === display_name_without_quotes.split('\\\\\"').length;\n    if (!all_start_with_back_slash) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n\n/**\n * Checks whether the `target` string is a valid email address\n * \n * @param target The target string\n * @param options The options\n * @return true if the `target` is a valid email address, false otherwise\n */\nexport function isEmail(str: string, options) {\n  assertString(str);\n  options = merge(options, default_email_options);\n\n  if (options.require_display_name || options.allow_display_name) {\n    const display_email = str.match(splitNameAddress);\n    if (display_email) {\n      let display_name;\n      [, display_name, str] = display_email;\n      // sometimes need to trim the last space to get the display name\n      // because there may be a space between display name and email address\n      // eg. myname <address@gmail.com>\n      // the display name is `myname` instead of `myname `, so need to trim the last space\n      if (display_name.endsWith(' ')) {\n        display_name = display_name.substr(0, display_name.length - 1);\n      }\n\n      if (!validateDisplayName(display_name)) {\n        return false;\n      }\n    } else if (options.require_display_name) {\n      return false;\n    }\n  }\n  if (!options.ignore_max_length && str.length > defaultMaxEmailLength) {\n    return false;\n  }\n\n  const parts = str.split('@');\n  const domain = parts.pop();\n  let user = parts.join('@');\n\n  const lower_domain = domain.toLowerCase();\n\n  if (options.domain_specific_validation && (lower_domain === 'gmail.com' || lower_domain === 'googlemail.com')) {\n    /*\n      Previously we removed dots for gmail addresses before validating.\n      This was removed because it allows `multiple..dots@gmail.com`\n      to be reported as valid, but it is not.\n      Gmail only normalizes single dots, removing them from here is pointless,\n      should be done in normalizeEmail\n    */\n    user = user.toLowerCase();\n\n    // Removing sub-address from username before gmail validation\n    const username = user.split('+')[0];\n\n    // Dots are not included in gmail length restriction\n    if (!isByteLength(username.replace('.', ''), { min: 6, max: 30 })) {\n      return false;\n    }\n\n    const user_parts = username.split('.');\n    for (let i = 0; i < user_parts.length; i++) {\n      if (!gmailUserPart.test(user_parts[i])) {\n        return false;\n      }\n    }\n  }\n\n  if (!isByteLength(user, { max: 64 }) ||\n    !isByteLength(domain, { max: 254 })) {\n    return false;\n  }\n\n  if (!isFQDN(domain, { require_tld: options.require_tld })) {\n    if (!options.allow_ip_domain) {\n      return false;\n    }\n\n    if (!isIP(domain)) {\n      if (!domain.startsWith('[') || !domain.endsWith(']')) {\n        return false;\n      }\n\n      let noBracketdomain = domain.substr(1, domain.length - 2);\n\n      if (noBracketdomain.length === 0 || !isIP(noBracketdomain)) {\n        return false;\n      }\n    }\n  }\n\n  if (user[0] === '\"') {\n    user = user.slice(1, user.length - 1);\n    return options.allow_utf8_local_part ?\n      quotedEmailUserUtf8.test(user) :\n      quotedEmailUser.test(user);\n  }\n\n  const pattern = options.allow_utf8_local_part ?\n    emailUserUtf8Part : emailUserPart;\n\n  const user_parts = user.split('.');\n  for (let i = 0; i < user_parts.length; i++) {\n    if (!pattern.test(user_parts[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","import { assertString } from '../util/assertString';\nimport { merge } from '../util/merge';\n\nconst default_is_empty_options = {\n  ignore_whitespace: false,\n};\n\n/**\n * Checks whether the `target` string is empty\n * \n * Note that `ignore_whitespace` is false by default.\n * \n * @param target The target string\n * @param options The options\n * @return true if the `target` is empty\n */\nexport function isEmpty(str: string, options) {\n  assertString(str);\n  options = merge(options, default_is_empty_options);\n\n  return (options.ignore_whitespace ? str.trim().length : str.length) === 0;\n}\n","import { assertString } from '../util/assertString';\n\nconst eth = /^(0x)[0-9a-f]{40}$/i;\n\n/**\n * Checks whether the `target` is an ethereum address\n * \n * @param target The target string\n * @return true if the `target` is an ethereum address\n */\nexport function isEthereumAddress(str: string) {\n  assertString(str);\n  return eth.test(str);\n}","import { assertString } from '../util/assertString';\n\nexport const fullWidth = /[^\\u0020-\\u007E\\uFF61-\\uFF9F\\uFFA0-\\uFFDC\\uFFE8-\\uFFEE0-9a-zA-Z]/;\n\n/**\n * Checks whether the `target` is full width\n * \n * @param target The target string\n * @return true if the `target` is full width, false otherwise\n */\nexport function isFullWidth(str: string) {\n  assertString(str);\n  return fullWidth.test(str);\n}\n","import { assertString } from '../util/assertString';\n\nexport const halfWidth = /[\\u0020-\\u007E\\uFF61-\\uFF9F\\uFFA0-\\uFFDC\\uFFE8-\\uFFEE0-9a-zA-Z]/;\n\n/**\n * Checks whether the `target` is half width\n * \n * @param target The target string\n * @return true if the `target` is half width, false otherwise\n */\nexport function isHalfWidth(str: string) {\n  assertString(str);\n  return halfWidth.test(str);\n}\n","import { assertString } from '../util/assertString';\n\nconst lengths = {\n  md5: 32,\n  md4: 32,\n  sha1: 40,\n  sha256: 64,\n  sha384: 96,\n  sha512: 128,\n  ripemd128: 32,\n  ripemd160: 40,\n  tiger128: 32,\n  tiger160: 40,\n  tiger192: 48,\n  crc32: 8,\n  crc32b: 8,\n};\n\n/**\n * Checks whether the `target` string is hashed using the `arg` algorithm\n * \n * @param target The target string\n * @param arg The arg\n * @return true if the `target` is hashed using the `arg` algorithm, false otherwise\n */\nexport function isHash(target: string, arg:string) {\n  assertString(target);\n  const hash = new RegExp(`^[a-fA-F0-9]{${lengths[arg]}}$`);\n  return hash.test(target);\n}\n","import { assertString } from '../util/assertString';\n\nconst hexadecimal = /^(0x|0h)?[0-9A-F]+$/i;\n\n/**\n * Checks whether the `target` is hexadecimal\n * \n * @param target The target string\n * @return true if the `target` is hexadecimal, false otherwise\n */\nexport function isHexadecimal(str: string) {\n  assertString(str);\n  return hexadecimal.test(str);\n}\n","import { assertString } from '../util/assertString';\n\nconst hexcolor = /^#?([0-9A-F]{3}|[0-9A-F]{4}|[0-9A-F]{6}|[0-9A-F]{8})$/i;\n\n/**\n * Checks whether the `target` is hexcolor\n * \n * @param target The target string\n * @return true if the `target` is hexcolor, false otherwise\n */\nexport function isHexColor(str) {\n  assertString(str);\n  return hexcolor.test(str);\n}\n","import { assertString } from '../util/assertString';\n\n\nconst hslcomma = /^(hsl)a?\\(\\s*((\\+|\\-)?([0-9]+(\\.[0-9]+)?(e(\\+|\\-)?[0-9]+)?|\\.[0-9]+(e(\\+|\\-)?[0-9]+)?))(deg|grad|rad|turn|\\s*)(\\s*,\\s*(\\+|\\-)?([0-9]+(\\.[0-9]+)?(e(\\+|\\-)?[0-9]+)?|\\.[0-9]+(e(\\+|\\-)?[0-9]+)?)%){2}\\s*(,\\s*((\\+|\\-)?([0-9]+(\\.[0-9]+)?(e(\\+|\\-)?[0-9]+)?|\\.[0-9]+(e(\\+|\\-)?[0-9]+)?)%?)\\s*)?\\)$/i;\nconst hslspace = /^(hsl)a?\\(\\s*((\\+|\\-)?([0-9]+(\\.[0-9]+)?(e(\\+|\\-)?[0-9]+)?|\\.[0-9]+(e(\\+|\\-)?[0-9]+)?))(deg|grad|rad|turn|\\s)(\\s*(\\+|\\-)?([0-9]+(\\.[0-9]+)?(e(\\+|\\-)?[0-9]+)?|\\.[0-9]+(e(\\+|\\-)?[0-9]+)?)%){2}\\s*(\\/\\s*((\\+|\\-)?([0-9]+(\\.[0-9]+)?(e(\\+|\\-)?[0-9]+)?|\\.[0-9]+(e(\\+|\\-)?[0-9]+)?)%?)\\s*)?\\)$/i;\n\n\n/**\n * Checks whether the `target` is HSL color\n * \n * @param target The target string\n * @return true if the `target` is HSL color, false otherwise\n */\nexport function isHSL(str: string) {\n  assertString(str);\n  return hslcomma.test(str) || hslspace.test(str);\n}\n","import { assertString } from '../util/assertString';\n\n/**\n * List of country codes with\n * corresponding IBAN regular expression\n * Reference: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n */\nconst ibanRegexThroughCountryCode = {\n  AD: /^(AD[0-9]{2})\\d{8}[A-Z0-9]{12}$/,\n  AE: /^(AE[0-9]{2})\\d{3}\\d{16}$/,\n  AL: /^(AL[0-9]{2})\\d{8}[A-Z0-9]{16}$/,\n  AT: /^(AT[0-9]{2})\\d{16}$/,\n  AZ: /^(AZ[0-9]{2})[A-Z0-9]{4}\\d{20}$/,\n  BA: /^(BA[0-9]{2})\\d{16}$/,\n  BE: /^(BE[0-9]{2})\\d{12}$/,\n  BG: /^(BG[0-9]{2})[A-Z]{4}\\d{6}[A-Z0-9]{8}$/,\n  BH: /^(BH[0-9]{2})[A-Z]{4}[A-Z0-9]{14}$/,\n  BR: /^(BR[0-9]{2})\\d{23}[A-Z]{1}[A-Z0-9]{1}$/,\n  BY: /^(BY[0-9]{2})[A-Z0-9]{4}\\d{20}$/,\n  CH: /^(CH[0-9]{2})\\d{5}[A-Z0-9]{12}$/,\n  CR: /^(CR[0-9]{2})\\d{18}$/,\n  CY: /^(CY[0-9]{2})\\d{8}[A-Z0-9]{16}$/,\n  CZ: /^(CZ[0-9]{2})\\d{20}$/,\n  DE: /^(DE[0-9]{2})\\d{18}$/,\n  DK: /^(DK[0-9]{2})\\d{14}$/,\n  DO: /^(DO[0-9]{2})[A-Z]{4}\\d{20}$/,\n  EE: /^(EE[0-9]{2})\\d{16}$/,\n  ES: /^(ES[0-9]{2})\\d{20}$/,\n  FI: /^(FI[0-9]{2})\\d{14}$/,\n  FO: /^(FO[0-9]{2})\\d{14}$/,\n  FR: /^(FR[0-9]{2})\\d{10}[A-Z0-9]{11}\\d{2}$/,\n  GB: /^(GB[0-9]{2})[A-Z]{4}\\d{14}$/,\n  GE: /^(GE[0-9]{2})[A-Z0-9]{2}\\d{16}$/,\n  GI: /^(GI[0-9]{2})[A-Z]{4}[A-Z0-9]{15}$/,\n  GL: /^(GL[0-9]{2})\\d{14}$/,\n  GR: /^(GR[0-9]{2})\\d{7}[A-Z0-9]{16}$/,\n  GT: /^(GT[0-9]{2})[A-Z0-9]{4}[A-Z0-9]{20}$/,\n  HR: /^(HR[0-9]{2})\\d{17}$/,\n  HU: /^(HU[0-9]{2})\\d{24}$/,\n  IE: /^(IE[0-9]{2})[A-Z0-9]{4}\\d{14}$/,\n  IL: /^(IL[0-9]{2})\\d{19}$/,\n  IQ: /^(IQ[0-9]{2})[A-Z]{4}\\d{15}$/,\n  IS: /^(IS[0-9]{2})\\d{22}$/,\n  IT: /^(IT[0-9]{2})[A-Z]{1}\\d{10}[A-Z0-9]{12}$/,\n  JO: /^(JO[0-9]{2})[A-Z]{4}\\d{22}$/,\n  KW: /^(KW[0-9]{2})[A-Z]{4}[A-Z0-9]{22}$/,\n  KZ: /^(KZ[0-9]{2})\\d{3}[A-Z0-9]{13}$/,\n  LB: /^(LB[0-9]{2})\\d{4}[A-Z0-9]{20}$/,\n  LC: /^(LC[0-9]{2})[A-Z]{4}[A-Z0-9]{24}$/,\n  LI: /^(LI[0-9]{2})\\d{5}[A-Z0-9]{12}$/,\n  LT: /^(LT[0-9]{2})\\d{16}$/,\n  LU: /^(LU[0-9]{2})\\d{3}[A-Z0-9]{13}$/,\n  LV: /^(LV[0-9]{2})[A-Z]{4}[A-Z0-9]{13}$/,\n  MC: /^(MC[0-9]{2})\\d{10}[A-Z0-9]{11}\\d{2}$/,\n  MD: /^(MD[0-9]{2})[A-Z0-9]{20}$/,\n  ME: /^(ME[0-9]{2})\\d{18}$/,\n  MK: /^(MK[0-9]{2})\\d{3}[A-Z0-9]{10}\\d{2}$/,\n  MR: /^(MR[0-9]{2})\\d{23}$/,\n  MT: /^(MT[0-9]{2})[A-Z]{4}\\d{5}[A-Z0-9]{18}$/,\n  MU: /^(MU[0-9]{2})[A-Z]{4}\\d{19}[A-Z]{3}$/,\n  NL: /^(NL[0-9]{2})[A-Z]{4}\\d{10}$/,\n  NO: /^(NO[0-9]{2})\\d{11}$/,\n  PK: /^(PK[0-9]{2})[A-Z0-9]{4}\\d{16}$/,\n  PL: /^(PL[0-9]{2})\\d{24}$/,\n  PS: /^(PS[0-9]{2})[A-Z0-9]{4}\\d{21}$/,\n  PT: /^(PT[0-9]{2})\\d{21}$/,\n  QA: /^(QA[0-9]{2})[A-Z]{4}[A-Z0-9]{21}$/,\n  RO: /^(RO[0-9]{2})[A-Z]{4}[A-Z0-9]{16}$/,\n  RS: /^(RS[0-9]{2})\\d{18}$/,\n  SA: /^(SA[0-9]{2})\\d{2}[A-Z0-9]{18}$/,\n  SC: /^(SC[0-9]{2})[A-Z]{4}\\d{20}[A-Z]{3}$/,\n  SE: /^(SE[0-9]{2})\\d{20}$/,\n  SI: /^(SI[0-9]{2})\\d{15}$/,\n  SK: /^(SK[0-9]{2})\\d{20}$/,\n  SM: /^(SM[0-9]{2})[A-Z]{1}\\d{10}[A-Z0-9]{12}$/,\n  TL: /^(TL[0-9]{2})\\d{19}$/,\n  TN: /^(TN[0-9]{2})\\d{20}$/,\n  TR: /^(TR[0-9]{2})\\d{5}[A-Z0-9]{17}$/,\n  UA: /^(UA[0-9]{2})\\d{6}[A-Z0-9]{19}$/,\n  VA: /^(VA[0-9]{2})\\d{18}$/,\n  VG: /^(VG[0-9]{2})[A-Z0-9]{4}\\d{16}$/,\n  XK: /^(XK[0-9]{2})\\d{16}$/,\n};\n\n/**\n * Check whether string has correct universal IBAN format\n * The IBAN consists of up to 34 alphanumeric characters, as follows:\n * Country Code using ISO 3166-1 alpha-2, two letters\n * check digits, two digits and\n * Basic Bank Account Number (BBAN), up to 30 alphanumeric characters.\n * NOTE: Permitted IBAN characters are: digits [0-9] and the 26 latin alphabetic [A-Z]\n *\n * @param {string} str - string under validation\n * @return {boolean}\n */\nfunction hasValidIbanFormat(str) {\n  // Strip white spaces and hyphens, keep only digits and A-Z latin alphabetic\n  const strippedStr = str.replace(/[^A-Z0-9]+/gi, '').toUpperCase();\n  const isoCountryCode = strippedStr.slice(0, 2).toUpperCase();\n\n  return (isoCountryCode in ibanRegexThroughCountryCode) &&\n    ibanRegexThroughCountryCode[isoCountryCode].test(strippedStr);\n}\n\n/**\n   * Check whether string has valid IBAN Checksum\n   * by performing basic mod-97 operation and\n   * the remainder should equal 1\n   * -- Start by rearranging the IBAN by moving the four initial characters to the end of the string\n   * -- Replace each letter in the string with two digits, A -> 10, B = 11, Z = 35\n   * -- Interpret the string as a decimal integer and\n   * -- compute the remainder on division by 97 (mod 97)\n   * Reference: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n   *\n   * @param target The target string\n   * @return true if the string has a valid IBAN checksum, false otherwise\n   */\nfunction hasValidIbanChecksum(target) {\n  const strippedStr = target.replace(/[^A-Z0-9]+/gi, '').toUpperCase(); // Keep only digits and A-Z latin alphabetic\n  const rearranged = strippedStr.slice(4) + strippedStr.slice(0, 4);\n  const alphaCapsReplacedWithDigits = rearranged.replace(/[A-Z]/g, char => char.charCodeAt(0) - 55);\n\n  const remainder = alphaCapsReplacedWithDigits.match(/\\d{1,7}/g)\n    .reduce((acc, value) => Number(acc + value) % 97, '');\n\n  return remainder === 1;\n}\n/**\n * Checks whether the IBAN number has a valid format and checksum.\n * \n * @param target The target string\n * @return true if the target has a valid format and checksum, false otherwise\n */\nexport function isIBAN(target: string) {\n  assertString(target);\n\n  return hasValidIbanFormat(target) && hasValidIbanChecksum(target);\n}\n","import { assertString } from '../util/assertString';\n\nconst validators = {\n  ES: (str) => {\n    assertString(str);\n\n    const DNI = /^[0-9X-Z][0-9]{7}[TRWAGMYFPDXBNJZSQVHLCKE]$/;\n\n    const charsValue = {\n      X: 0,\n      Y: 1,\n      Z: 2,\n    };\n\n    const controlDigits = [\n      'T', 'R', 'W', 'A', 'G', 'M', 'Y', 'F', 'P', 'D', 'X', 'B',\n      'N', 'J', 'Z', 'S', 'Q', 'V', 'H', 'L', 'C', 'K', 'E',\n    ];\n\n    // sanitize user input\n    const sanitized = str.trim().toUpperCase();\n\n    // validate the data structure\n    if (!DNI.test(sanitized)) {\n      return false;\n    }\n\n    // validate the control digit\n    const number = sanitized.slice(0, -1).replace(/[X,Y,Z]/g, char => charsValue[char]);\n\n    return sanitized.endsWith(controlDigits[number % 23]);\n  },\n  'he-IL': (str) => {\n    const DNI = /^\\d{9}$/;\n\n    // sanitize user input\n    const sanitized = str.trim();\n\n    // validate the data structure\n    if (!DNI.test(sanitized)) {\n      return false;\n    }\n\n    const id = sanitized;\n\n    let sum = 0,\n      incNum;\n    for (let i = 0; i < id.length; i++) {\n      incNum = Number(id[i]) * ((i % 2) + 1); // Multiply number by 1 or 2\n      sum += incNum > 9 ? incNum - 9 : incNum; // Sum the digits up and add to total\n    }\n    return sum % 10 === 0;\n  },\n  'zh-TW': (str) => {\n    const ALPHABET_CODES = {\n      A: 10,\n      B: 11,\n      C: 12,\n      D: 13,\n      E: 14,\n      F: 15,\n      G: 16,\n      H: 17,\n      I: 34,\n      J: 18,\n      K: 19,\n      L: 20,\n      M: 21,\n      N: 22,\n      O: 35,\n      P: 23,\n      Q: 24,\n      R: 25,\n      S: 26,\n      T: 27,\n      U: 28,\n      V: 29,\n      W: 32,\n      X: 30,\n      Y: 31,\n      Z: 33,\n    };\n\n    const sanitized = str.trim().toUpperCase();\n\n    if (!/^[A-Z][0-9]{9}$/.test(sanitized)) return false;\n\n    return Array.from(sanitized).reduce((sum: number, num: number, index: number) => {\n      if (index === 0) {\n        const code = ALPHABET_CODES[num];\n\n        return ((code % 10) * 9) + Math.floor(code / 10);\n      }\n\n      if (index === 9) {\n        return ((10 - (sum % 10)) - Number(num)) % 10 === 0;\n      }\n\n      return sum + (Number(num) * (9 - index));\n    }, 0);\n  },\n};\n\n/**\n * Check if the string is an identity card\n * @param target The target string\n * @param arg The arg\n */\nexport function isIdentityCard(target: string, arg: string) {\n  assertString(target);\n  if (arg in validators) {\n    return validators[arg](target);\n  } else if (arg === 'any') {\n    for (const key in validators) {\n      // https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md#ignoring-code-for-coverage-purposes\n      // istanbul ignore else\n      if (validators.hasOwnProperty(key)) {\n        const validator = validators[key];\n        if (validator(target)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  throw new Error(`Invalid locale '${arg}'`);\n}","import { assertString } from '../util/assertString';\n\nconst int = /^(?:[-+]?(?:0|[1-9][0-9]*))$/;\nconst intLeadingZeroes = /^[-+]?[0-9]+$/;\n\n/**\n * Checks whether the `target` string is an int\n * \n * @param target The target string\n * @param options The options\n * @return true if the `target` is an int, false otherwise\n */\nexport function isInt(str: string, options) {\n  assertString(str);\n  options = options || {};\n\n  // Get the regex to use for testing, based on whether\n  // leading zeroes are allowed or not.\n  let regex = (\n    options.hasOwnProperty('allow_leading_zeroes') && !options.allow_leading_zeroes ?\n      int : intLeadingZeroes\n  );\n\n  // Check min/max/lt/gt\n  let minCheckPassed = (!options.hasOwnProperty('min') || str >= options.min);\n  let maxCheckPassed = (!options.hasOwnProperty('max') || str <= options.max);\n  let ltCheckPassed = (!options.hasOwnProperty('lt') || str < options.lt);\n  let gtCheckPassed = (!options.hasOwnProperty('gt') || str > options.gt);\n\n  return regex.test(str) && minCheckPassed && maxCheckPassed && ltCheckPassed && gtCheckPassed;\n}\n","import { assertString } from '../util/assertString';\n\nconst isbn10Maybe = /^(?:[0-9]{9}X|[0-9]{10})$/;\nconst isbn13Maybe = /^(?:[0-9]{13})$/;\nconst factor = [1, 3];\n\n/**\n * Test whether the target string is an ISBN number.\n * \n * @param target The string\n * @param arg The ISBN version\n * @return true if the `target` string is an ISBN number, false otherwise\n */\nexport function isISBN(target: string, arg: string = '') {\n  assertString(target);\n  arg = String(arg);\n  if (!arg) {\n    return isISBN(target, '10') || isISBN(target, '13');\n  }\n  const sanitized: string = target.replace(/[\\s-]+/g, '');\n  let checksum = 0;\n  let i;\n  if (arg === '10') {\n    if (!isbn10Maybe.test(sanitized)) {\n      return false;\n    }\n    for (i = 0; i < 9; i++) {\n      checksum += (i + 1) * parseInt(sanitized.charAt(i));\n    }\n    if (sanitized.charAt(9) === 'X') {\n      checksum += 10 * 10;\n    } else {\n      checksum += 10 * parseInt(sanitized.charAt(9));\n    }\n    if ((checksum % 11) === 0) {\n      return !!sanitized;\n    }\n  } else if (arg === '13') {\n    if (!isbn13Maybe.test(sanitized)) {\n      return false;\n    }\n    for (i = 0; i < 12; i++) {\n      checksum += factor[i % 2] * parseInt(sanitized.charAt(i));\n    }\n    if (parseInt(sanitized.charAt(12)) - ((10 - (checksum % 10)) % 10) === 0) {\n      return !!sanitized;\n    }\n  }\n  return false;\n}","import { assertString } from '../util/assertString';\n\nconst isin = /^[A-Z]{2}[0-9A-Z]{9}[0-9]$/;\n\n\n/**\n * Test whether the target string is an ISBN number.\n * \n * @param target The string\n * @return true if the `target` string is an ISIN number, false otherwise\n */\nexport function isISIN(target:string) {\n  assertString(target);\n  if (!isin.test(target)) {\n    return false;\n  }\n\n  const checksumStr = target.replace(/[A-Z]/g, character => {\n    const intValue = (parseInt(character, 36))\n    return intValue ? intValue.toString() : ''\n  });\n\n  let sum = 0;\n  let digit;\n  let tmpNum;\n  let shouldDouble = true;\n  for (let i = checksumStr.length - 2; i >= 0; i--) {\n    digit = checksumStr.substring(i, (i + 1));\n    tmpNum = parseInt(digit, 10);\n    if (shouldDouble) {\n      tmpNum *= 2;\n      if (tmpNum >= 10) {\n        sum += tmpNum + 1;\n      } else {\n        sum += tmpNum;\n      }\n    } else {\n      sum += tmpNum;\n    }\n    shouldDouble = !shouldDouble;\n  }\n\n  return parseInt(target.substr(target.length - 1), 10) === (10000 - sum) % 10;\n}\n","import { assertString } from '../util/assertString';\n\n/* eslint-disable max-len */\n// from http://goo.gl/0ejHHW\nconst iso8601 = /^([\\+-]?\\d{4}(?!\\d{2}\\b))((-?)((0[1-9]|1[0-2])(\\3([12]\\d|0[1-9]|3[01]))?|W([0-4]\\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\\d|[12]\\d{2}|3([0-5]\\d|6[1-6])))([T\\s]((([01]\\d|2[0-3])((:?)[0-5]\\d)?|24:?00)([\\.,]\\d+(?!:))?)?(\\17[0-5]\\d([\\.,]\\d+)?)?([zZ]|([\\+-])([01]\\d|2[0-3]):?([0-5]\\d)?)?)?)?$/;\n/* eslint-enable max-len */\nconst isValidDate = (str) => {\n  // str must have passed the ISO8601 check\n  // this check is meant to catch invalid dates\n  // like 2009-02-31\n  // first check for ordinal dates\n  const ordinalMatch = str.match(/^(\\d{4})-?(\\d{3})([ T]{1}\\.*|$)/);\n  if (ordinalMatch) {\n    const oYear = Number(ordinalMatch[1]);\n    const oDay = Number(ordinalMatch[2]);\n    // if is leap year\n    if ((oYear % 4 === 0 && oYear % 100 !== 0) || oYear % 400 === 0) return oDay <= 366;\n    return oDay <= 365;\n  }\n  const match = str.match(/(\\d{4})-?(\\d{0,2})-?(\\d*)/).map(Number);\n  const year = match[1];\n  const month = match[2];\n  const day = match[3];\n  const monthString = month ? `0${month}`.slice(-2) : month;\n  const dayString = day ? `0${day}`.slice(-2) : day;\n\n  // create a date object and compare\n  const d = new Date(`${year}-${monthString || '01'}-${dayString || '01'}`);\n  if (month && day) {\n    return d.getUTCFullYear() === year\n      && (d.getUTCMonth() + 1) === month\n      && d.getUTCDate() === day;\n  }\n  return true;\n}\n\n\n/**\n * Checks whether the `target` string is a valid ISO8601 date\n * \n * @param target The target string\n * @param options The options\n * @return true if the `target` is a valid ISO8601 date, false otherwise\n */\nexport function isISO8601(str, options?) {\n  assertString(str);\n  const check = iso8601.test(str);\n  if (!options) return check;\n  if (check && options.strict) return isValidDate(str);\n  return check;\n}\n","import { assertString } from '../util/assertString';\nimport { includes } from '../util/includes';\n\n// from https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2\nconst validISO31661Alpha2CountriesCodes = [\n  'AD', 'AE', 'AF', 'AG', 'AI', 'AL', 'AM', 'AO', 'AQ', 'AR', 'AS', 'AT', 'AU', 'AW', 'AX', 'AZ',\n  'BA', 'BB', 'BD', 'BE', 'BF', 'BG', 'BH', 'BI', 'BJ', 'BL', 'BM', 'BN', 'BO', 'BQ', 'BR', 'BS', 'BT', 'BV', 'BW', 'BY', 'BZ',\n  'CA', 'CC', 'CD', 'CF', 'CG', 'CH', 'CI', 'CK', 'CL', 'CM', 'CN', 'CO', 'CR', 'CU', 'CV', 'CW', 'CX', 'CY', 'CZ',\n  'DE', 'DJ', 'DK', 'DM', 'DO', 'DZ',\n  'EC', 'EE', 'EG', 'EH', 'ER', 'ES', 'ET',\n  'FI', 'FJ', 'FK', 'FM', 'FO', 'FR',\n  'GA', 'GB', 'GD', 'GE', 'GF', 'GG', 'GH', 'GI', 'GL', 'GM', 'GN', 'GP', 'GQ', 'GR', 'GS', 'GT', 'GU', 'GW', 'GY',\n  'HK', 'HM', 'HN', 'HR', 'HT', 'HU',\n  'ID', 'IE', 'IL', 'IM', 'IN', 'IO', 'IQ', 'IR', 'IS', 'IT',\n  'JE', 'JM', 'JO', 'JP',\n  'KE', 'KG', 'KH', 'KI', 'KM', 'KN', 'KP', 'KR', 'KW', 'KY', 'KZ',\n  'LA', 'LB', 'LC', 'LI', 'LK', 'LR', 'LS', 'LT', 'LU', 'LV', 'LY',\n  'MA', 'MC', 'MD', 'ME', 'MF', 'MG', 'MH', 'MK', 'ML', 'MM', 'MN', 'MO', 'MP', 'MQ', 'MR', 'MS', 'MT', 'MU', 'MV', 'MW', 'MX', 'MY', 'MZ',\n  'NA', 'NC', 'NE', 'NF', 'NG', 'NI', 'NL', 'NO', 'NP', 'NR', 'NU', 'NZ',\n  'OM',\n  'PA', 'PE', 'PF', 'PG', 'PH', 'PK', 'PL', 'PM', 'PN', 'PR', 'PS', 'PT', 'PW', 'PY',\n  'QA',\n  'RE', 'RO', 'RS', 'RU', 'RW',\n  'SA', 'SB', 'SC', 'SD', 'SE', 'SG', 'SH', 'SI', 'SJ', 'SK', 'SL', 'SM', 'SN', 'SO', 'SR', 'SS', 'ST', 'SV', 'SX', 'SY', 'SZ',\n  'TC', 'TD', 'TF', 'TG', 'TH', 'TJ', 'TK', 'TL', 'TM', 'TN', 'TO', 'TR', 'TT', 'TV', 'TW', 'TZ',\n  'UA', 'UG', 'UM', 'US', 'UY', 'UZ',\n  'VA', 'VC', 'VE', 'VG', 'VI', 'VN', 'VU',\n  'WF', 'WS',\n  'YE', 'YT',\n  'ZA', 'ZM', 'ZW',\n];\n\n/**\n * Check whether the `target` string is a valid \n * ISO 3166-1 alpha-2 officially assigned country code\n * \n * @param target The target string\n * @return true if the `target` is a valid is a valid ISO 3166-1 alpha-2 officially assigned country code, false otherwise\n */\nexport function isISO31661Alpha2(target:string) {\n  assertString(target);\n  return includes(validISO31661Alpha2CountriesCodes, target.toUpperCase());\n}\n","import { assertString } from '../util/assertString';\nimport { includes } from '../util/includes';\n\n// from https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3\nconst validISO31661Alpha3CountriesCodes = [\n  'AFG', 'ALA', 'ALB', 'DZA', 'ASM', 'AND', 'AGO', 'AIA', 'ATA', 'ATG', 'ARG', 'ARM', 'ABW', 'AUS', 'AUT', 'AZE',\n  'BHS', 'BHR', 'BGD', 'BRB', 'BLR', 'BEL', 'BLZ', 'BEN', 'BMU', 'BTN', 'BOL', 'BES', 'BIH', 'BWA', 'BVT', 'BRA',\n  'IOT', 'BRN', 'BGR', 'BFA', 'BDI', 'KHM', 'CMR', 'CAN', 'CPV', 'CYM', 'CAF', 'TCD', 'CHL', 'CHN', 'CXR', 'CCK',\n  'COL', 'COM', 'COG', 'COD', 'COK', 'CRI', 'CIV', 'HRV', 'CUB', 'CUW', 'CYP', 'CZE', 'DNK', 'DJI', 'DMA', 'DOM',\n  'ECU', 'EGY', 'SLV', 'GNQ', 'ERI', 'EST', 'ETH', 'FLK', 'FRO', 'FJI', 'FIN', 'FRA', 'GUF', 'PYF', 'ATF', 'GAB',\n  'GMB', 'GEO', 'DEU', 'GHA', 'GIB', 'GRC', 'GRL', 'GRD', 'GLP', 'GUM', 'GTM', 'GGY', 'GIN', 'GNB', 'GUY', 'HTI',\n  'HMD', 'VAT', 'HND', 'HKG', 'HUN', 'ISL', 'IND', 'IDN', 'IRN', 'IRQ', 'IRL', 'IMN', 'ISR', 'ITA', 'JAM', 'JPN',\n  'JEY', 'JOR', 'KAZ', 'KEN', 'KIR', 'PRK', 'KOR', 'KWT', 'KGZ', 'LAO', 'LVA', 'LBN', 'LSO', 'LBR', 'LBY', 'LIE',\n  'LTU', 'LUX', 'MAC', 'MKD', 'MDG', 'MWI', 'MYS', 'MDV', 'MLI', 'MLT', 'MHL', 'MTQ', 'MRT', 'MUS', 'MYT', 'MEX',\n  'FSM', 'MDA', 'MCO', 'MNG', 'MNE', 'MSR', 'MAR', 'MOZ', 'MMR', 'NAM', 'NRU', 'NPL', 'NLD', 'NCL', 'NZL', 'NIC',\n  'NER', 'NGA', 'NIU', 'NFK', 'MNP', 'NOR', 'OMN', 'PAK', 'PLW', 'PSE', 'PAN', 'PNG', 'PRY', 'PER', 'PHL', 'PCN',\n  'POL', 'PRT', 'PRI', 'QAT', 'REU', 'ROU', 'RUS', 'RWA', 'BLM', 'SHN', 'KNA', 'LCA', 'MAF', 'SPM', 'VCT', 'WSM',\n  'SMR', 'STP', 'SAU', 'SEN', 'SRB', 'SYC', 'SLE', 'SGP', 'SXM', 'SVK', 'SVN', 'SLB', 'SOM', 'ZAF', 'SGS', 'SSD',\n  'ESP', 'LKA', 'SDN', 'SUR', 'SJM', 'SWZ', 'SWE', 'CHE', 'SYR', 'TWN', 'TJK', 'TZA', 'THA', 'TLS', 'TGO', 'TKL',\n  'TON', 'TTO', 'TUN', 'TUR', 'TKM', 'TCA', 'TUV', 'UGA', 'UKR', 'ARE', 'GBR', 'USA', 'UMI', 'URY', 'UZB', 'VUT',\n  'VEN', 'VNM', 'VGB', 'VIR', 'WLF', 'ESH', 'YEM', 'ZMB', 'ZWE',\n];\n\n/**\n * Check whether the `target` string is a valid \n * ISO 3166-1 alpha-3 officially assigned country code\n * \n * @param target The target string\n * @return true if the `target` is a valid is a valid ISO 3166-1 alpha-2 officially assigned country code, false otherwise\n */\nexport function isISO31661Alpha3(target:string) {\n  assertString(target);\n  return includes(validISO31661Alpha3CountriesCodes, target.toUpperCase());\n}\n","import { assertString } from '../util/assertString';\n\n// see http://isrc.ifpi.org/en/isrc-standard/code-syntax\nconst isrc = /^[A-Z]{2}[0-9A-Z]{3}\\d{2}\\d{5}$/;\n\n\n/**\n * Checks whether the `target` string is a valid ISRC\n * \n * @param target The target string\n * @return true if the `target` is a valid ISRC, false otherwise\n */\nexport function isISRC(target:string) {\n  assertString(target);\n  return isrc.test(target);\n}\n","import { assertString } from '../util/assertString';\n\nconst jwt = /^([A-Za-z0-9\\-_~+\\/]+[=]{0,2})\\.([A-Za-z0-9\\-_~+\\/]+[=]{0,2})(?:\\.([A-Za-z0-9\\-_~+\\/]+[=]{0,2}))?$/;\n\n/**\n * Checks whether the `target` string is a valid JWT\n * \n * @param target The target string\n * @return true if the `target` is a valid JWT, false otherwise\n */\nexport function isJWT(target:string) {\n  assertString(target);\n  return jwt.test(target);\n}\n","import { assertString } from '../util/assertString';\n\nconst lat = /^\\(?[+-]?(90(\\.0+)?|[1-8]?\\d(\\.\\d+)?)$/;\nconst long = /^\\s?[+-]?(180(\\.0+)?|1[0-7]\\d(\\.\\d+)?|\\d{1,2}(\\.\\d+)?)\\)?$/;\n\n/**\n * Checks whether the `target` string is a valid LatLong\n * \n * @param target The target string\n * @return true if the `target` is a valid LatLong, false otherwise\n */\nexport function isLatLong(target:string) {\n  assertString(target);\n  if (!target.includes(',')) return false;\n  const pair = target.split(',');\n  if ((pair[0].startsWith('(') && !pair[1].endsWith(')'))\n    || (pair[1].endsWith(')') && !pair[0].startsWith('('))) return false;\n  return lat.test(pair[0]) && long.test(pair[1]);\n}\n","import { assertString } from '../util/assertString';\n\nconst localeReg = /^[A-z]{2,4}([_-]([A-z]{4}|[\\d]{3}))?([_-]([A-z]{2}|[\\d]{3}))?$/;\n\n/**\n * Checks whether the `target` string is a valid locale\n * \n * @param target The target string\n * @return true if the `target` is a valid locale, false otherwise\n */\nexport function isLocale(target:string) {\n  assertString(target);\n  if (target === 'en_US_POSIX' || target === 'ca_ES_VALENCIA') {\n    return true;\n  }\n  return localeReg.test(target);\n}\n","import { assertString } from '../util/assertString';\n\nconst macAddress = /^([0-9a-fA-F][0-9a-fA-F]:){5}([0-9a-fA-F][0-9a-fA-F])$/;\nconst macAddressNoColons = /^([0-9a-fA-F]){12}$/;\nconst macAddressWithHyphen = /^([0-9a-fA-F][0-9a-fA-F]-){5}([0-9a-fA-F][0-9a-fA-F])$/;\nconst macAddressWithSpaces = /^([0-9a-fA-F][0-9a-fA-F]\\s){5}([0-9a-fA-F][0-9a-fA-F])$/;\n\n/**\n * Checks whether the `target` string is a valid MAC Address\n * \n * @param target The target string\n * @param options The options\n * @return true if the `target` is a valid Mac Address, false otherwise\n */\nexport function isMACAddress(target:string, options) {\n  assertString(target);\n  if (options && options.no_colons) {\n    return macAddressNoColons.test(target);\n  }\n  return macAddress.test(target) || macAddressWithHyphen.test(target) || macAddressWithSpaces.test(target);\n}\n","import { assertString } from '../util/assertString';\n\nconst magnetURI = /^magnet:\\?xt=urn:[a-z0-9]+:[a-z0-9]{32,40}&dn=.+&tr=.+$/i;\n\n/**\n * Checks whether the `target` string is a valid Magnet URI\n * \n * @param target The target string\n * @return true if the `target` is a valid Magnet URI, false otherwise\n */\nexport function isMagnetURI(target:string) {\n  assertString(target);\n  return magnetURI.test(target.trim());\n}\n","import { assertString } from '../util/assertString';\n\nconst md5 = /^[a-f0-9]{32}$/;\n\n/**\n * Checks whether the `target` string is a valid MD5 checksum\n * \n * @param target The target string\n * @return true if the `target` is a valid MD5 checksum, false otherwise\n */\nexport function isMD5(target:string) {\n  assertString(target);\n  return md5.test(target);\n}\n","import { assertString } from '../util/assertString';\n\n/*\n  Checks if the provided string matches to a correct Media type format (MIME type)\n\n  This function only checks is the string format follows the\n  etablished rules by the according RFC specifications.\n  This function supports 'charset' in textual media types\n  (https://tools.ietf.org/html/rfc6657).\n\n  This function does not check against all the media types listed\n  by the IANA (https://www.iana.org/assignments/media-types/media-types.xhtml)\n  because of lightness purposes : it would require to include\n  all these MIME types in this librairy, which would weigh it\n  significantly. This kind of effort maybe is not worth for the use that\n  this function has in this entire librairy.\n\n  More informations in the RFC specifications :\n  - https://tools.ietf.org/html/rfc2045\n  - https://tools.ietf.org/html/rfc2046\n  - https://tools.ietf.org/html/rfc7231#section-3.1.1.1\n  - https://tools.ietf.org/html/rfc7231#section-3.1.1.5\n*/\n\n// Match simple MIME types\n// NB :\n//   Subtype length must not exceed 100 characters.\n//   This rule does not comply to the RFC specs (what is the max length ?).\nconst mimeTypeSimple = /^(application|audio|font|image|message|model|multipart|text|video)\\/[a-zA-Z0-9\\.\\-\\+]{1,100}$/i; // eslint-disable-line max-len\n\n// Handle \"charset\" in \"text/*\"\nconst mimeTypeText = /^text\\/[a-zA-Z0-9\\.\\-\\+]{1,100};\\s?charset=(\"[a-zA-Z0-9\\.\\-\\+\\s]{0,70}\"|[a-zA-Z0-9\\.\\-\\+]{0,70})(\\s?\\([a-zA-Z0-9\\.\\-\\+\\s]{1,20}\\))?$/i; // eslint-disable-line max-len\n\n// Handle \"boundary\" in \"multipart/*\"\nconst mimeTypeMultipart = /^multipart\\/[a-zA-Z0-9\\.\\-\\+]{1,100}(;\\s?(boundary|charset)=(\"[a-zA-Z0-9\\.\\-\\+\\s]{0,70}\"|[a-zA-Z0-9\\.\\-\\+]{0,70})(\\s?\\([a-zA-Z0-9\\.\\-\\+\\s]{1,20}\\))?){0,2}$/i; // eslint-disable-line max-len\n\n/**\n * Checks whether the `target` string is a valid Mime Type\n * \n * @param target The target string\n * @return true if the `target` is a valid Mime Type, false otherwise\n */\nexport function isMimeType(str) {\n  assertString(str);\n  return mimeTypeSimple.test(str) || mimeTypeText.test(str) || mimeTypeMultipart.test(str);\n}","import { assertString } from '../util/assertString'\n\n/**\n * Mobile Phone Local Type.\n * \n * TODO: \n * We added \n * 'en-CA'\n * 'fr-BE'\n * 'zh-HK'\n * And these don't have regex support yet.\n */\nexport type MobilePhoneLocale =\n| 'am-AM'\n| 'ar-AE'\n| 'ar-BH'\n| 'ar-DZ'\n| 'ar-EG'\n| 'ar-IQ'\n| 'ar-JO'\n| 'ar-KW'\n| 'ar-SA'\n| 'ar-SY'\n| 'ar-TN'\n| 'be-BY'\n| 'bg-BG'\n| 'bn-BD'\n| 'cs-CZ'\n| 'da-DK'\n| 'de-DE'\n| 'de-AT'\n| 'el-GR'\n| 'en-AU'\n| 'en-GB'\n| 'en-GG'\n| 'en-GH'\n| 'en-HK'\n| 'en-IE'\n| 'en-MO'\n| 'en-IN'\n| 'en-KE'\n| 'en-MT'\n| 'en-MU'\n| 'en-NG'\n| 'en-NZ'\n| 'en-PK'\n| 'en-RW'\n| 'en-SG'\n| 'en-TZ'\n| 'en-UG'\n| 'en-US'\n| 'en-ZA'\n| 'en-ZM'\n| 'es-CL'\n| 'es-ES'\n| 'es-MX'\n| 'es-PA'\n| 'es-PY'\n| 'es-UY'\n| 'et-EE'\n| 'fa-IR'\n| 'fi-FI'\n| 'fj-FJ'\n| 'fo-FO'\n| 'fr-FR'\n| 'fr-GF'\n| 'fr-GP'\n| 'fr-MQ'\n| 'fr-RE'\n| 'he-IL'\n| 'hu-HU'\n| 'id-ID'\n| 'it-IT'\n| 'ja-JP'\n| 'kk-KZ'\n| 'kl-GL'\n| 'ko-KR'\n| 'lt-LT'\n| 'ms-MY'\n| 'nb-NO'\n| 'nl-BE'\n| 'ne-NP'\n| 'nl-NL'\n| 'nn-NO'\n| 'pl-PL'\n| 'pt-BR'\n| 'pt-PT'\n| 'ro-RO'\n| 'ru-RU'\n| 'sl-SI'\n| 'sk-SK'\n| 'sr-RS'\n| 'sv-SE'\n| 'th-TH'\n| 'tr-TR'\n| 'uk-UA'\n| 'vi-VN'\n| 'zh-CN'\n| 'zh-TW'\n| 'en-CA'\n| 'fr-BE'\n| 'zh-HK'\n\n/* eslint-disable max-len */\nconst phones = {\n  'am-AM': /^(\\+?374|0)((10|[9|7][0-9])\\d{6}$|[2-4]\\d{7}$)/,\n  'ar-AE': /^((\\+?971)|0)?5[024568]\\d{7}$/,\n  'ar-BH': /^(\\+?973)?(3|6)\\d{7}$/,\n  'ar-DZ': /^(\\+?213|0)(5|6|7)\\d{8}$/,\n  'ar-EG': /^((\\+?20)|0)?1[0125]\\d{8}$/,\n  'ar-IQ': /^(\\+?964|0)?7[0-9]\\d{8}$/,\n  'ar-JO': /^(\\+?962|0)?7[789]\\d{7}$/,\n  'ar-KW': /^(\\+?965)[569]\\d{7}$/,\n  'ar-SA': /^(!?(\\+?966)|0)?5\\d{8}$/,\n  'ar-SY': /^(!?(\\+?963)|0)?9\\d{8}$/,\n  'ar-TN': /^(\\+?216)?[2459]\\d{7}$/,\n  'be-BY': /^(\\+?375)?(24|25|29|33|44)\\d{7}$/,\n  'bg-BG': /^(\\+?359|0)?8[789]\\d{7}$/,\n  'bn-BD': /^(\\+?880|0)1[13456789][0-9]{8}$/,\n  'cs-CZ': /^(\\+?420)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,\n  'da-DK': /^(\\+?45)?\\s?\\d{2}\\s?\\d{2}\\s?\\d{2}\\s?\\d{2}$/,\n  'de-DE': /^(\\+49)?0?1(5[0-25-9]\\d|6([23]|0\\d?)|7([0-57-9]|6\\d))\\d{7}$/,\n  'de-AT': /^(\\+43|0)\\d{1,4}\\d{3,12}$/,\n  'el-GR': /^(\\+?30|0)?(69\\d{8})$/,\n  'en-AU': /^(\\+?61|0)4\\d{8}$/,\n  'en-GB': /^(\\+?44|0)7\\d{9}$/,\n  'en-GG': /^(\\+?44|0)1481\\d{6}$/,\n  'en-GH': /^(\\+233|0)(20|50|24|54|27|57|26|56|23|28)\\d{7}$/,\n  'en-HK': /^(\\+?852[-\\s]?)?[456789]\\d{3}[-\\s]?\\d{4}$/,\n  'en-MO': /^(\\+?853[-\\s]?)?[6]\\d{3}[-\\s]?\\d{4}$/,\n  'en-IE': /^(\\+?353|0)8[356789]\\d{7}$/,\n  'en-IN': /^(\\+?91|0)?[6789]\\d{9}$/,\n  'en-KE': /^(\\+?254|0)(7|1)\\d{8}$/,\n  'en-MT': /^(\\+?356|0)?(99|79|77|21|27|22|25)[0-9]{6}$/,\n  'en-MU': /^(\\+?230|0)?\\d{8}$/,\n  'en-NG': /^(\\+?234|0)?[789]\\d{9}$/,\n  'en-NZ': /^(\\+?64|0)[28]\\d{7,9}$/,\n  'en-PK': /^((\\+92)|(0092))-{0,1}\\d{3}-{0,1}\\d{7}$|^\\d{11}$|^\\d{4}-\\d{7}$/,\n  'en-RW': /^(\\+?250|0)?[7]\\d{8}$/,\n  'en-SG': /^(\\+65)?[89]\\d{7}$/,\n  'en-TZ': /^(\\+?255|0)?[67]\\d{8}$/,\n  'en-UG': /^(\\+?256|0)?[7]\\d{8}$/,\n  'en-US': /^((\\+1|1)?( |-)?)?(\\([2-9][0-9]{2}\\)|[2-9][0-9]{2})( |-)?([2-9][0-9]{2}( |-)?[0-9]{4})$/,\n  'en-ZA': /^(\\+?27|0)\\d{9}$/,\n  'en-ZM': /^(\\+?26)?09[567]\\d{7}$/,\n  'es-CL': /^(\\+?56|0)[2-9]\\d{1}\\d{7}$/,\n  'es-EC': /^(\\+?593|0)([2-7]|9[2-9])\\d{7}$/,\n  'es-ES': /^(\\+?34)?(6\\d{1}|7[1234])\\d{7}$/,\n  'es-MX': /^(\\+?52)?(1|01)?\\d{10,11}$/,\n  'es-PA': /^(\\+?507)\\d{7,8}$/,\n  'es-PY': /^(\\+?595|0)9[9876]\\d{7}$/,\n  'es-UY': /^(\\+598|0)9[1-9][\\d]{6}$/,\n  'et-EE': /^(\\+?372)?\\s?(5|8[1-4])\\s?([0-9]\\s?){6,7}$/,\n  'fa-IR': /^(\\+?98[\\-\\s]?|0)9[0-39]\\d[\\-\\s]?\\d{3}[\\-\\s]?\\d{4}$/,\n  'fi-FI': /^(\\+?358|0)\\s?(4(0|1|2|4|5|6)?|50)\\s?(\\d\\s?){4,8}\\d$/,\n  'fj-FJ': /^(\\+?679)?\\s?\\d{3}\\s?\\d{4}$/,\n  'fo-FO': /^(\\+?298)?\\s?\\d{2}\\s?\\d{2}\\s?\\d{2}$/,\n  'fr-FR': /^(\\+?33|0)[67]\\d{8}$/,\n  'fr-GF': /^(\\+?594|0|00594)[67]\\d{8}$/,\n  'fr-GP': /^(\\+?590|0|00590)[67]\\d{8}$/,\n  'fr-MQ': /^(\\+?596|0|00596)[67]\\d{8}$/,\n  'fr-RE': /^(\\+?262|0|00262)[67]\\d{8}$/,\n  'he-IL': /^(\\+972|0)([23489]|5[012345689]|77)[1-9]\\d{6}$/,\n  'hu-HU': /^(\\+?36)(20|30|70)\\d{7}$/,\n  'id-ID': /^(\\+?62|0)8(1[123456789]|2[1238]|3[1238]|5[12356789]|7[78]|9[56789]|8[123456789])([\\s?|\\d]{5,11})$/,\n  'it-IT': /^(\\+?39)?\\s?3\\d{2} ?\\d{6,7}$/,\n  'ja-JP': /^(\\+81[ \\-]?(\\(0\\))?|0)[6789]0[ \\-]?\\d{4}[ \\-]?\\d{4}$/,\n  'kk-KZ': /^(\\+?7|8)?7\\d{9}$/,\n  'kl-GL': /^(\\+?299)?\\s?\\d{2}\\s?\\d{2}\\s?\\d{2}$/,\n  'ko-KR': /^((\\+?82)[ \\-]?)?0?1([0|1|6|7|8|9]{1})[ \\-]?\\d{3,4}[ \\-]?\\d{4}$/,\n  'lt-LT': /^(\\+370|8)\\d{8}$/,\n  'ms-MY': /^(\\+?6?01){1}(([0145]{1}(\\-|\\s)?\\d{7,8})|([236789]{1}(\\s|\\-)?\\d{7}))$/,\n  'nb-NO': /^(\\+?47)?[49]\\d{7}$/,\n  'ne-NP': /^(\\+?977)?9[78]\\d{8}$/,\n  'nl-BE': /^(\\+?32|0)4?\\d{8}$/,\n  'nl-NL': /^(\\+?31|0)6?\\d{8}$/,\n  'nn-NO': /^(\\+?47)?[49]\\d{7}$/,\n  'pl-PL': /^(\\+?48)? ?[5-8]\\d ?\\d{3} ?\\d{2} ?\\d{2}$/,\n  'pt-BR': /(?=^(\\+?5{2}\\-?|0)[1-9]{2}\\-?\\d{4}\\-?\\d{4}$)(^(\\+?5{2}\\-?|0)[1-9]{2}\\-?[6-9]{1}\\d{3}\\-?\\d{4}$)|(^(\\+?5{2}\\-?|0)[1-9]{2}\\-?9[6-9]{1}\\d{3}\\-?\\d{4}$)/,\n  'pt-PT': /^(\\+?351)?9[1236]\\d{7}$/,\n  'ro-RO': /^(\\+?4?0)\\s?7\\d{2}(\\/|\\s|\\.|\\-)?\\d{3}(\\s|\\.|\\-)?\\d{3}$/,\n  'ru-RU': /^(\\+?7|8)?9\\d{9}$/,\n  'sl-SI': /^(\\+386\\s?|0)(\\d{1}\\s?\\d{3}\\s?\\d{2}\\s?\\d{2}|\\d{2}\\s?\\d{3}\\s?\\d{3})$/,\n  'sk-SK': /^(\\+?421)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,\n  'sr-RS': /^(\\+3816|06)[- \\d]{5,9}$/,\n  'sv-SE': /^(\\+?46|0)[\\s\\-]?7[\\s\\-]?[02369]([\\s\\-]?\\d){7}$/,\n  'th-TH': /^(\\+66|66|0)\\d{9}$/,\n  'tr-TR': /^(\\+?90|0)?5\\d{9}$/,\n  'uk-UA': /^(\\+?38|8)?0\\d{9}$/,\n  'vi-VN': /^(\\+?84|0)((3([2-9]))|(5([2689]))|(7([0|6-9]))|(8([1-6|89]))|(9([0-9])))([0-9]{7})$/,\n  'zh-CN': /^((\\+|00)86)?1([358][0-9]|4[579]|6[67]|7[01235678]|9[189])[0-9]{8}$/,\n  'zh-TW': /^(\\+?886\\-?|0)?9\\d{8}$/,\n};\n/* eslint-enable max-len */\n\n// aliases\nphones['en-CA'] = phones['en-US'];\nphones['fr-BE'] = phones['nl-BE'];\nphones['zh-HK'] = phones['en-HK'];\nphones['zh-MO'] = phones['en-MO'];\n\n\n/**\n * Optional configuration \n * If `strictMode` is set to true, \n * the mobile phone number must be supplied \n * with the country code and therefore must start with +. \n * The supported localelist is exported via isMobilePhoneLocales.\n */\nexport interface IsMobilePhoneOptions {\n  strictMode:boolean\n}\n\n/**\n * Checks whether the `target` string is a valid Mobile Phone Number\n * \n * @param target The target string\n * @param locale The locale\n * @param options The options\n * @throws Error If the local passed in is not supported.\n * @return true if the `target` is a valid Mobile Phone Number, false otherwise\n */\nexport function isMobilePhone(target:string, locale:string, options?:IsMobilePhoneOptions) {\n  assertString(target);\n  if (options && options.strictMode && !target.startsWith('+')) {\n    return false;\n  }\n  if (Array.isArray(locale)) {\n    return locale.some((key) => {\n      // https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md#ignoring-code-for-coverage-purposes\n      // istanbul ignore else\n      if (phones.hasOwnProperty(key)) {\n        const phone = phones[key];\n        if (phone.test(target)) {\n          return true;\n        }\n      }\n      return false;\n    });\n  } else if (locale in phones) {\n    return phones[locale].test(target);\n    // alias falsey locale as 'any'\n  } else if (!locale || locale === 'any') {\n    for (const key in phones) {\n      // istanbul ignore else\n      if (phones.hasOwnProperty(key)) {\n        const phone = phones[key];\n        if (phone.test(target)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  throw new Error(`Invalid locale '${locale}'`);\n}\n\n/**\n * The supported locale list.\n */\nexport const isMobilePhoneLocales = Object.keys(phones);\n","import { assertString } from '../util/assertString';\n\n/* eslint-disable no-control-regex */\nconst multibyte = /[^\\x00-\\x7F]/;\n/* eslint-enable no-control-regex */\n\n/**\n * Checks whether the `target` string contains one or more multibyte characters\n * \n * @param target The target string\n * @return true if the `target` contains one or more multibyte characters, false otherwise\n */\nexport function isMultibyte(target:string) {\n  assertString(target);\n  return multibyte.test(target);\n}\n","import { assertString } from '../util/assertString';\n\nconst numeric = /^[+-]?([0-9]*[.])?[0-9]+$/;\nconst numericNoSymbols = /^[0-9]+$/;\n\n/**\n * Checks whether the `target` string contains only numbers\n * \n * @param target The target string\n * @param options The options\n * @return true if the `target` contains only numbers, false otherwise\n */\nexport function isNumeric(str, options) {\n  assertString(str);\n  if (options && options.no_symbols) {\n    return numericNoSymbols.test(str);\n  }\n  return numeric.test(str);\n}\n","import { assertString } from '../util/assertString';\n\nconst octal = /^(0o)?[0-7]+$/i;\n\n/**\n * Checks whether the `target` string is a valid Octal number\n * \n * @param target The target string\n * @return true if the `target` is a valid Octal number, false otherwise\n */\nexport function isOctal(target:string) {\n  assertString(target);\n  return octal.test(target);\n}\n","/**\n * Reference:\n * https://en.wikipedia.org/ -- Wikipedia\n * https://docs.microsoft.com/en-us/microsoft-365/compliance/eu-passport-number -- EU Passport Number\n * https://countrycode.org/ -- Country Codes\n */\nconst passportRegexByCountryCode = {\n  AM: /^[A-Z]{2}\\d{7}$/, // ARMENIA\n  AR: /^[A-Z]{3}\\d{6}$/, // ARGENTINA\n  AT: /^[A-Z]\\d{7}$/, // AUSTRIA\n  AU: /^[A-Z]\\d{7}$/, // AUSTRALIA\n  BE: /^[A-Z]{2}\\d{6}$/, // BELGIUM\n  BG: /^\\d{9}$/, // BULGARIA\n  CA: /^[A-Z]{2}\\d{6}$/, // CANADA\n  CH: /^[A-Z]\\d{7}$/, // SWITZERLAND\n  CN: /^[GE]\\d{8}$/, // CHINA [G=Ordinary, E=Electronic] followed by 8-digits\n  CY: /^[A-Z](\\d{6}|\\d{8})$/, // CYPRUS\n  CZ: /^\\d{8}$/, // CZECH REPUBLIC\n  DE: /^[CFGHJKLMNPRTVWXYZ0-9]{9}$/, // GERMANY\n  DK: /^\\d{9}$/, // DENMARK\n  EE: /^([A-Z]\\d{7}|[A-Z]{2}\\d{7})$/, // ESTONIA (K followed by 7-digits), e-passports have 2 UPPERCASE followed by 7 digits\n  ES: /^[A-Z0-9]{2}([A-Z0-9]?)\\d{6}$/, // SPAIN\n  FI: /^[A-Z]{2}\\d{7}$/, // FINLAND\n  FR: /^\\d{2}[A-Z]{2}\\d{5}$/, // FRANCE\n  GB: /^\\d{9}$/, // UNITED KINGDOM\n  GR: /^[A-Z]{2}\\d{7}$/, // GREECE\n  HR: /^\\d{9}$/, // CROATIA\n  HU: /^[A-Z]{2}(\\d{6}|\\d{7})$/, // HUNGARY\n  IE: /^[A-Z0-9]{2}\\d{7}$/, // IRELAND\n  IS: /^(A)\\d{7}$/, // ICELAND\n  IT: /^[A-Z0-9]{2}\\d{7}$/, // ITALY\n  JP: /^[A-Z]{2}\\d{7}$/, // JAPAN\n  KR: /^[MS]\\d{8}$/, // SOUTH KOREA, REPUBLIC OF KOREA, [S=PS Passports, M=PM Passports]\n  LT: /^[A-Z0-9]{8}$/, // LITHUANIA\n  LU: /^[A-Z0-9]{8}$/, // LUXEMBURG\n  LV: /^[A-Z0-9]{2}\\d{7}$/, // LATVIA\n  MT: /^\\d{7}$/, // MALTA\n  NL: /^[A-Z]{2}[A-Z0-9]{6}\\d$/, // NETHERLANDS\n  PO: /^[A-Z]{2}\\d{7}$/, // POLAND\n  PT: /^[A-Z]\\d{6}$/, // PORTUGAL\n  RO: /^\\d{8,9}$/, // ROMANIA\n  SE: /^\\d{8}$/, // SWEDEN\n  SL: /^(P)[A-Z]\\d{7}$/, // SLOVANIA\n  SK: /^[0-9A-Z]\\d{7}$/, // SLOVAKIA\n  TR: /^[A-Z]\\d{8}$/, // TURKEY\n  UA: /^[A-Z]{2}\\d{6}$/, // UKRAINE\n  US: /^\\d{9}$/, // UNITED STATES\n};\n\n/**\n * Check if `target` is a valid passport number\n * relative to provided `arg` ISO Country Code.\n *\n * @param target The passport number\n * @param arg The country code\n * @return true if the `target` is a passport number, false otherwise\n */\nexport function isPassportNumber(target:string, arg:string) {\n  /** Remove All Whitespaces, Convert to UPPERCASE */\n  const normalizedStr = target.replace(/\\s/g, '').toUpperCase();\n\n  return (arg.toUpperCase() in passportRegexByCountryCode) &&\n    passportRegexByCountryCode[arg].test(normalizedStr);\n}","import { assertString } from '../util/assertString';\n\n// common patterns\nconst threeDigit = /^\\d{3}$/;\nconst fourDigit = /^\\d{4}$/;\nconst fiveDigit = /^\\d{5}$/;\nconst sixDigit = /^\\d{6}$/;\n\nconst patterns = {\n  AD: /^AD\\d{3}$/,\n  AT: fourDigit,\n  AU: fourDigit,\n  BE: fourDigit,\n  BG: fourDigit,\n  BR: /^\\d{5}-\\d{3}$/,\n  CA: /^[ABCEGHJKLMNPRSTVXY]\\d[ABCEGHJ-NPRSTV-Z][\\s\\-]?\\d[ABCEGHJ-NPRSTV-Z]\\d$/i,\n  CH: fourDigit,\n  CZ: /^\\d{3}\\s?\\d{2}$/,\n  DE: fiveDigit,\n  DK: fourDigit,\n  DZ: fiveDigit,\n  EE: fiveDigit,\n  ES: fiveDigit,\n  FI: fiveDigit,\n  FR: /^\\d{2}\\s?\\d{3}$/,\n  GB: /^(gir\\s?0aa|[a-z]{1,2}\\d[\\da-z]?\\s?(\\d[a-z]{2})?)$/i,\n  GR: /^\\d{3}\\s?\\d{2}$/,\n  HR: /^([1-5]\\d{4}$)/,\n  HU: fourDigit,\n  ID: fiveDigit,\n  IE: /^(?!.*(?:o))[A-z]\\d[\\dw]\\s\\w{4}$/i,\n  IL: fiveDigit,\n  IN: /^((?!10|29|35|54|55|65|66|86|87|88|89)[1-9][0-9]{5})$/,\n  IS: threeDigit,\n  IT: fiveDigit,\n  JP: /^\\d{3}\\-\\d{4}$/,\n  KE: fiveDigit,\n  LI: /^(948[5-9]|949[0-7])$/,\n  LT: /^LT\\-\\d{5}$/,\n  LU: fourDigit,\n  LV: /^LV\\-\\d{4}$/,\n  MX: fiveDigit,\n  MT: /^[A-Za-z]{3}\\s{0,1}\\d{4}$/,\n  NL: /^\\d{4}\\s?[a-z]{2}$/i,\n  NO: fourDigit,\n  NZ: fourDigit,\n  PL: /^\\d{2}\\-\\d{3}$/,\n  PR: /^00[679]\\d{2}([ -]\\d{4})?$/,\n  PT: /^\\d{4}\\-\\d{3}?$/,\n  RO: sixDigit,\n  RU: sixDigit,\n  SA: fiveDigit,\n  SE: /^[1-9]\\d{2}\\s?\\d{2}$/,\n  SI: fourDigit,\n  SK: /^\\d{3}\\s?\\d{2}$/,\n  TN: fourDigit,\n  TW: /^\\d{3}(\\d{2})?$/,\n  UA: fiveDigit,\n  US: /^\\d{5}(-\\d{4})?$/,\n  ZA: fourDigit,\n  ZM: fiveDigit,\n};\n\nexport const postalCodeLocales = Object.keys(patterns);\n\n/**\n * Checks whether the `target` string is a valid postal code\n * \n * @param target The target string\n * @param arg The locale\n * @return true if the `target` is a valid postal code, false otherwise\n */\nexport function isPostalCode(target:string, arg:string) {\n  assertString(target);\n  if (arg in patterns) {\n    return patterns[arg].test(target);\n  } else if (arg === 'any') {\n    for (const key in patterns) {\n      // https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md#ignoring-code-for-coverage-purposes\n      // istanbul ignore else\n      if (patterns.hasOwnProperty(key)) {\n        const pattern = patterns[key];\n        if (pattern.test(target)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  throw new Error(`Invalid locale '${arg}'`);\n}","import { assertString } from '../util/assertString';\n\n/* Based on https://tools.ietf.org/html/rfc3339#section-5.6 */\n\nconst dateFullYear = /[0-9]{4}/;\nconst dateMonth = /(0[1-9]|1[0-2])/;\nconst dateMDay = /([12]\\d|0[1-9]|3[01])/;\n\nconst timeHour = /([01][0-9]|2[0-3])/;\nconst timeMinute = /[0-5][0-9]/;\nconst timeSecond = /([0-5][0-9]|60)/;\n\nconst timeSecFrac = /(\\.[0-9]+)?/;\nconst timeNumOffset = new RegExp(`[-+]${timeHour.source}:${timeMinute.source}`);\nconst timeOffset = new RegExp(`([zZ]|${timeNumOffset.source})`);\n\nconst partialTime = new RegExp(`${timeHour.source}:${timeMinute.source}:${timeSecond.source}${timeSecFrac.source}`);\n\nconst fullDate = new RegExp(`${dateFullYear.source}-${dateMonth.source}-${dateMDay.source}`);\nconst fullTime = new RegExp(`${partialTime.source}${timeOffset.source}`);\n\nconst rfc3339 = new RegExp(`${fullDate.source}[ tT]${fullTime.source}`);\n\n/**\n * Check if `target` is a valid RFC3339 timestamp\n *\n * @param target The time stamp\n * @return true if the `target` is a valid RFC3339 timestamp, false otherwise\n * \n * @example\n```\nconst isRFC3339:boolean = isRFC3339('2002-10-02T15:00:00Z')\n```\n */\nexport function isRFC3339(target:string) {\n  assertString(target);\n  return rfc3339.test(target);\n}\n","import { assertString } from '../util/assertString';\n\nconst rgbColor = /^rgb\\((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]),){2}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\)$/;\nconst rgbaColor = /^rgba\\((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]),){3}(0?\\.\\d|1(\\.0)?|0(\\.0)?)\\)$/;\nconst rgbColorPercent = /^rgb\\((([0-9]%|[1-9][0-9]%|100%),){2}([0-9]%|[1-9][0-9]%|100%)\\)/;\nconst rgbaColorPercent = /^rgba\\((([0-9]%|[1-9][0-9]%|100%),){3}(0?\\.\\d|1(\\.0)?|0(\\.0)?)\\)/;\n\n/**\n * Check if `target` is a valid RGB color\n *\n * @param target The RGB color\n * @return true if the `target` is a valid RGB color, false otherwise\n * \n */\nexport function isRgbColor(target:string, includePercentValues:string = `true`) {\n  assertString(target);\n\n  if (!includePercentValues) {\n    return rgbColor.test(target) || rgbaColor.test(target);\n  }\n\n  return rgbColor.test(target) ||\n    rgbaColor.test(target) ||\n    rgbColorPercent.test(target) ||\n    rgbaColorPercent.test(target);\n}\n","import {assertString} from '../util/assertString';\nimport {multilineRegexp} from '../util/multilineRegex';\n\n/**\n * Regular Expression to match\n * semantic versioning (SemVer)\n * built from multi-line, multi-parts regexp\n * Reference: https://semver.org/\n */\nconst semanticVersioningRegex = multilineRegexp([\n  '^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)',\n  '(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))',\n  '?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$',\n]);\n\n/**\n * Check if `target` is a valid semver version\n *\n * @param target The target\n * @return true if the `target` is a valid semver version, false otherwise\n */\nexport function isSemVer(target:string) {\n  assertString(target)\n  return semanticVersioningRegex.test(target)\n}\n","/**\n * Build RegExp object from an array\n * of multiple/multi-line regexp parts\n *\n * @param {string[]} parts\n * @param {string} flags\n * @return {object} - RegExp object\n */\nexport function multilineRegexp(parts, flags = '') {\n  const regexpAsStringLiteral = parts.join('');\n\n  return new RegExp(regexpAsStringLiteral, flags);\n}\n","import { assertString } from '../util/assertString';\n\nlet charsetRegex = /^[^-_](?!.*?[-_]{2,})([a-z0-9\\\\-]{1,}).*[^-_]$/;\n\n/**\n * Check if `target` is a valid slug\n *\n * @param target The target\n * @return true if the `target` is a valid slug, false otherwise\n */\nexport function isSlug(target:string) {\n  assertString(target);\n  return (charsetRegex.test(target));\n}\n","import { assertString } from '../util/assertString';\n\nconst surrogatePair = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/;\n\n/**\n * Check if `target` is a valid surrogate pair\n *\n * @param target The target\n * @return true if the `target` a valid surrogate pair, false otherwise\n */\nexport function isSurrogatePair(target:string) {\n  assertString(target);\n  return surrogatePair.test(target);\n}\n","import { assertString } from '../util/assertString';\n\nimport { isFQDN } from './isFQDN';\nimport { isIP } from './isIP';\nimport { merge } from '../util/merge';\n\n/*\noptions for isURL method\n\nrequire_protocol - if set as true isURL will return false if protocol is not present in the URL\nrequire_valid_protocol - isURL will check if the URL's protocol is present in the protocols option\nprotocols - valid protocols can be modified with this option\nrequire_host - if set as false isURL will not check if host is present in the URL\nallow_protocol_relative_urls - if set as true protocol relative URLs will be allowed\n\n*/\n\n/**\n * IsURL Options.\n */\nexport interface IsURLOptions {\n  protocols?: string[]\n  require_tld?: boolean\n  require_protocol?: boolean\n  require_host?: boolean\n  require_valid_protocol?: boolean\n  allow_underscores?: boolean\n  host_whitelist?: false | string[]\n  host_blacklist?: false | string[]\n  allow_trailing_dot?: boolean\n  allow_protocol_relative_urls?: boolean\n}\n\nconst default_url_options:IsURLOptions = {\n  protocols: ['http', 'https', 'ftp'],\n  require_tld: true,\n  require_protocol: false,\n  require_host: true,\n  require_valid_protocol: true,\n  allow_underscores: false,\n  allow_trailing_dot: false,\n  allow_protocol_relative_urls: false,\n}\n\nconst wrapped_ipv6 = /^\\[([^\\]]+)\\](?::([0-9]+))?$/;\n\nfunction isRegExp(obj) {\n  return Object.prototype.toString.call(obj) === '[object RegExp]';\n}\n\nfunction checkHost(host, matches) {\n  for (let i = 0; i < matches.length; i++) {\n    let match = matches[i];\n    if (host === match || (isRegExp(match) && match.test(host))) {\n      return true;\n    }\n  }\n  return false;\n}\n/**\n * Checks whether the `target` string is valid URL\n * \n * @param target The target string\n * @param options The options\n * @return true if the `target` is a valid URL, false otherwise\n */\nexport function isURL(target:string, options) {\n  assertString(target);\n  if (!target || target.length >= 2083 || /[\\s<>]/.test(target)) {\n    return false;\n  }\n  if (target.indexOf('mailto:') === 0) {\n    return false;\n  }\n  options = merge(options, default_url_options);\n  let protocol, auth, host, hostname, port, port_str, split, ipv6;\n\n  split = target.split('#');\n  target = split.shift();\n\n  split = target.split('?');\n  target = split.shift();\n\n  split = target.split('://');\n  if (split.length > 1) {\n    protocol = split.shift().toLowerCase();\n    if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {\n      return false;\n    }\n  } else if (options.require_protocol) {\n    return false;\n  } else if (target.substr(0, 2) === '//') {\n    if (!options.allow_protocol_relative_urls) {\n      return false;\n    }\n    split[0] = target.substr(2);\n  }\n  target = split.join('://');\n\n  if (target === '') {\n    return false;\n  }\n\n  split = target.split('/');\n  target = split.shift();\n\n  if (target === '' && !options.require_host) {\n    return true;\n  }\n\n  split = target.split('@');\n  if (split.length > 1) {\n    if (options.disallow_auth) {\n      return false;\n    }\n    auth = split.shift();\n    if (auth.indexOf(':') >= 0 && auth.split(':').length > 2) {\n      return false;\n    }\n  }\n  hostname = split.join('@');\n\n  port_str = null;\n  ipv6 = null;\n  const ipv6_match = hostname.match(wrapped_ipv6);\n  if (ipv6_match) {\n    host = '';\n    ipv6 = ipv6_match[1];\n    port_str = ipv6_match[2] || null;\n  } else {\n    split = hostname.split(':');\n    host = split.shift();\n    if (split.length) {\n      port_str = split.join(':');\n    }\n  }\n\n  if (port_str !== null) {\n    port = parseInt(port_str, 10);\n    if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {\n      return false;\n    }\n  }\n\n  if (!isIP(host) && !isFQDN(host, options) && (!ipv6 || !isIP(ipv6, '6'))) {\n    return false;\n  }\n\n  host = host || ipv6;\n\n  if (options.host_whitelist && !checkHost(host, options.host_whitelist)) {\n    return false;\n  }\n  if (options.host_blacklist && checkHost(host, options.host_blacklist)) {\n    return false;\n  }\n\n  return true;\n}\n","import { assertString } from '../util/assertString';\n\nconst uuid = {\n  3: /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,\n  4: /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,\n  5: /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,\n  all: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i,\n};\n\n/**\n * Checks whether the `target` is a valid UUID\n * \n * @param target The target string\n * @param version The version\n * @return true if the `target` is  a valid UUID, false otherwise\n */\nexport function isUUID(str, version?) {\n  version = version ? version : 'all'\n  assertString(str);\n  const pattern = uuid[version];\n  return pattern && pattern.test(str);\n}","import { assertString } from '../util/assertString';\n\nexport function blacklist(str: string, chars: string) {\n  assertString(str);\n  return str.replace(new RegExp(`[${chars}]+`, 'g'), '');\n}","import { assertString } from '../util/assertString';\n\nexport function ltrim(str, chars) {\n  assertString(str);\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping\n  const pattern = chars ? new RegExp(`^[${chars.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}]+`, 'g') : /^\\s+/g;\n  return str.replace(pattern, '');\n}\n","import { assertString } from '../util/assertString';\n\nexport function rtrim(str, chars) {\n  assertString(str);\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping\n  const pattern = chars ? new RegExp(`[${chars.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}]+$`, 'g') : /\\s+$/g;\n  return str.replace(pattern, '');\n}\n","import { assertString } from '../util/assertString';\nimport { toString } from '../util/toString';\n\n/**\n * Test whether the target string contains the arg.\n * \n * @param target The string that should contains the element\n * @param arg The contained string\n * @return true if the `target` string contains the `arg` string, false otherwise\n */\nexport function contains(target: string, arg: string) {\n  assertString(target);\n  return target.indexOf(toString(arg)) >= 0;\n}\n","import { assertString } from '../util/assertString'\n\n/**\n * Compares the `target` and `arg` strings for strict (`===`) equality\n * \n * @param target The target string to compare to\n * @param arg The argument to perform the comparison with \n * @return true if the `target` is strictly equal to the `arg`, false otherwise\n */\nexport function equals(target: string, arg: string) {\n  assertString(target)\n  return target === arg\n}","import { assertString } from '../util/assertString';\n\n/**\n * Replaces <, >, &, ', \" and / with HTML entities. \n * @param str The string to perform the `escape` operation on.\n */\nexport function escape(str:string) {\n  assertString(str);\n  return (str.replace(/&/g, '&amp;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#x27;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\\//g, '&#x2F;')\n    .replace(/\\\\/g, '&#x5C;')\n    .replace(/`/g, '&#96;'))\n}","import { assertString } from '../util/assertString';\nimport { toDate } from '../sanitizers/toDate';\n\n/**\n * Checks whether the `target` date comes after the `arg` date\n * \n * @param target The target date\n * @param arg The argument to perform the comparison with \n * @return true if the `target` date comes after the `arg` date, false otherwise\n */\nexport function isAfter(target: string, arg: string = String(new Date())) {\n  assertString(target);\n  const comparison = toDate(arg);\n  const original = toDate(target);\n  return !!(original && comparison && original > comparison);\n}","import { assertString } from '../util/assertString';\nimport { toDate } from '../sanitizers/toDate';\n\n/**\n * Checks whether the `target` date comes before the `arg` date\n * \n * @param target The target date\n * @param arg The argument  \n * @return true if the `target` date comes before the `arg` date, false otherwise\n */\nexport function isBefore(target: string, arg: string = String(new Date())) {\n  assertString(target);\n  const comparison = toDate(arg);\n  const original = toDate(target);\n  return !!(original && comparison && original < comparison);\n}\n","import { assertString } from '../util/assertString';\n\n/**\n * Checks whether the `target` is a boolean value\n * meaning it contains of of `['true', 'false', '1', '0']` \n * \n * @param target The target string\n * @return true if the `target` is a boolean value, false otherwise\n */\nexport function isBoolean(str: string) {\n  assertString(str);\n  return (['true', 'false', '1', '0'].indexOf(str) >= 0);\n}\n","import { assertString } from '../util/assertString';\nimport { toFloat } from '../sanitizers/toFloat';\n\n/**\n * Checks whether the `target` is divisible by the arg\n * \n * @param target The target string\n * @param arg The divisor\n * @return true if the `target` is divisible by the `arg`, false otherwise\n */\nexport function isDivisibleBy(target: string, arg: string) {\n  assertString(target);\n  return toFloat(target) % parseInt(arg, 10) === 0;\n}\n","import { assertString } from '../util/assertString';\n\nconst issn = '^\\\\d{4}-?\\\\d{3}[\\\\dX]$';\n\n/**\n * Checks whether the `target` string is a valid ISSN\n * \n * @param target The target string\n * @param options The options\n * @return true if the `target` is a valid ISSN, false otherwise\n */\nexport function isISSN(str, options: any = {}) {\n  assertString(str);\n  let testIssn: any = issn;\n  testIssn = options.require_hyphen ? testIssn.replace('?', '') : testIssn;\n  testIssn = options.case_sensitive ? new RegExp(testIssn) : new RegExp(testIssn, 'i');\n  if (!testIssn.test(str)) {\n    return false;\n  }\n  const digits = str.replace('-', '').toUpperCase();\n  let checksum = 0;\n  for (let i = 0; i < digits.length; i++) {\n    const digit = digits[i];\n    checksum += (digit === 'X' ? 10 : +digit) * (8 - i);\n  }\n  return checksum % 11 === 0;\n}\n","import { assertString } from '../util/assertString';\nimport { toString } from '../util/toString';\n/**\n * Checks whether the `target` string is in the array of allowed values\n * \n * @param target The target string\n * @param options The options\n * @return true if the `target` is in the array of allowed values, false otherwise\n */\nexport function isIn(str: string, options) {\n  assertString(str);\n  let i;\n  if (Object.prototype.toString.call(options) === '[object Array]') {\n    const array = [];\n    for (i in options) {\n      // https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md#ignoring-code-for-coverage-purposes\n      // istanbul ignore else\n      if ({}.hasOwnProperty.call(options, i)) {\n        array[i] = toString(options[i]);\n      }\n    }\n    return array.indexOf(str) >= 0;\n  } else if (typeof options === 'object') {\n    return options.hasOwnProperty(str);\n  } else if (options && typeof options.indexOf === 'function') {\n    return options.indexOf(str) >= 0;\n  }\n  return false;\n}","import { assertString } from '../util/assertString';\n\n/**\n * Checks whether the `target` string is valid JSON\n * \n * @param target The target string\n * @return true if the `target` is a valid ISSN, false otherwise\n */\nexport function isJSON(target:string) {\n  assertString(target);\n  try {\n    const obj = JSON.parse(target);\n    return !!obj && typeof obj === 'object';\n  } catch (e) { /* ignore */ }\n  return false;\n}\n","import { assertString } from '../util/assertString';\n\n/* eslint-disable prefer-rest-params */\n\n/**\n * Checks whether the `target` string length is valid\n * \n * @param target The target string\n * @param options The options\n * @return true if the `target` has a valid length, false otherwise\n */\nexport function isLength(target:string, options) {\n  assertString(target);\n  let min;\n  let max;\n  if (typeof (options) === 'object') {\n    min = options.min || 0;\n    max = options.max;\n  } else { // backwards compatibility: isLength(str, min [, max])\n    min = arguments[1] || 0;\n    max = arguments[2];\n  }\n  const surrogatePairs = target.match(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g) || [];\n  const len = target.length - surrogatePairs.length;\n  return len >= min && (typeof max === 'undefined' || len <= max);\n}\n","import { assertString } from '../util/assertString';\n\n/**\n * Checks whether the `target` string is lowercase\n * \n * @param target The target string\n * @return true if the `target` is lowercase, false otherwise\n */\nexport function isLowercase(target:string) {\n  assertString(target);\n  return target === target.toLowerCase();\n}\n","import { assertString } from '../util/assertString';\n\nimport { isHexadecimal } from './isHexadecimal';\n\n/**\n * Checks whether the `target` string is a valid MongoID\n * \n * @param target The target string\n * @return true if the `target` is a valid MongoID, false otherwise\n */\nexport function isMongoId(target:string) {\n  assertString(target);\n  return isHexadecimal(target) && target.length === 24;\n}\n","import { isInt } from './isInt';\n\n/**\n * Check if `target` is a valid port number\n *\n * @param target The port number\n * @return true if the `target` is a port number, false otherwise\n * \n * @example\n```\nconst isPortNumber:boolean = isPort('4200')\n```\n */\nexport function isPort(target:string) {\n  return isInt(target, { min: 0, max: 65535 });\n}\n","import { assertString } from '../util/assertString';\n\n\n/**\n * Check if `target` is uppercase\n *\n * @param target The target\n * @return true if the `target` is uppercase, false otherwise\n */\nexport function isUppercase(target:string) {\n  assertString(target);\n  return target === target.toUpperCase();\n}\n","import { assertString } from '../util/assertString';\n\nimport { fullWidth } from './isFullWidth';\nimport { halfWidth } from './isHalfWidth';\n\n/**\n * Checks whether the `target` is variable width\n * \n * @param target The target string\n * @return true if the `target` is variable width, false otherwise\n */\nexport function isVariableWidth(target:string) {\n  assertString(target);\n  return fullWidth.test(target) && halfWidth.test(target);\n}\n","import { assertString } from '../util/assertString';\n//checks characters if they appear in the whitelist.\n\n/**\n * Checks whether the `target` string appears in the white list `arg`\n * \n * @param target The target string\n * @param arg The white list\n * @return true if the `target` appears in the whitelist, false otherwise\n */\nexport function isWhitelisted(target:string, arg:string) {\n  assertString(target);\n  for (let i = target.length - 1; i >= 0; i--) {\n    if (arg.indexOf(target[i]) === -1) {\n      return false;\n    }\n  }\n  return true;\n}\n","import { assertString } from '../util/assertString';\n\n/**\n * Check whether the target matches the pattern\n * @param target The target\n * @param pattern The RegExp\n * @param modifiers The optional modifier\n * @return true if the target matches, false otherwise\n */\nexport function matches(target:string, pattern:RegExp, modifiers?:string) {\n  assertString(target);\n  if (Object.prototype.toString.call(pattern) !== '[object RegExp]') {\n    pattern = new RegExp(pattern, modifiers);\n  }\n  return pattern.test(target);\n}\n","import { assertString } from '../util/assertString';\n\nimport { blacklist } from './blacklist';\n\nexport function stripLow(str, keep_new_lines) {\n  assertString(str);\n  const chars = keep_new_lines ? '\\\\x00-\\\\x09\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x7F' : '\\\\x00-\\\\x1F\\\\x7F';\n  return blacklist(str, chars);\n}\n","import { assertString } from '../util/assertString';\n\nexport function toBoolean(str, strict) {\n  assertString(str);\n  if (strict) {\n    return str === '1' || /^true$/i.test(str);\n  }\n  return str !== '0' && !/^false$/i.test(str) && str !== '';\n}\n","import { assertString } from '../util/assertString';\n\nexport function toInt(str, radix) {\n  assertString(str);\n  return parseInt(str, radix || 10);\n}\n","import { rtrim } from './rtrim';\nimport { ltrim }  from './ltrim';\n\nexport function trim(str, chars) {\n  return rtrim(ltrim(str, chars), chars);\n}\n","import { assertString } from '../util/assertString';\n\nexport function unescape(str) {\n  assertString(str);\n  return (str.replace(/&amp;/g, '&')\n    .replace(/&quot;/g, '\"')\n    .replace(/&#x27;/g, \"'\")\n    .replace(/&lt;/g, '<')\n    .replace(/&gt;/g, '>')\n    .replace(/&#x2F;/g, '/')\n    .replace(/&#x5C;/g, '\\\\')\n    .replace(/&#96;/g, '`'));\n}\n","import { assertString } from '../util/assertString';\n\nexport function whitelist(str, chars) {\n  assertString(str);\n  return str.replace(new RegExp(`[^${chars}]+`, 'g'), '');\n}"]}